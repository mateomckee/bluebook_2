/*! For license information please see main.aeb5555c.js.LICENSE.txt */
(() => { var e = { 694: (e, t) => { var n; !function () { "use strict"; var r = {}.hasOwnProperty; function i() { for (var e = [], t = 0; t < arguments.length; t++) { var n = arguments[t]; if (n) { var o = typeof n; if ("string" === o || "number" === o) e.push(n); else if (Array.isArray(n)) { if (n.length) { var a = i.apply(null, n); a && e.push(a) } } else if ("object" === o) { if (n.toString !== Object.prototype.toString && !n.toString.toString().includes("[native code]")) { e.push(n.toString()); continue } for (var s in n) r.call(n, s) && n[s] && e.push(s) } } } return e.join(" ") } e.exports ? (i.default = i, e.exports = i) : void 0 === (n = function () { return i }.apply(t, [])) || (e.exports = n) }() }, 28: e => { !function () { function t(e, t) { document.addEventListener ? e.addEventListener("scroll", t, !1) : e.attachEvent("scroll", t) } function n(e) { this.g = document.createElement("div"), this.g.setAttribute("aria-hidden", "true"), this.g.appendChild(document.createTextNode(e)), this.h = document.createElement("span"), this.i = document.createElement("span"), this.m = document.createElement("span"), this.j = document.createElement("span"), this.l = -1, this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;", this.h.appendChild(this.m), this.i.appendChild(this.j), this.g.appendChild(this.h), this.g.appendChild(this.i) } function r(e, t) { e.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + t + ";" } function i(e) { var t = e.g.offsetWidth, n = t + 100; return e.j.style.width = n + "px", e.i.scrollLeft = n, e.h.scrollLeft = e.h.scrollWidth + 100, e.l !== t && (e.l = t, !0) } function o(e, n) { function r() { var e = o; i(e) && null !== e.g.parentNode && n(e.l) } var o = e; t(e.h, r), t(e.i, r), i(e) } function a(e, t, n) { t = t || {}, n = n || window, this.family = e, this.style = t.style || "normal", this.weight = t.weight || "normal", this.stretch = t.stretch || "normal", this.context = n } var s = null, l = null, c = null, u = null; function d(e) { return null === u && (u = !!e.document.fonts), u } function h(e, t) { var n = e.style, r = e.weight; if (null === c) { var i = document.createElement("div"); try { i.style.font = "condensed 100px sans-serif" } catch (o) { } c = "" !== i.style.font } return [n, r, c ? e.stretch : "", "100px", t].join(" ") } a.prototype.load = function (e, t) { var i = this, a = e || "BESbswy", c = 0, u = t || 3e3, f = (new Date).getTime(); return new Promise((function (e, t) { if (d(i.context) && !function (e) { return null === l && (d(e) && /Apple/.test(window.navigator.vendor) ? (e = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent), l = !!e && 603 > parseInt(e[1], 10)) : l = !1), l }(i.context)) { var p = new Promise((function (e, t) { !function n() { (new Date).getTime() - f >= u ? t(Error(u + "ms timeout exceeded")) : i.context.document.fonts.load(h(i, '"' + i.family + '"'), a).then((function (t) { 1 <= t.length ? e() : setTimeout(n, 25) }), t) }() })), g = new Promise((function (e, t) { c = setTimeout((function () { t(Error(u + "ms timeout exceeded")) }), u) })); Promise.race([g, p]).then((function () { clearTimeout(c), e(i) }), t) } else !function (e) { document.body ? e() : document.addEventListener ? document.addEventListener("DOMContentLoaded", (function t() { document.removeEventListener("DOMContentLoaded", t), e() })) : document.attachEvent("onreadystatechange", (function t() { "interactive" != document.readyState && "complete" != document.readyState || (document.detachEvent("onreadystatechange", t), e()) })) }((function () { function l() { var t; (t = -1 != m && -1 != b || -1 != m && -1 != v || -1 != b && -1 != v) && ((t = m != b && m != v && b != v) || (null === s && (t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), s = !!t && (536 > parseInt(t[1], 10) || 536 === parseInt(t[1], 10) && 11 >= parseInt(t[2], 10))), t = s && (m == y && b == y && v == y || m == x && b == x && v == x || m == w && b == w && v == w)), t = !t), t && (null !== _.parentNode && _.parentNode.removeChild(_), clearTimeout(c), e(i)) } var d = new n(a), p = new n(a), g = new n(a), m = -1, b = -1, v = -1, y = -1, x = -1, w = -1, _ = document.createElement("div"); _.dir = "ltr", r(d, h(i, "sans-serif")), r(p, h(i, "serif")), r(g, h(i, "monospace")), _.appendChild(d.g), _.appendChild(p.g), _.appendChild(g.g), i.context.document.body.appendChild(_), y = d.g.offsetWidth, x = p.g.offsetWidth, w = g.g.offsetWidth, function e() { if ((new Date).getTime() - f >= u) null !== _.parentNode && _.parentNode.removeChild(_), t(Error(u + "ms timeout exceeded")); else { var n = i.context.document.hidden; !0 !== n && void 0 !== n || (m = d.g.offsetWidth, b = p.g.offsetWidth, v = g.g.offsetWidth, l()), c = setTimeout(e, 50) } }(), o(d, (function (e) { m = e, l() })), r(d, h(i, '"' + i.family + '",sans-serif')), o(p, (function (e) { b = e, l() })), r(p, h(i, '"' + i.family + '",serif')), o(g, (function (e) { v = e, l() })), r(g, h(i, '"' + i.family + '",monospace')) })) })) }, e.exports = a }() }, 176: e => { "use strict"; e.exports = function (e, t, n, r, i, o, a, s) { if (!e) { var l; if (void 0 === t) l = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var c = [n, r, i, o, a, s], u = 0; (l = new Error(t.replace(/%s/g, (function () { return c[u++] })))).name = "Invariant Violation" } throw l.framesToPop = 1, l } } }, 573: (e, t, n) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return (0, o.default)((function () { for (var e = arguments.length, n = Array(e), r = 0; r < e; r++)n[r] = arguments[r]; var i = null; return t.forEach((function (e) { if (null == i) { var t = e.apply(void 0, n); null != t && (i = t) } })), i })) }; var r, i = n(54), o = (r = i) && r.__esModule ? r : { default: r }; e.exports = t.default }, 54: (e, t) => { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e) { function t(t, n, r, i, o, a) { var s = i || "<<anonymous>>", l = a || r; if (null == n[r]) return t ? new Error("Required " + o + " `" + l + "` was not specified in `" + s + "`.") : null; for (var c = arguments.length, u = Array(c > 6 ? c - 6 : 0), d = 6; d < c; d++)u[d - 6] = arguments[d]; return e.apply(void 0, [n, r, s, o, l].concat(u)) } var n = t.bind(null, !1); return n.isRequired = t.bind(null, !0), n }, e.exports = t.default }, 888: (e, t, n) => { "use strict"; var r = n(47); function i() { } function o() { } o.resetWarningCache = i, e.exports = function () { function e(e, t, n, i, o, a) { if (a !== r) { var s = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw s.name = "Invariant Violation", s } } function t() { return e } e.isRequired = e; var n = { array: e, bigint: e, bool: e, func: e, number: e, object: e, string: e, symbol: e, any: e, arrayOf: t, element: e, elementType: e, instanceOf: t, node: e, objectOf: t, oneOf: t, oneOfType: t, shape: t, exact: t, checkPropTypes: o, resetWarningCache: i }; return n.PropTypes = n, n } }, 7: (e, t, n) => { e.exports = n(888)() }, 47: e => { "use strict"; e.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED" }, 463: (e, t, n) => { "use strict"; var r = n(791), i = n(296); function o(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var a = new Set, s = {}; function l(e, t) { c(e, t), c(e + "Capture", t) } function c(e, t) { for (s[e] = t, e = 0; e < t.length; e++)a.add(t[e]) } var u = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), d = Object.prototype.hasOwnProperty, h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, p = {}; function g(e, t, n, r, i, o, a) { this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = a } var m = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function (e) { m[e] = new g(e, 0, !1, e, null, !1, !1) })), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach((function (e) { var t = e[0]; m[t] = new g(t, 1, !1, e[1], null, !1, !1) })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function (e) { m[e] = new g(e, 2, !1, e.toLowerCase(), null, !1, !1) })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function (e) { m[e] = new g(e, 2, !1, e, null, !1, !1) })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function (e) { m[e] = new g(e, 3, !1, e.toLowerCase(), null, !1, !1) })), ["checked", "multiple", "muted", "selected"].forEach((function (e) { m[e] = new g(e, 3, !0, e, null, !1, !1) })), ["capture", "download"].forEach((function (e) { m[e] = new g(e, 4, !1, e, null, !1, !1) })), ["cols", "rows", "size", "span"].forEach((function (e) { m[e] = new g(e, 6, !1, e, null, !1, !1) })), ["rowSpan", "start"].forEach((function (e) { m[e] = new g(e, 5, !1, e.toLowerCase(), null, !1, !1) })); var b = /[\-:]([a-z])/g; function v(e) { return e[1].toUpperCase() } function y(e, t, n, r) { var i = m.hasOwnProperty(t) ? m[t] : null; (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function (e, t, n, r) { if (null === t || "undefined" === typeof t || function (e, t, n, r) { if (null !== n && 0 === n.type) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e); default: return !1 } }(e, t, n, r)) return !0; if (r) return !1; if (null !== n) switch (n.type) { case 3: return !t; case 4: return !1 === t; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 }(t, n, i, r) && (n = null), r || null === i ? function (e) { return !!d.call(p, e) || !d.call(f, e) && (h.test(e) ? p[e] = !0 : (f[e] = !0, !1)) }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function (e) { var t = e.replace(b, v); m[t] = new g(t, 1, !1, e, null, !1, !1) })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function (e) { var t = e.replace(b, v); m[t] = new g(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) })), ["xml:base", "xml:lang", "xml:space"].forEach((function (e) { var t = e.replace(b, v); m[t] = new g(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) })), ["tabIndex", "crossOrigin"].forEach((function (e) { m[e] = new g(e, 1, !1, e.toLowerCase(), null, !1, !1) })), m.xlinkHref = new g("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function (e) { m[e] = new g(e, 1, !1, e.toLowerCase(), null, !0, !0) })); var x = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, w = Symbol.for("react.element"), _ = Symbol.for("react.portal"), k = Symbol.for("react.fragment"), S = Symbol.for("react.strict_mode"), C = Symbol.for("react.profiler"), E = Symbol.for("react.provider"), M = Symbol.for("react.context"), O = Symbol.for("react.forward_ref"), P = Symbol.for("react.suspense"), N = Symbol.for("react.suspense_list"), T = Symbol.for("react.memo"), j = Symbol.for("react.lazy"); Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode"); var D = Symbol.for("react.offscreen"); Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker"); var R = Symbol.iterator; function L(e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = R && e[R] || e["@@iterator"]) ? e : null } var A, z = Object.assign; function I(e) { if (void 0 === A) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); A = t && t[1] || "" } return "\n" + A + e } var F = !1; function B(e, t) { if (!e || F) return ""; F = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), "object" === typeof Reflect && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var r = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { r = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { r = c } e() } } catch (c) { if (c && r && "string" === typeof c.stack) { for (var i = c.stack.split("\n"), o = r.stack.split("\n"), a = i.length - 1, s = o.length - 1; 1 <= a && 0 <= s && i[a] !== o[s];)s--; for (; 1 <= a && 0 <= s; a--, s--)if (i[a] !== o[s]) { if (1 !== a || 1 !== s) do { if (a--, 0 > --s || i[a] !== o[s]) { var l = "\n" + i[a].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l } } while (1 <= a && 0 <= s); break } } } finally { F = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? I(e) : "" } function W(e) { switch (e.tag) { case 5: return I(e.type); case 16: return I("Lazy"); case 13: return I("Suspense"); case 19: return I("SuspenseList"); case 0: case 2: case 15: return e = B(e.type, !1); case 11: return e = B(e.type.render, !1); case 1: return e = B(e.type, !0); default: return "" } } function V(e) { if (null == e) return null; if ("function" === typeof e) return e.displayName || e.name || null; if ("string" === typeof e) return e; switch (e) { case k: return "Fragment"; case _: return "Portal"; case C: return "Profiler"; case S: return "StrictMode"; case P: return "Suspense"; case N: return "SuspenseList" }if ("object" === typeof e) switch (e.$$typeof) { case M: return (e.displayName || "Context") + ".Consumer"; case E: return (e._context.displayName || "Context") + ".Provider"; case O: var t = e.render; return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case T: return null !== (t = e.displayName || null) ? t : V(e.type) || "Memo"; case j: t = e._payload, e = e._init; try { return V(e(t)) } catch (n) { } }return null } function H(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return V(t); case 8: return t === S ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if ("function" === typeof t) return t.displayName || t.name || null; if ("string" === typeof t) return t }return null } function U(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": case "object": return e; default: return "" } } function $(e) { var t = e.type; return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t) } function Y(e) { e._valueTracker || (e._valueTracker = function (e) { var t = $(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) { var i = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (e) { r = "" + e, o.call(this, e) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (e) { r = "" + e }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } }(e)) } function q(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = $(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0) } function K(e) { if ("undefined" === typeof (e = e || ("undefined" !== typeof document ? document : void 0))) return null; try { return e.activeElement || e.body } catch (t) { return e.body } } function Q(e, t) { var n = t.checked; return z({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != n ? n : e._wrapperState.initialChecked }) } function X(e, t) { var n = null == t.defaultValue ? "" : t.defaultValue, r = null != t.checked ? t.checked : t.defaultChecked; n = U(null != t.value ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value } } function G(e, t) { null != (t = t.checked) && y(e, "checked", t, !1) } function J(e, t) { G(e, t); var n = U(t.value), r = t.type; if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if ("submit" === r || "reset" === r) return void e.removeAttribute("value"); t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, U(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked) } function Z(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n) } function ee(e, t, n) { "number" === t && K(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var te = Array.isArray; function ne(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + U(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) return e[i].selected = !0, void (r && (e[i].defaultSelected = !0)); null !== t || e[i].disabled || (t = e[i]) } null !== t && (t.selected = !0) } } function re(e, t) { if (null != t.dangerouslySetInnerHTML) throw Error(o(91)); return z({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function ie(e, t) { var n = t.value; if (null == n) { if (n = t.children, t = t.defaultValue, null != n) { if (null != t) throw Error(o(92)); if (te(n)) { if (1 < n.length) throw Error(o(93)); n = n[0] } t = n } null == t && (t = ""), n = t } e._wrapperState = { initialValue: U(n) } } function oe(e, t) { var n = U(t.value), r = U(t.defaultValue); null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r) } function ae(e) { var t = e.textContent; t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t) } function se(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function le(e, t) { return null == e || "http://www.w3.org/1999/xhtml" === e ? se(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e } var ce, ue, de = (ue = function (e, t) { if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t; else { for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }, "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (e, t, n, r) { MSApp.execUnsafeLocalFunction((function () { return ue(e, t) })) } : ue); function he(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && 3 === n.nodeType) return void (n.nodeValue = t) } e.textContent = t } var fe = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, pe = ["Webkit", "ms", "Moz", "O"]; function ge(e, t, n) { return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || fe.hasOwnProperty(e) && fe[e] ? ("" + t).trim() : t + "px" } function me(e, t) { for (var n in e = e.style, t) if (t.hasOwnProperty(n)) { var r = 0 === n.indexOf("--"), i = ge(n, t[n], r); "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } Object.keys(fe).forEach((function (e) { pe.forEach((function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), fe[t] = fe[e] })) })); var be = z({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function ve(e, t) { if (t) { if (be[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(o(137, e)); if (null != t.dangerouslySetInnerHTML) { if (null != t.children) throw Error(o(60)); if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(o(61)) } if (null != t.style && "object" !== typeof t.style) throw Error(o(62)) } } function ye(e, t) { if (-1 === e.indexOf("-")) return "string" === typeof t.is; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var xe = null; function we(e) { return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e } var _e = null, ke = null, Se = null; function Ce(e) { if (e = yi(e)) { if ("function" !== typeof _e) throw Error(o(280)); var t = e.stateNode; t && (t = wi(t), _e(e.stateNode, e.type, t)) } } function Ee(e) { ke ? Se ? Se.push(e) : Se = [e] : ke = e } function Me() { if (ke) { var e = ke, t = Se; if (Se = ke = null, Ce(e), t) for (e = 0; e < t.length; e++)Ce(t[e]) } } function Oe(e, t) { return e(t) } function Pe() { } var Ne = !1; function Te(e, t, n) { if (Ne) return e(t, n); Ne = !0; try { return Oe(e, t, n) } finally { Ne = !1, (null !== ke || null !== Se) && (Pe(), Me()) } } function je(e, t) { var n = e.stateNode; if (null === n) return null; var r = wi(n); if (null === r) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r; break e; default: e = !1 }if (e) return null; if (n && "function" !== typeof n) throw Error(o(231, t, typeof n)); return n } var De = !1; if (u) try { var Re = {}; Object.defineProperty(Re, "passive", { get: function () { De = !0 } }), window.addEventListener("test", Re, Re), window.removeEventListener("test", Re, Re) } catch (ue) { De = !1 } function Le(e, t, n, r, i, o, a, s, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (u) { this.onError(u) } } var Ae = !1, ze = null, Ie = !1, Fe = null, Be = { onError: function (e) { Ae = !0, ze = e } }; function We(e, t, n, r, i, o, a, s, l) { Ae = !1, ze = null, Le.apply(Be, arguments) } function Ve(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do { 0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return } while (e) } return 3 === t.tag ? n : null } function He(e) { if (13 === e.tag) { var t = e.memoizedState; if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated } return null } function Ue(e) { if (Ve(e) !== e) throw Error(o(188)) } function $e(e) { return null !== (e = function (e) { var t = e.alternate; if (!t) { if (null === (t = Ve(e))) throw Error(o(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (null === i) break; var a = i.alternate; if (null === a) { if (null !== (r = i.return)) { n = r; continue } break } if (i.child === a.child) { for (a = i.child; a;) { if (a === n) return Ue(i), e; if (a === r) return Ue(i), t; a = a.sibling } throw Error(o(188)) } if (n.return !== r.return) n = i, r = a; else { for (var s = !1, l = i.child; l;) { if (l === n) { s = !0, n = i, r = a; break } if (l === r) { s = !0, r = i, n = a; break } l = l.sibling } if (!s) { for (l = a.child; l;) { if (l === n) { s = !0, n = a, r = i; break } if (l === r) { s = !0, r = a, n = i; break } l = l.sibling } if (!s) throw Error(o(189)) } } if (n.alternate !== r) throw Error(o(190)) } if (3 !== n.tag) throw Error(o(188)); return n.stateNode.current === n ? e : t }(e)) ? Ye(e) : null } function Ye(e) { if (5 === e.tag || 6 === e.tag) return e; for (e = e.child; null !== e;) { var t = Ye(e); if (null !== t) return t; e = e.sibling } return null } var qe = i.unstable_scheduleCallback, Ke = i.unstable_cancelCallback, Qe = i.unstable_shouldYield, Xe = i.unstable_requestPaint, Ge = i.unstable_now, Je = i.unstable_getCurrentPriorityLevel, Ze = i.unstable_ImmediatePriority, et = i.unstable_UserBlockingPriority, tt = i.unstable_NormalPriority, nt = i.unstable_LowPriority, rt = i.unstable_IdlePriority, it = null, ot = null; var at = Math.clz32 ? Math.clz32 : function (e) { return e >>>= 0, 0 === e ? 32 : 31 - (st(e) / lt | 0) | 0 }, st = Math.log, lt = Math.LN2; var ct = 64, ut = 4194304; function dt(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return 4194240 & e; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return 130023424 & e; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function ht(e, t) { var n = e.pendingLanes; if (0 === n) return 0; var r = 0, i = e.suspendedLanes, o = e.pingedLanes, a = 268435455 & n; if (0 !== a) { var s = a & ~i; 0 !== s ? r = dt(s) : 0 !== (o &= a) && (r = dt(o)) } else 0 !== (a = n & ~i) ? r = dt(a) : 0 !== o && (r = dt(o)); if (0 === r) return 0; if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (o = t & -t) || 16 === i && 0 !== (4194240 & o))) return t; if (0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes)) for (e = e.entanglements, t &= r; 0 < t;)i = 1 << (n = 31 - at(t)), r |= e[n], t &= ~i; return r } function ft(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; default: return -1 } } function pt(e) { return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0 } function gt() { var e = ct; return 0 === (4194240 & (ct <<= 1)) && (ct = 64), e } function mt(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function bt(e, t, n) { e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - at(t)] = n } function vt(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - at(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var yt = 0; function xt(e) { return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1 } var wt, _t, kt, St, Ct, Et = !1, Mt = [], Ot = null, Pt = null, Nt = null, Tt = new Map, jt = new Map, Dt = [], Rt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Lt(e, t) { switch (e) { case "focusin": case "focusout": Ot = null; break; case "dragenter": case "dragleave": Pt = null; break; case "mouseover": case "mouseout": Nt = null; break; case "pointerover": case "pointerout": Tt.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": jt.delete(t.pointerId) } } function At(e, t, n, r, i, o) { return null === e || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, null !== t && (null !== (t = yi(t)) && _t(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e) } function zt(e) { var t = vi(e.target); if (null !== t) { var n = Ve(t); if (null !== n) if (13 === (t = n.tag)) { if (null !== (t = He(n))) return e.blockedOn = t, void Ct(e.priority, (function () { kt(n) })) } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void (e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null) } e.blockedOn = null } function It(e) { if (null !== e.blockedOn) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Qt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (null !== n) return null !== (t = yi(n)) && _t(t), e.blockedOn = n, !1; var r = new (n = e.nativeEvent).constructor(n.type, n); xe = r, n.target.dispatchEvent(r), xe = null, t.shift() } return !0 } function Ft(e, t, n) { It(e) && n.delete(t) } function Bt() { Et = !1, null !== Ot && It(Ot) && (Ot = null), null !== Pt && It(Pt) && (Pt = null), null !== Nt && It(Nt) && (Nt = null), Tt.forEach(Ft), jt.forEach(Ft) } function Wt(e, t) { e.blockedOn === t && (e.blockedOn = null, Et || (Et = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, Bt))) } function Vt(e) { function t(t) { return Wt(t, e) } if (0 < Mt.length) { Wt(Mt[0], e); for (var n = 1; n < Mt.length; n++) { var r = Mt[n]; r.blockedOn === e && (r.blockedOn = null) } } for (null !== Ot && Wt(Ot, e), null !== Pt && Wt(Pt, e), null !== Nt && Wt(Nt, e), Tt.forEach(t), jt.forEach(t), n = 0; n < Dt.length; n++)(r = Dt[n]).blockedOn === e && (r.blockedOn = null); for (; 0 < Dt.length && null === (n = Dt[0]).blockedOn;)zt(n), null === n.blockedOn && Dt.shift() } var Ht = x.ReactCurrentBatchConfig, Ut = !0; function $t(e, t, n, r) { var i = yt, o = Ht.transition; Ht.transition = null; try { yt = 1, qt(e, t, n, r) } finally { yt = i, Ht.transition = o } } function Yt(e, t, n, r) { var i = yt, o = Ht.transition; Ht.transition = null; try { yt = 4, qt(e, t, n, r) } finally { yt = i, Ht.transition = o } } function qt(e, t, n, r) { if (Ut) { var i = Qt(e, t, n, r); if (null === i) Ur(e, t, r, Kt, n), Lt(e, r); else if (function (e, t, n, r, i) { switch (t) { case "focusin": return Ot = At(Ot, e, t, n, r, i), !0; case "dragenter": return Pt = At(Pt, e, t, n, r, i), !0; case "mouseover": return Nt = At(Nt, e, t, n, r, i), !0; case "pointerover": var o = i.pointerId; return Tt.set(o, At(Tt.get(o) || null, e, t, n, r, i)), !0; case "gotpointercapture": return o = i.pointerId, jt.set(o, At(jt.get(o) || null, e, t, n, r, i)), !0 }return !1 }(i, e, t, n, r)) r.stopPropagation(); else if (Lt(e, r), 4 & t && -1 < Rt.indexOf(e)) { for (; null !== i;) { var o = yi(i); if (null !== o && wt(o), null === (o = Qt(e, t, n, r)) && Ur(e, t, r, Kt, n), o === i) break; i = o } null !== i && r.stopPropagation() } else Ur(e, t, r, null, n) } } var Kt = null; function Qt(e, t, n, r) { if (Kt = null, null !== (e = vi(e = we(r)))) if (null === (t = Ve(e))) e = null; else if (13 === (n = t.tag)) { if (null !== (e = He(t))) return e; e = null } else if (3 === n) { if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Kt = e, null } function Xt(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (Je()) { case Ze: return 1; case et: return 4; case tt: case nt: return 16; case rt: return 536870912; default: return 16 }default: return 16 } } var Gt = null, Jt = null, Zt = null; function en() { if (Zt) return Zt; var e, t, n = Jt, r = n.length, i = "value" in Gt ? Gt.value : Gt.textContent, o = i.length; for (e = 0; e < r && n[e] === i[e]; e++); var a = r - e; for (t = 1; t <= a && n[r - t] === i[o - t]; t++); return Zt = i.slice(e, 1 < t ? 1 - t : void 0) } function tn(e) { var t = e.keyCode; return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0 } function nn() { return !0 } function rn() { return !1 } function on(e) { function t(t, n, r, i, o) { for (var a in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = o, this.currentTarget = null, e) e.hasOwnProperty(a) && (t = e[a], this[a] = t ? t(i) : i[a]); return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this } return z(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var e = this.nativeEvent; e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn) }, stopPropagation: function () { var e = this.nativeEvent; e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn) }, persist: function () { }, isPersistent: nn }), t } var an, sn, ln, cn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, un = on(cn), dn = z({}, cn, { view: 0, detail: 0 }), hn = on(dn), fn = z({}, dn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Cn, button: 0, buttons: 0, relatedTarget: function (e) { return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== ln && (ln && "mousemove" === e.type ? (an = e.screenX - ln.screenX, sn = e.screenY - ln.screenY) : sn = an = 0, ln = e), an) }, movementY: function (e) { return "movementY" in e ? e.movementY : sn } }), pn = on(fn), gn = on(z({}, fn, { dataTransfer: 0 })), mn = on(z({}, dn, { relatedTarget: 0 })), bn = on(z({}, cn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })), vn = z({}, cn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), yn = on(vn), xn = on(z({}, cn, { data: 0 })), wn = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, _n = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, kn = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Sn(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : !!(e = kn[e]) && !!t[e] } function Cn() { return Sn } var En = z({}, dn, { key: function (e) { if (e.key) { var t = wn[e.key] || e.key; if ("Unidentified" !== t) return t } return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? _n[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Cn, charCode: function (e) { return "keypress" === e.type ? tn(e) : 0 }, keyCode: function (e) { return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 }, which: function (e) { return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0 } }), Mn = on(En), On = on(z({}, fn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 })), Pn = on(z({}, dn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Cn })), Nn = on(z({}, cn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })), Tn = z({}, fn, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), jn = on(Tn), Dn = [9, 13, 27, 32], Rn = u && "CompositionEvent" in window, Ln = null; u && "documentMode" in document && (Ln = document.documentMode); var An = u && "TextEvent" in window && !Ln, zn = u && (!Rn || Ln && 8 < Ln && 11 >= Ln), In = String.fromCharCode(32), Fn = !1; function Bn(e, t) { switch (e) { case "keyup": return -1 !== Dn.indexOf(t.keyCode); case "keydown": return 229 !== t.keyCode; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Wn(e) { return "object" === typeof (e = e.detail) && "data" in e ? e.data : null } var Vn = !1; var Hn = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Un(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return "input" === t ? !!Hn[e.type] : "textarea" === t } function $n(e, t, n, r) { Ee(r), 0 < (t = Yr(t, "onChange")).length && (n = new un("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Yn = null, qn = null; function Kn(e) { Ir(e, 0) } function Qn(e) { if (q(xi(e))) return e } function Xn(e, t) { if ("change" === e) return t } var Gn = !1; if (u) { var Jn; if (u) { var Zn = "oninput" in document; if (!Zn) { var er = document.createElement("div"); er.setAttribute("oninput", "return;"), Zn = "function" === typeof er.oninput } Jn = Zn } else Jn = !1; Gn = Jn && (!document.documentMode || 9 < document.documentMode) } function tr() { Yn && (Yn.detachEvent("onpropertychange", nr), qn = Yn = null) } function nr(e) { if ("value" === e.propertyName && Qn(qn)) { var t = []; $n(t, qn, e, we(e)), Te(Kn, t) } } function rr(e, t, n) { "focusin" === e ? (tr(), qn = n, (Yn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr() } function ir(e) { if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Qn(qn) } function or(e, t) { if ("click" === e) return Qn(t) } function ar(e, t) { if ("input" === e || "change" === e) return Qn(t) } var sr = "function" === typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t }; function lr(e, t) { if (sr(e, t)) return !0; if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!d.call(t, i) || !sr(e[i], t[i])) return !1 } return !0 } function cr(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function ur(e, t) { var n, r = cr(e); for (e = 0; r;) { if (3 === r.nodeType) { if (n = e + r.textContent.length, e <= t && n >= t) return { node: r, offset: t - e }; e = n } e: { for (; r;) { if (r.nextSibling) { r = r.nextSibling; break e } r = r.parentNode } r = void 0 } r = cr(r) } } function dr(e, t) { return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t)))) } function hr() { for (var e = window, t = K(); t instanceof e.HTMLIFrameElement;) { try { var n = "string" === typeof t.contentWindow.location.href } catch (r) { n = !1 } if (!n) break; t = K((e = t.contentWindow).document) } return t } function fr(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable) } function pr(e) { var t = hr(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) { if (null !== r && fr(n)) if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) { e = e.getSelection(); var i = n.textContent.length, o = Math.min(r.start, i); r = void 0 === r.end ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = ur(n, o); var a = ur(n, r); i && a && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset), e.addRange(t))) } for (t = [], e = n; e = e.parentNode;)1 === e.nodeType && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for ("function" === typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top } } var gr = u && "documentMode" in document && 11 >= document.documentMode, mr = null, br = null, vr = null, yr = !1; function xr(e, t, n) { var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument; yr || null == mr || mr !== K(r) || ("selectionStart" in (r = mr) && fr(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : r = { anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }, vr && lr(vr, r) || (vr = r, 0 < (r = Yr(br, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = mr))) } function wr(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var _r = { animationend: wr("Animation", "AnimationEnd"), animationiteration: wr("Animation", "AnimationIteration"), animationstart: wr("Animation", "AnimationStart"), transitionend: wr("Transition", "TransitionEnd") }, kr = {}, Sr = {}; function Cr(e) { if (kr[e]) return kr[e]; if (!_r[e]) return e; var t, n = _r[e]; for (t in n) if (n.hasOwnProperty(t) && t in Sr) return kr[e] = n[t]; return e } u && (Sr = document.createElement("div").style, "AnimationEvent" in window || (delete _r.animationend.animation, delete _r.animationiteration.animation, delete _r.animationstart.animation), "TransitionEvent" in window || delete _r.transitionend.transition); var Er = Cr("animationend"), Mr = Cr("animationiteration"), Or = Cr("animationstart"), Pr = Cr("transitionend"), Nr = new Map, Tr = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function jr(e, t) { Nr.set(e, t), l(t, [e]) } for (var Dr = 0; Dr < Tr.length; Dr++) { var Rr = Tr[Dr]; jr(Rr.toLowerCase(), "on" + (Rr[0].toUpperCase() + Rr.slice(1))) } jr(Er, "onAnimationEnd"), jr(Mr, "onAnimationIteration"), jr(Or, "onAnimationStart"), jr("dblclick", "onDoubleClick"), jr("focusin", "onFocus"), jr("focusout", "onBlur"), jr(Pr, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Lr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ar = new Set("cancel close invalid load scroll toggle".split(" ").concat(Lr)); function zr(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, function (e, t, n, r, i, a, s, l, c) { if (We.apply(this, arguments), Ae) { if (!Ae) throw Error(o(198)); var u = ze; Ae = !1, ze = null, Ie || (Ie = !0, Fe = u) } }(r, t, void 0, e), e.currentTarget = null } function Ir(e, t) { t = 0 !== (4 & t); for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var a = r.length - 1; 0 <= a; a--) { var s = r[a], l = s.instance, c = s.currentTarget; if (s = s.listener, l !== o && i.isPropagationStopped()) break e; zr(i, s, c), o = l } else for (a = 0; a < r.length; a++) { if (l = (s = r[a]).instance, c = s.currentTarget, s = s.listener, l !== o && i.isPropagationStopped()) break e; zr(i, s, c), o = l } } } if (Ie) throw e = Fe, Ie = !1, Fe = null, e } function Fr(e, t) { var n = t[gi]; void 0 === n && (n = t[gi] = new Set); var r = e + "__bubble"; n.has(r) || (Hr(t, e, 2, !1), n.add(r)) } function Br(e, t, n) { var r = 0; t && (r |= 4), Hr(n, e, r, t) } var Wr = "_reactListening" + Math.random().toString(36).slice(2); function Vr(e) { if (!e[Wr]) { e[Wr] = !0, a.forEach((function (t) { "selectionchange" !== t && (Ar.has(t) || Br(t, !1, e), Br(t, !0, e)) })); var t = 9 === e.nodeType ? e : e.ownerDocument; null === t || t[Wr] || (t[Wr] = !0, Br("selectionchange", !1, t)) } } function Hr(e, t, n, r) { switch (Xt(t)) { case 1: var i = $t; break; case 4: i = Yt; break; default: i = qt }n = i.bind(null, t, n, e), i = void 0, !De || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Ur(e, t, n, r, i) { var o = r; if (0 === (1 & t) && 0 === (2 & t) && null !== r) e: for (; ;) { if (null === r) return; var a = r.tag; if (3 === a || 4 === a) { var s = r.stateNode.containerInfo; if (s === i || 8 === s.nodeType && s.parentNode === i) break; if (4 === a) for (a = r.return; null !== a;) { var l = a.tag; if ((3 === l || 4 === l) && ((l = a.stateNode.containerInfo) === i || 8 === l.nodeType && l.parentNode === i)) return; a = a.return } for (; null !== s;) { if (null === (a = vi(s))) return; if (5 === (l = a.tag) || 6 === l) { r = o = a; continue e } s = s.parentNode } } r = r.return } Te((function () { var r = o, i = we(n), a = []; e: { var s = Nr.get(e); if (void 0 !== s) { var l = un, c = e; switch (e) { case "keypress": if (0 === tn(n)) break e; case "keydown": case "keyup": l = Mn; break; case "focusin": c = "focus", l = mn; break; case "focusout": c = "blur", l = mn; break; case "beforeblur": case "afterblur": l = mn; break; case "click": if (2 === n.button) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": l = pn; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": l = gn; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": l = Pn; break; case Er: case Mr: case Or: l = bn; break; case Pr: l = Nn; break; case "scroll": l = hn; break; case "wheel": l = jn; break; case "copy": case "cut": case "paste": l = yn; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": l = On }var u = 0 !== (4 & t), d = !u && "scroll" === e, h = u ? null !== s ? s + "Capture" : null : s; u = []; for (var f, p = r; null !== p;) { var g = (f = p).stateNode; if (5 === f.tag && null !== g && (f = g, null !== h && (null != (g = je(p, h)) && u.push($r(p, g, f)))), d) break; p = p.return } 0 < u.length && (s = new l(s, c, null, n, i), a.push({ event: s, listeners: u })) } } if (0 === (7 & t)) { if (l = "mouseout" === e || "pointerout" === e, (!(s = "mouseover" === e || "pointerover" === e) || n === xe || !(c = n.relatedTarget || n.fromElement) || !vi(c) && !c[pi]) && (l || s) && (s = i.window === i ? i : (s = i.ownerDocument) ? s.defaultView || s.parentWindow : window, l ? (l = r, null !== (c = (c = n.relatedTarget || n.toElement) ? vi(c) : null) && (c !== (d = Ve(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (l = null, c = r), l !== c)) { if (u = pn, g = "onMouseLeave", h = "onMouseEnter", p = "mouse", "pointerout" !== e && "pointerover" !== e || (u = On, g = "onPointerLeave", h = "onPointerEnter", p = "pointer"), d = null == l ? s : xi(l), f = null == c ? s : xi(c), (s = new u(g, p + "leave", l, n, i)).target = d, s.relatedTarget = f, g = null, vi(i) === r && ((u = new u(h, p + "enter", c, n, i)).target = f, u.relatedTarget = d, g = u), d = g, l && c) e: { for (h = c, p = 0, f = u = l; f; f = qr(f))p++; for (f = 0, g = h; g; g = qr(g))f++; for (; 0 < p - f;)u = qr(u), p--; for (; 0 < f - p;)h = qr(h), f--; for (; p--;) { if (u === h || null !== h && u === h.alternate) break e; u = qr(u), h = qr(h) } u = null } else u = null; null !== l && Kr(a, s, l, u, !1), null !== c && null !== d && Kr(a, d, c, u, !0) } if ("select" === (l = (s = r ? xi(r) : window).nodeName && s.nodeName.toLowerCase()) || "input" === l && "file" === s.type) var m = Xn; else if (Un(s)) if (Gn) m = ar; else { m = ir; var b = rr } else (l = s.nodeName) && "input" === l.toLowerCase() && ("checkbox" === s.type || "radio" === s.type) && (m = or); switch (m && (m = m(e, r)) ? $n(a, m, n, i) : (b && b(e, s, r), "focusout" === e && (b = s._wrapperState) && b.controlled && "number" === s.type && ee(s, "number", s.value)), b = r ? xi(r) : window, e) { case "focusin": (Un(b) || "true" === b.contentEditable) && (mr = b, br = r, vr = null); break; case "focusout": vr = br = mr = null; break; case "mousedown": yr = !0; break; case "contextmenu": case "mouseup": case "dragend": yr = !1, xr(a, n, i); break; case "selectionchange": if (gr) break; case "keydown": case "keyup": xr(a, n, i) }var v; if (Rn) e: { switch (e) { case "compositionstart": var y = "onCompositionStart"; break e; case "compositionend": y = "onCompositionEnd"; break e; case "compositionupdate": y = "onCompositionUpdate"; break e }y = void 0 } else Vn ? Bn(e, n) && (y = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (y = "onCompositionStart"); y && (zn && "ko" !== n.locale && (Vn || "onCompositionStart" !== y ? "onCompositionEnd" === y && Vn && (v = en()) : (Jt = "value" in (Gt = i) ? Gt.value : Gt.textContent, Vn = !0)), 0 < (b = Yr(r, y)).length && (y = new xn(y, e, null, n, i), a.push({ event: y, listeners: b }), v ? y.data = v : null !== (v = Wn(n)) && (y.data = v))), (v = An ? function (e, t) { switch (e) { case "compositionend": return Wn(t); case "keypress": return 32 !== t.which ? null : (Fn = !0, In); case "textInput": return (e = t.data) === In && Fn ? null : e; default: return null } }(e, n) : function (e, t) { if (Vn) return "compositionend" === e || !Rn && Bn(e, t) ? (e = en(), Zt = Jt = Gt = null, Vn = !1, e) : null; switch (e) { case "paste": default: return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return zn && "ko" !== t.locale ? null : t.data } }(e, n)) && (0 < (r = Yr(r, "onBeforeInput")).length && (i = new xn("onBeforeInput", "beforeinput", null, n, i), a.push({ event: i, listeners: r }), i.data = v)) } Ir(a, t) })) } function $r(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Yr(e, t) { for (var n = t + "Capture", r = []; null !== e;) { var i = e, o = i.stateNode; 5 === i.tag && null !== o && (i = o, null != (o = je(e, n)) && r.unshift($r(e, o, i)), null != (o = je(e, t)) && r.push($r(e, o, i))), e = e.return } return r } function qr(e) { if (null === e) return null; do { e = e.return } while (e && 5 !== e.tag); return e || null } function Kr(e, t, n, r, i) { for (var o = t._reactName, a = []; null !== n && n !== r;) { var s = n, l = s.alternate, c = s.stateNode; if (null !== l && l === r) break; 5 === s.tag && null !== c && (s = c, i ? null != (l = je(n, o)) && a.unshift($r(n, l, s)) : i || null != (l = je(n, o)) && a.push($r(n, l, s))), n = n.return } 0 !== a.length && e.push({ event: t, listeners: a }) } var Qr = /\r\n?/g, Xr = /\u0000|\uFFFD/g; function Gr(e) { return ("string" === typeof e ? e : "" + e).replace(Qr, "\n").replace(Xr, "") } function Jr(e, t, n) { if (t = Gr(t), Gr(e) !== t && n) throw Error(o(425)) } function Zr() { } var ei = null, ti = null; function ni(e, t) { return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html } var ri = "function" === typeof setTimeout ? setTimeout : void 0, ii = "function" === typeof clearTimeout ? clearTimeout : void 0, oi = "function" === typeof Promise ? Promise : void 0, ai = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof oi ? function (e) { return oi.resolve(null).then(e).catch(si) } : ri; function si(e) { setTimeout((function () { throw e })) } function li(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && 8 === i.nodeType) if ("/$" === (n = i.data)) { if (0 === r) return e.removeChild(i), void Vt(t); r-- } else "$" !== n && "$?" !== n && "$!" !== n || r++; n = i } while (n); Vt(t) } function ci(e) { for (; null != e; e = e.nextSibling) { var t = e.nodeType; if (1 === t || 3 === t) break; if (8 === t) { if ("$" === (t = e.data) || "$!" === t || "$?" === t) break; if ("/$" === t) return null } } return e } function ui(e) { e = e.previousSibling; for (var t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("$" === n || "$!" === n || "$?" === n) { if (0 === t) return e; t-- } else "/$" === n && t++ } e = e.previousSibling } return null } var di = Math.random().toString(36).slice(2), hi = "__reactFiber$" + di, fi = "__reactProps$" + di, pi = "__reactContainer$" + di, gi = "__reactEvents$" + di, mi = "__reactListeners$" + di, bi = "__reactHandles$" + di; function vi(e) { var t = e[hi]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[pi] || n[hi]) { if (n = t.alternate, null !== t.child || null !== n && null !== n.child) for (e = ui(e); null !== e;) { if (n = e[hi]) return n; e = ui(e) } return t } n = (e = n).parentNode } return null } function yi(e) { return !(e = e[hi] || e[pi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e } function xi(e) { if (5 === e.tag || 6 === e.tag) return e.stateNode; throw Error(o(33)) } function wi(e) { return e[fi] || null } var _i = [], ki = -1; function Si(e) { return { current: e } } function Ci(e) { 0 > ki || (e.current = _i[ki], _i[ki] = null, ki--) } function Ei(e, t) { ki++, _i[ki] = e.current, e.current = t } var Mi = {}, Oi = Si(Mi), Pi = Si(!1), Ni = Mi; function Ti(e, t) { var n = e.type.contextTypes; if (!n) return Mi; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i, o = {}; for (i in n) o[i] = t[i]; return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o } function ji(e) { return null !== (e = e.childContextTypes) && void 0 !== e } function Di() { Ci(Pi), Ci(Oi) } function Ri(e, t, n) { if (Oi.current !== Mi) throw Error(o(168)); Ei(Oi, t), Ei(Pi, n) } function Li(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, "function" !== typeof r.getChildContext) return n; for (var i in r = r.getChildContext()) if (!(i in t)) throw Error(o(108, H(e) || "Unknown", i)); return z({}, n, r) } function Ai(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Mi, Ni = Oi.current, Ei(Oi, e), Ei(Pi, Pi.current), !0 } function zi(e, t, n) { var r = e.stateNode; if (!r) throw Error(o(169)); n ? (e = Li(e, t, Ni), r.__reactInternalMemoizedMergedChildContext = e, Ci(Pi), Ci(Oi), Ei(Oi, e)) : Ci(Pi), Ei(Pi, n) } var Ii = null, Fi = !1, Bi = !1; function Wi(e) { null === Ii ? Ii = [e] : Ii.push(e) } function Vi() { if (!Bi && null !== Ii) { Bi = !0; var e = 0, t = yt; try { var n = Ii; for (yt = 1; e < n.length; e++) { var r = n[e]; do { r = r(!0) } while (null !== r) } Ii = null, Fi = !1 } catch (i) { throw null !== Ii && (Ii = Ii.slice(e + 1)), qe(Ze, Vi), i } finally { yt = t, Bi = !1 } } return null } var Hi = [], Ui = 0, $i = null, Yi = 0, qi = [], Ki = 0, Qi = null, Xi = 1, Gi = ""; function Ji(e, t) { Hi[Ui++] = Yi, Hi[Ui++] = $i, $i = e, Yi = t } function Zi(e, t, n) { qi[Ki++] = Xi, qi[Ki++] = Gi, qi[Ki++] = Qi, Qi = e; var r = Xi; e = Gi; var i = 32 - at(r) - 1; r &= ~(1 << i), n += 1; var o = 32 - at(t) + i; if (30 < o) { var a = i - i % 5; o = (r & (1 << a) - 1).toString(32), r >>= a, i -= a, Xi = 1 << 32 - at(t) + i | n << i | r, Gi = o + e } else Xi = 1 << o | n << i | r, Gi = e } function eo(e) { null !== e.return && (Ji(e, 1), Zi(e, 1, 0)) } function to(e) { for (; e === $i;)$i = Hi[--Ui], Hi[Ui] = null, Yi = Hi[--Ui], Hi[Ui] = null; for (; e === Qi;)Qi = qi[--Ki], qi[Ki] = null, Gi = qi[--Ki], qi[Ki] = null, Xi = qi[--Ki], qi[Ki] = null } var no = null, ro = null, io = !1, oo = null; function ao(e, t) { var n = jc(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function so(e, t) { switch (e.tag) { case 5: var n = e.type; return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, no = e, ro = ci(t.firstChild), !0); case 6: return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, no = e, ro = null, !0); case 13: return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Qi ? { id: Xi, overflow: Gi } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, (n = jc(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, no = e, ro = null, !0); default: return !1 } } function lo(e) { return 0 !== (1 & e.mode) && 0 === (128 & e.flags) } function co(e) { if (io) { var t = ro; if (t) { var n = t; if (!so(e, t)) { if (lo(e)) throw Error(o(418)); t = ci(n.nextSibling); var r = no; t && so(e, t) ? ao(r, n) : (e.flags = -4097 & e.flags | 2, io = !1, no = e) } } else { if (lo(e)) throw Error(o(418)); e.flags = -4097 & e.flags | 2, io = !1, no = e } } } function uo(e) { for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;)e = e.return; no = e } function ho(e) { if (e !== no) return !1; if (!io) return uo(e), io = !0, !1; var t; if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = ro)) { if (lo(e)) throw fo(), Error(o(418)); for (; t;)ao(e, t), t = ci(t.nextSibling) } if (uo(e), 13 === e.tag) { if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (8 === e.nodeType) { var n = e.data; if ("/$" === n) { if (0 === t) { ro = ci(e.nextSibling); break e } t-- } else "$" !== n && "$!" !== n && "$?" !== n || t++ } e = e.nextSibling } ro = null } } else ro = no ? ci(e.stateNode.nextSibling) : null; return !0 } function fo() { for (var e = ro; e;)e = ci(e.nextSibling) } function po() { ro = no = null, io = !1 } function go(e) { null === oo ? oo = [e] : oo.push(e) } var mo = x.ReactCurrentBatchConfig; function bo(e, t) { if (e && e.defaultProps) { for (var n in t = z({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]); return t } return t } var vo = Si(null), yo = null, xo = null, wo = null; function _o() { wo = xo = yo = null } function ko(e) { var t = vo.current; Ci(vo), e._currentValue = t } function So(e, t, n) { for (; null !== e;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function Co(e, t) { yo = e, wo = xo = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (xs = !0), e.firstContext = null) } function Eo(e) { var t = e._currentValue; if (wo !== e) if (e = { context: e, memoizedValue: t, next: null }, null === xo) { if (null === yo) throw Error(o(308)); xo = e, yo.dependencies = { lanes: 0, firstContext: e } } else xo = xo.next = e; return t } var Mo = null; function Oo(e) { null === Mo ? Mo = [e] : Mo.push(e) } function Po(e, t, n, r) { var i = t.interleaved; return null === i ? (n.next = n, Oo(t)) : (n.next = i.next, i.next = n), t.interleaved = n, No(e, r) } function No(e, t) { e.lanes |= t; var n = e.alternate; for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;)e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return; return 3 === n.tag ? n.stateNode : null } var To = !1; function jo(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Do(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Ro(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Lo(e, t, n) { var r = e.updateQueue; if (null === r) return null; if (r = r.shared, 0 !== (2 & Pl)) { var i = r.pending; return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, No(e, n) } return null === (i = r.interleaved) ? (t.next = t, Oo(r)) : (t.next = i.next, i.next = t), r.interleaved = t, No(e, n) } function Ao(e, t, n) { if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, vt(e, n) } } function zo(e, t) { var n = e.updateQueue, r = e.alternate; if (null !== r && n === (r = r.updateQueue)) { var i = null, o = null; if (null !== (n = n.firstBaseUpdate)) { do { var a = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; null === o ? i = o = a : o = o.next = a, n = n.next } while (null !== n); null === o ? i = o = t : o = o.next = t } else i = o = t; return n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, void (e.updateQueue = n) } null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Io(e, t, n, r) { var i = e.updateQueue; To = !1; var o = i.firstBaseUpdate, a = i.lastBaseUpdate, s = i.shared.pending; if (null !== s) { i.shared.pending = null; var l = s, c = l.next; l.next = null, null === a ? o = c : a.next = c, a = l; var u = e.alternate; null !== u && ((s = (u = u.updateQueue).lastBaseUpdate) !== a && (null === s ? u.firstBaseUpdate = c : s.next = c, u.lastBaseUpdate = l)) } if (null !== o) { var d = i.baseState; for (a = 0, u = c = l = null, s = o; ;) { var h = s.lane, f = s.eventTime; if ((r & h) === h) { null !== u && (u = u.next = { eventTime: f, lane: 0, tag: s.tag, payload: s.payload, callback: s.callback, next: null }); e: { var p = e, g = s; switch (h = t, f = n, g.tag) { case 1: if ("function" === typeof (p = g.payload)) { d = p.call(f, d, h); break e } d = p; break e; case 3: p.flags = -65537 & p.flags | 128; case 0: if (null === (h = "function" === typeof (p = g.payload) ? p.call(f, d, h) : p) || void 0 === h) break e; d = z({}, d, h); break e; case 2: To = !0 } } null !== s.callback && 0 !== s.lane && (e.flags |= 64, null === (h = i.effects) ? i.effects = [s] : h.push(s)) } else f = { eventTime: f, lane: h, tag: s.tag, payload: s.payload, callback: s.callback, next: null }, null === u ? (c = u = f, l = d) : u = u.next = f, a |= h; if (null === (s = s.next)) { if (null === (s = i.shared.pending)) break; s = (h = s).next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null } } if (null === u && (l = d), i.baseState = l, i.firstBaseUpdate = c, i.lastBaseUpdate = u, null !== (t = i.shared.interleaved)) { i = t; do { a |= i.lane, i = i.next } while (i !== t) } else null === o && (i.shared.lanes = 0); zl |= a, e.lanes = a, e.memoizedState = d } } function Fo(e, t, n) { if (e = t.effects, t.effects = null, null !== e) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (null !== i) { if (r.callback = null, r = n, "function" !== typeof i) throw Error(o(191, i)); i.call(r) } } } var Bo = (new r.Component).refs; function Wo(e, t, n, r) { n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : z({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n) } var Vo = { isMounted: function (e) { return !!(e = e._reactInternals) && Ve(e) === e }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = tc(), i = nc(e), o = Ro(r, i); o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = Lo(e, o, i)) && (rc(t, e, i, r), Ao(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = tc(), i = nc(e), o = Ro(r, i); o.tag = 1, o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = Lo(e, o, i)) && (rc(t, e, i, r), Ao(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = tc(), r = nc(e), i = Ro(n, r); i.tag = 2, void 0 !== t && null !== t && (i.callback = t), null !== (t = Lo(e, i, r)) && (rc(t, e, r, n), Ao(t, e, r)) } }; function Ho(e, t, n, r, i, o, a) { return "function" === typeof (e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, a) : !t.prototype || !t.prototype.isPureReactComponent || (!lr(n, r) || !lr(i, o)) } function Uo(e, t, n) { var r = !1, i = Mi, o = t.contextType; return "object" === typeof o && null !== o ? o = Eo(o) : (i = ji(t) ? Ni : Oi.current, o = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Ti(e, i) : Mi), t = new t(n, o), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = Vo, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t } function $o(e, t, n, r) { e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Vo.enqueueReplaceState(t, t.state, null) } function Yo(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = Bo, jo(e); var o = t.contextType; "object" === typeof o && null !== o ? i.context = Eo(o) : (o = ji(t) ? Ni : Oi.current, i.context = Ti(e, o)), i.state = e.memoizedState, "function" === typeof (o = t.getDerivedStateFromProps) && (Wo(e, t, o, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && Vo.enqueueReplaceState(i, i.state, null), Io(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4194308) } function qo(e, t, n) { if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) { if (n._owner) { if (n = n._owner) { if (1 !== n.tag) throw Error(o(309)); var r = n.stateNode } if (!r) throw Error(o(147, e)); var i = r, a = "" + e; return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === a ? t.ref : (t = function (e) { var t = i.refs; t === Bo && (t = i.refs = {}), null === e ? delete t[a] : t[a] = e }, t._stringRef = a, t) } if ("string" !== typeof e) throw Error(o(284)); if (!n._owner) throw Error(o(290, e)) } return e } function Ko(e, t) { throw e = Object.prototype.toString.call(t), Error(o(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Qo(e) { return (0, e._init)(e._payload) } function Xo(e) { function t(t, n) { if (e) { var r = t.deletions; null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n) } } function n(n, r) { if (!e) return null; for (; null !== r;)t(n, r), r = r.sibling; return null } function r(e, t) { for (e = new Map; null !== t;)null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling; return e } function i(e, t) { return (e = Rc(e, t)).index = 0, e.sibling = null, e } function a(t, n, r) { return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n) } function s(t) { return e && null === t.alternate && (t.flags |= 2), t } function l(e, t, n, r) { return null === t || 6 !== t.tag ? ((t = Ic(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t) } function c(e, t, n, r) { var o = n.type; return o === k ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === o || "object" === typeof o && null !== o && o.$$typeof === j && Qo(o) === t.type) ? ((r = i(t, n.props)).ref = qo(e, t, n), r.return = e, r) : ((r = Lc(n.type, n.key, n.props, null, e.mode, r)).ref = qo(e, t, n), r.return = e, r) } function u(e, t, n, r) { return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Fc(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t) } function d(e, t, n, r, o) { return null === t || 7 !== t.tag ? ((t = Ac(n, e.mode, r, o)).return = e, t) : ((t = i(t, n)).return = e, t) } function h(e, t, n) { if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = Ic("" + t, e.mode, n)).return = e, t; if ("object" === typeof t && null !== t) { switch (t.$$typeof) { case w: return (n = Lc(t.type, t.key, t.props, null, e.mode, n)).ref = qo(e, null, t), n.return = e, n; case _: return (t = Fc(t, e.mode, n)).return = e, t; case j: return h(e, (0, t._init)(t._payload), n) }if (te(t) || L(t)) return (t = Ac(t, e.mode, n, null)).return = e, t; Ko(e, t) } return null } function f(e, t, n, r) { var i = null !== t ? t.key : null; if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== i ? null : l(e, t, "" + n, r); if ("object" === typeof n && null !== n) { switch (n.$$typeof) { case w: return n.key === i ? c(e, t, n, r) : null; case _: return n.key === i ? u(e, t, n, r) : null; case j: return f(e, t, (i = n._init)(n._payload), r) }if (te(n) || L(n)) return null !== i ? null : d(e, t, n, r, null); Ko(e, n) } return null } function p(e, t, n, r, i) { if ("string" === typeof r && "" !== r || "number" === typeof r) return l(t, e = e.get(n) || null, "" + r, i); if ("object" === typeof r && null !== r) { switch (r.$$typeof) { case w: return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case _: return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i); case j: return p(e, t, n, (0, r._init)(r._payload), i) }if (te(r) || L(r)) return d(t, e = e.get(n) || null, r, i, null); Ko(t, r) } return null } function g(i, o, s, l) { for (var c = null, u = null, d = o, g = o = 0, m = null; null !== d && g < s.length; g++) { d.index > g ? (m = d, d = null) : m = d.sibling; var b = f(i, d, s[g], l); if (null === b) { null === d && (d = m); break } e && d && null === b.alternate && t(i, d), o = a(b, o, g), null === u ? c = b : u.sibling = b, u = b, d = m } if (g === s.length) return n(i, d), io && Ji(i, g), c; if (null === d) { for (; g < s.length; g++)null !== (d = h(i, s[g], l)) && (o = a(d, o, g), null === u ? c = d : u.sibling = d, u = d); return io && Ji(i, g), c } for (d = r(i, d); g < s.length; g++)null !== (m = p(d, i, g, s[g], l)) && (e && null !== m.alternate && d.delete(null === m.key ? g : m.key), o = a(m, o, g), null === u ? c = m : u.sibling = m, u = m); return e && d.forEach((function (e) { return t(i, e) })), io && Ji(i, g), c } function m(i, s, l, c) { var u = L(l); if ("function" !== typeof u) throw Error(o(150)); if (null == (l = u.call(l))) throw Error(o(151)); for (var d = u = null, g = s, m = s = 0, b = null, v = l.next(); null !== g && !v.done; m++, v = l.next()) { g.index > m ? (b = g, g = null) : b = g.sibling; var y = f(i, g, v.value, c); if (null === y) { null === g && (g = b); break } e && g && null === y.alternate && t(i, g), s = a(y, s, m), null === d ? u = y : d.sibling = y, d = y, g = b } if (v.done) return n(i, g), io && Ji(i, m), u; if (null === g) { for (; !v.done; m++, v = l.next())null !== (v = h(i, v.value, c)) && (s = a(v, s, m), null === d ? u = v : d.sibling = v, d = v); return io && Ji(i, m), u } for (g = r(i, g); !v.done; m++, v = l.next())null !== (v = p(g, i, m, v.value, c)) && (e && null !== v.alternate && g.delete(null === v.key ? m : v.key), s = a(v, s, m), null === d ? u = v : d.sibling = v, d = v); return e && g.forEach((function (e) { return t(i, e) })), io && Ji(i, m), u } return function e(r, o, a, l) { if ("object" === typeof a && null !== a && a.type === k && null === a.key && (a = a.props.children), "object" === typeof a && null !== a) { switch (a.$$typeof) { case w: e: { for (var c = a.key, u = o; null !== u;) { if (u.key === c) { if ((c = a.type) === k) { if (7 === u.tag) { n(r, u.sibling), (o = i(u, a.props.children)).return = r, r = o; break e } } else if (u.elementType === c || "object" === typeof c && null !== c && c.$$typeof === j && Qo(c) === u.type) { n(r, u.sibling), (o = i(u, a.props)).ref = qo(r, u, a), o.return = r, r = o; break e } n(r, u); break } t(r, u), u = u.sibling } a.type === k ? ((o = Ac(a.props.children, r.mode, l, a.key)).return = r, r = o) : ((l = Lc(a.type, a.key, a.props, null, r.mode, l)).ref = qo(r, o, a), l.return = r, r = l) } return s(r); case _: e: { for (u = a.key; null !== o;) { if (o.key === u) { if (4 === o.tag && o.stateNode.containerInfo === a.containerInfo && o.stateNode.implementation === a.implementation) { n(r, o.sibling), (o = i(o, a.children || [])).return = r, r = o; break e } n(r, o); break } t(r, o), o = o.sibling } (o = Fc(a, r.mode, l)).return = r, r = o } return s(r); case j: return e(r, o, (u = a._init)(a._payload), l) }if (te(a)) return g(r, o, a, l); if (L(a)) return m(r, o, a, l); Ko(r, a) } return "string" === typeof a && "" !== a || "number" === typeof a ? (a = "" + a, null !== o && 6 === o.tag ? (n(r, o.sibling), (o = i(o, a)).return = r, r = o) : (n(r, o), (o = Ic(a, r.mode, l)).return = r, r = o), s(r)) : n(r, o) } } var Go = Xo(!0), Jo = Xo(!1), Zo = {}, ea = Si(Zo), ta = Si(Zo), na = Si(Zo); function ra(e) { if (e === Zo) throw Error(o(174)); return e } function ia(e, t) { switch (Ei(na, t), Ei(ta, e), Ei(ea, Zo), e = t.nodeType) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : le(null, ""); break; default: t = le(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName) }Ci(ea), Ei(ea, t) } function oa() { Ci(ea), Ci(ta), Ci(na) } function aa(e) { ra(na.current); var t = ra(ea.current), n = le(t, e.type); t !== n && (Ei(ta, e), Ei(ea, n)) } function sa(e) { ta.current === e && (Ci(ea), Ci(ta)) } var la = Si(0); function ca(e) { for (var t = e; null !== t;) { if (13 === t.tag) { var n = t.memoizedState; if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) { if (0 !== (128 & t.flags)) return t } else if (null !== t.child) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var ua = []; function da() { for (var e = 0; e < ua.length; e++)ua[e]._workInProgressVersionPrimary = null; ua.length = 0 } var ha = x.ReactCurrentDispatcher, fa = x.ReactCurrentBatchConfig, pa = 0, ga = null, ma = null, ba = null, va = !1, ya = !1, xa = 0, wa = 0; function _a() { throw Error(o(321)) } function ka(e, t) { if (null === t) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!sr(e[n], t[n])) return !1; return !0 } function Sa(e, t, n, r, i, a) { if (pa = a, ga = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, ha.current = null === e || null === e.memoizedState ? ss : ls, e = n(r, i), ya) { a = 0; do { if (ya = !1, xa = 0, 25 <= a) throw Error(o(301)); a += 1, ba = ma = null, t.updateQueue = null, ha.current = cs, e = n(r, i) } while (ya) } if (ha.current = as, t = null !== ma && null !== ma.next, pa = 0, ba = ma = ga = null, va = !1, t) throw Error(o(300)); return e } function Ca() { var e = 0 !== xa; return xa = 0, e } function Ea() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return null === ba ? ga.memoizedState = ba = e : ba = ba.next = e, ba } function Ma() { if (null === ma) { var e = ga.alternate; e = null !== e ? e.memoizedState : null } else e = ma.next; var t = null === ba ? ga.memoizedState : ba.next; if (null !== t) ba = t, ma = e; else { if (null === e) throw Error(o(310)); e = { memoizedState: (ma = e).memoizedState, baseState: ma.baseState, baseQueue: ma.baseQueue, queue: ma.queue, next: null }, null === ba ? ga.memoizedState = ba = e : ba = ba.next = e } return ba } function Oa(e, t) { return "function" === typeof t ? t(e) : t } function Pa(e) { var t = Ma(), n = t.queue; if (null === n) throw Error(o(311)); n.lastRenderedReducer = e; var r = ma, i = r.baseQueue, a = n.pending; if (null !== a) { if (null !== i) { var s = i.next; i.next = a.next, a.next = s } r.baseQueue = i = a, n.pending = null } if (null !== i) { a = i.next, r = r.baseState; var l = s = null, c = null, u = a; do { var d = u.lane; if ((pa & d) === d) null !== c && (c = c.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var h = { lane: d, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; null === c ? (l = c = h, s = r) : c = c.next = h, ga.lanes |= d, zl |= d } u = u.next } while (null !== u && u !== a); null === c ? s = r : c.next = l, sr(r, t.memoizedState) || (xs = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = c, n.lastRenderedState = r } if (null !== (e = n.interleaved)) { i = e; do { a = i.lane, ga.lanes |= a, zl |= a, i = i.next } while (i !== e) } else null === i && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Na(e) { var t = Ma(), n = t.queue; if (null === n) throw Error(o(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, a = t.memoizedState; if (null !== i) { n.pending = null; var s = i = i.next; do { a = e(a, s.action), s = s.next } while (s !== i); sr(a, t.memoizedState) || (xs = !0), t.memoizedState = a, null === t.baseQueue && (t.baseState = a), n.lastRenderedState = a } return [a, r] } function Ta() { } function ja(e, t) { var n = ga, r = Ma(), i = t(), a = !sr(r.memoizedState, i); if (a && (r.memoizedState = i, xs = !0), r = r.queue, Ua(La.bind(null, n, r, e), [e]), r.getSnapshot !== t || a || null !== ba && 1 & ba.memoizedState.tag) { if (n.flags |= 2048, Fa(9, Ra.bind(null, n, r, i, t), void 0, null), null === Nl) throw Error(o(349)); 0 !== (30 & pa) || Da(n, t, i) } return i } function Da(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, null === (t = ga.updateQueue) ? (t = { lastEffect: null, stores: null }, ga.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e) } function Ra(e, t, n, r) { t.value = n, t.getSnapshot = r, Aa(t) && za(e) } function La(e, t, n) { return n((function () { Aa(t) && za(e) })) } function Aa(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !sr(e, n) } catch (r) { return !0 } } function za(e) { var t = No(e, 1); null !== t && rc(t, e, 1, -1) } function Ia(e) { var t = Ea(); return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Oa, lastRenderedState: e }, t.queue = e, e = e.dispatch = ns.bind(null, ga, e), [t.memoizedState, e] } function Fa(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, null === (t = ga.updateQueue) ? (t = { lastEffect: null, stores: null }, ga.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e } function Ba() { return Ma().memoizedState } function Wa(e, t, n, r) { var i = Ea(); ga.flags |= e, i.memoizedState = Fa(1 | t, n, void 0, void 0 === r ? null : r) } function Va(e, t, n, r) { var i = Ma(); r = void 0 === r ? null : r; var o = void 0; if (null !== ma) { var a = ma.memoizedState; if (o = a.destroy, null !== r && ka(r, a.deps)) return void (i.memoizedState = Fa(t, n, o, r)) } ga.flags |= e, i.memoizedState = Fa(1 | t, n, o, r) } function Ha(e, t) { return Wa(8390656, 8, e, t) } function Ua(e, t) { return Va(2048, 8, e, t) } function $a(e, t) { return Va(4, 2, e, t) } function Ya(e, t) { return Va(4, 4, e, t) } function qa(e, t) { return "function" === typeof t ? (e = e(), t(e), function () { t(null) }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function () { t.current = null }) : void 0 } function Ka(e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, Va(4, 4, qa.bind(null, t, e), n) } function Qa() { } function Xa(e, t) { var n = Ma(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && ka(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Ga(e, t) { var n = Ma(); t = void 0 === t ? null : t; var r = n.memoizedState; return null !== r && null !== t && ka(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Ja(e, t, n) { return 0 === (21 & pa) ? (e.baseState && (e.baseState = !1, xs = !0), e.memoizedState = n) : (sr(n, t) || (n = gt(), ga.lanes |= n, zl |= n, e.baseState = !0), t) } function Za(e, t) { var n = yt; yt = 0 !== n && 4 > n ? n : 4, e(!0); var r = fa.transition; fa.transition = {}; try { e(!1), t() } finally { yt = n, fa.transition = r } } function es() { return Ma().memoizedState } function ts(e, t, n) { var r = nc(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, rs(e)) is(t, n); else if (null !== (n = Po(e, t, n, r))) { rc(n, e, r, tc()), os(n, t, r) } } function ns(e, t, n) { var r = nc(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (rs(e)) is(t, i); else { var o = e.alternate; if (0 === e.lanes && (null === o || 0 === o.lanes) && null !== (o = t.lastRenderedReducer)) try { var a = t.lastRenderedState, s = o(a, n); if (i.hasEagerState = !0, i.eagerState = s, sr(s, a)) { var l = t.interleaved; return null === l ? (i.next = i, Oo(t)) : (i.next = l.next, l.next = i), void (t.interleaved = i) } } catch (c) { } null !== (n = Po(e, t, i, r)) && (rc(n, e, r, i = tc()), os(n, t, r)) } } function rs(e) { var t = e.alternate; return e === ga || null !== t && t === ga } function is(e, t) { ya = va = !0; var n = e.pending; null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function os(e, t, n) { if (0 !== (4194240 & n)) { var r = t.lanes; n |= r &= e.pendingLanes, t.lanes = n, vt(e, n) } } var as = { readContext: Eo, useCallback: _a, useContext: _a, useEffect: _a, useImperativeHandle: _a, useInsertionEffect: _a, useLayoutEffect: _a, useMemo: _a, useReducer: _a, useRef: _a, useState: _a, useDebugValue: _a, useDeferredValue: _a, useTransition: _a, useMutableSource: _a, useSyncExternalStore: _a, useId: _a, unstable_isNewReconciler: !1 }, ss = { readContext: Eo, useCallback: function (e, t) { return Ea().memoizedState = [e, void 0 === t ? null : t], e }, useContext: Eo, useEffect: Ha, useImperativeHandle: function (e, t, n) { return n = null !== n && void 0 !== n ? n.concat([e]) : null, Wa(4194308, 4, qa.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Wa(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Wa(4, 2, e, t) }, useMemo: function (e, t) { var n = Ea(); return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = Ea(); return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = ts.bind(null, ga, e), [r.memoizedState, e] }, useRef: function (e) { return e = { current: e }, Ea().memoizedState = e }, useState: Ia, useDebugValue: Qa, useDeferredValue: function (e) { return Ea().memoizedState = e }, useTransition: function () { var e = Ia(!1), t = e[0]; return e = Za.bind(null, e[1]), Ea().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = ga, i = Ea(); if (io) { if (void 0 === n) throw Error(o(407)); n = n() } else { if (n = t(), null === Nl) throw Error(o(349)); 0 !== (30 & pa) || Da(r, t, n) } i.memoizedState = n; var a = { value: n, getSnapshot: t }; return i.queue = a, Ha(La.bind(null, r, a, e), [e]), r.flags |= 2048, Fa(9, Ra.bind(null, r, a, n, t), void 0, null), n }, useId: function () { var e = Ea(), t = Nl.identifierPrefix; if (io) { var n = Gi; t = ":" + t + "R" + (n = (Xi & ~(1 << 32 - at(Xi) - 1)).toString(32) + n), 0 < (n = xa++) && (t += "H" + n.toString(32)), t += ":" } else t = ":" + t + "r" + (n = wa++).toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, ls = { readContext: Eo, useCallback: Xa, useContext: Eo, useEffect: Ua, useImperativeHandle: Ka, useInsertionEffect: $a, useLayoutEffect: Ya, useMemo: Ga, useReducer: Pa, useRef: Ba, useState: function () { return Pa(Oa) }, useDebugValue: Qa, useDeferredValue: function (e) { return Ja(Ma(), ma.memoizedState, e) }, useTransition: function () { return [Pa(Oa)[0], Ma().memoizedState] }, useMutableSource: Ta, useSyncExternalStore: ja, useId: es, unstable_isNewReconciler: !1 }, cs = { readContext: Eo, useCallback: Xa, useContext: Eo, useEffect: Ua, useImperativeHandle: Ka, useInsertionEffect: $a, useLayoutEffect: Ya, useMemo: Ga, useReducer: Na, useRef: Ba, useState: function () { return Na(Oa) }, useDebugValue: Qa, useDeferredValue: function (e) { var t = Ma(); return null === ma ? t.memoizedState = e : Ja(t, ma.memoizedState, e) }, useTransition: function () { return [Na(Oa)[0], Ma().memoizedState] }, useMutableSource: Ta, useSyncExternalStore: ja, useId: es, unstable_isNewReconciler: !1 }; function us(e, t) { try { var n = "", r = t; do { n += W(r), r = r.return } while (r); var i = n } catch (o) { i = "\nError generating stack: " + o.message + "\n" + o.stack } return { value: e, source: t, stack: i, digest: null } } function ds(e, t, n) { return { value: e, source: null, stack: null != n ? n : null, digest: null != t ? t : null } } function hs(e, t) { try { console.error(t.value) } catch (n) { setTimeout((function () { throw n })) } } var fs = "function" === typeof WeakMap ? WeakMap : Map; function ps(e, t, n) { (n = Ro(-1, n)).tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { $l || ($l = !0, Yl = r), hs(0, t) }, n } function gs(e, t, n) { (n = Ro(-1, n)).tag = 3; var r = e.type.getDerivedStateFromError; if ("function" === typeof r) { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { hs(0, t) } } var o = e.stateNode; return null !== o && "function" === typeof o.componentDidCatch && (n.callback = function () { hs(0, t), "function" !== typeof r && (null === ql ? ql = new Set([this]) : ql.add(this)); var e = t.stack; this.componentDidCatch(t.value, { componentStack: null !== e ? e : "" }) }), n } function ms(e, t, n) { var r = e.pingCache; if (null === r) { r = e.pingCache = new fs; var i = new Set; r.set(t, i) } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = Ec.bind(null, e, t, n), t.then(e, e)) } function bs(e) { do { var t; if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e; e = e.return } while (null !== e); return null } function vs(e, t, n, r, i) { return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Ro(-1, 1)).tag = 2, Lo(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e) } var ys = x.ReactCurrentOwner, xs = !1; function ws(e, t, n, r) { t.child = null === e ? Jo(t, null, n, r) : Go(t, e.child, n, r) } function _s(e, t, n, r, i) { n = n.render; var o = t.ref; return Co(t, i), r = Sa(e, t, n, r, o, i), n = Ca(), null === e || xs ? (io && n && eo(t), t.flags |= 1, ws(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, $s(e, t, i)) } function ks(e, t, n, r, i) { if (null === e) { var o = n.type; return "function" !== typeof o || Dc(o) || void 0 !== o.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Lc(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = o, Ss(e, t, o, r, i)) } if (o = e.child, 0 === (e.lanes & i)) { var a = o.memoizedProps; if ((n = null !== (n = n.compare) ? n : lr)(a, r) && e.ref === t.ref) return $s(e, t, i) } return t.flags |= 1, (e = Rc(o, r)).ref = t.ref, e.return = t, t.child = e } function Ss(e, t, n, r, i) { if (null !== e) { var o = e.memoizedProps; if (lr(o, r) && e.ref === t.ref) { if (xs = !1, t.pendingProps = r = o, 0 === (e.lanes & i)) return t.lanes = e.lanes, $s(e, t, i); 0 !== (131072 & e.flags) && (xs = !0) } } return Ms(e, t, n, r, i) } function Cs(e, t, n) { var r = t.pendingProps, i = r.children, o = null !== e ? e.memoizedState : null; if ("hidden" === r.mode) if (0 === (1 & t.mode)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ei(Rl, Dl), Dl |= n; else { if (0 === (1073741824 & n)) return e = null !== o ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Ei(Rl, Dl), Dl |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = null !== o ? o.baseLanes : n, Ei(Rl, Dl), Dl |= r } else null !== o ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Ei(Rl, Dl), Dl |= r; return ws(e, t, i, n), t.child } function Es(e, t) { var n = t.ref; (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Ms(e, t, n, r, i) { var o = ji(n) ? Ni : Oi.current; return o = Ti(t, o), Co(t, i), n = Sa(e, t, n, r, o, i), r = Ca(), null === e || xs ? (io && r && eo(t), t.flags |= 1, ws(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, $s(e, t, i)) } function Os(e, t, n, r, i) { if (ji(n)) { var o = !0; Ai(t) } else o = !1; if (Co(t, i), null === t.stateNode) Us(e, t), Uo(t, n, r), Yo(t, n, r, i), r = !0; else if (null === e) { var a = t.stateNode, s = t.memoizedProps; a.props = s; var l = a.context, c = n.contextType; "object" === typeof c && null !== c ? c = Eo(c) : c = Ti(t, c = ji(n) ? Ni : Oi.current); var u = n.getDerivedStateFromProps, d = "function" === typeof u || "function" === typeof a.getSnapshotBeforeUpdate; d || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== r || l !== c) && $o(t, a, r, c), To = !1; var h = t.memoizedState; a.state = h, Io(t, r, a, i), l = t.memoizedState, s !== r || h !== l || Pi.current || To ? ("function" === typeof u && (Wo(t, n, u, r), l = t.memoizedState), (s = To || Ho(t, n, s, r, h, l, c)) ? (d || "function" !== typeof a.UNSAFE_componentWillMount && "function" !== typeof a.componentWillMount || ("function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()), "function" === typeof a.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), a.props = r, a.state = l, a.context = c, r = s) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), r = !1) } else { a = t.stateNode, Do(e, t), s = t.memoizedProps, c = t.type === t.elementType ? s : bo(t.type, s), a.props = c, d = t.pendingProps, h = a.context, "object" === typeof (l = n.contextType) && null !== l ? l = Eo(l) : l = Ti(t, l = ji(n) ? Ni : Oi.current); var f = n.getDerivedStateFromProps; (u = "function" === typeof f || "function" === typeof a.getSnapshotBeforeUpdate) || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== d || h !== l) && $o(t, a, r, l), To = !1, h = t.memoizedState, a.state = h, Io(t, r, a, i); var p = t.memoizedState; s !== d || h !== p || Pi.current || To ? ("function" === typeof f && (Wo(t, n, f, r), p = t.memoizedState), (c = To || Ho(t, n, c, r, h, p, l) || !1) ? (u || "function" !== typeof a.UNSAFE_componentWillUpdate && "function" !== typeof a.componentWillUpdate || ("function" === typeof a.componentWillUpdate && a.componentWillUpdate(r, p, l), "function" === typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(r, p, l)), "function" === typeof a.componentDidUpdate && (t.flags |= 4), "function" === typeof a.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = p), a.props = r, a.state = p, a.context = l, r = c) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1) } return Ps(e, t, n, r, o, i) } function Ps(e, t, n, r, i, o) { Es(e, t); var a = 0 !== (128 & t.flags); if (!r && !a) return i && zi(t, n, !1), $s(e, t, o); r = t.stateNode, ys.current = t; var s = a && "function" !== typeof n.getDerivedStateFromError ? null : r.render(); return t.flags |= 1, null !== e && a ? (t.child = Go(t, e.child, null, o), t.child = Go(t, null, s, o)) : ws(e, t, s, o), t.memoizedState = r.state, i && zi(t, n, !0), t.child } function Ns(e) { var t = e.stateNode; t.pendingContext ? Ri(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Ri(0, t.context, !1), ia(e, t.containerInfo) } function Ts(e, t, n, r, i) { return po(), go(i), t.flags |= 256, ws(e, t, n, r), t.child } var js, Ds, Rs, Ls, As = { dehydrated: null, treeContext: null, retryLane: 0 }; function zs(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Is(e, t, n) { var r, i = t.pendingProps, a = la.current, s = !1, l = 0 !== (128 & t.flags); if ((r = l) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & a)), r ? (s = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (a |= 1), Ei(la, 1 & a), null === e) return co(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (l = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, l = { mode: "hidden", children: l }, 0 === (1 & i) && null !== s ? (s.childLanes = 0, s.pendingProps = l) : s = zc(l, i, 0, null), e = Ac(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = zs(n), t.memoizedState = As, e) : Fs(t, l)); if (null !== (a = e.memoizedState) && null !== (r = a.dehydrated)) return function (e, t, n, r, i, a, s) { if (n) return 256 & t.flags ? (t.flags &= -257, Bs(e, t, s, r = ds(Error(o(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (a = r.fallback, i = t.mode, r = zc({ mode: "visible", children: r.children }, i, 0, null), (a = Ac(a, i, s, null)).flags |= 2, r.return = t, a.return = t, r.sibling = a, t.child = r, 0 !== (1 & t.mode) && Go(t, e.child, null, s), t.child.memoizedState = zs(s), t.memoizedState = As, a); if (0 === (1 & t.mode)) return Bs(e, t, s, null); if ("$!" === i.data) { if (r = i.nextSibling && i.nextSibling.dataset) var l = r.dgst; return r = l, Bs(e, t, s, r = ds(a = Error(o(419)), r, void 0)) } if (l = 0 !== (s & e.childLanes), xs || l) { if (null !== (r = Nl)) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }0 !== (i = 0 !== (i & (r.suspendedLanes | s)) ? 0 : i) && i !== a.retryLane && (a.retryLane = i, No(e, i), rc(r, e, i, -1)) } return mc(), Bs(e, t, s, r = ds(Error(o(421)))) } return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = Oc.bind(null, e), i._reactRetry = t, null) : (e = a.treeContext, ro = ci(i.nextSibling), no = t, io = !0, oo = null, null !== e && (qi[Ki++] = Xi, qi[Ki++] = Gi, qi[Ki++] = Qi, Xi = e.id, Gi = e.overflow, Qi = t), t = Fs(t, r.children), t.flags |= 4096, t) }(e, t, l, i, r, a, n); if (s) { s = i.fallback, l = t.mode, r = (a = e.child).sibling; var c = { mode: "hidden", children: i.children }; return 0 === (1 & l) && t.child !== a ? ((i = t.child).childLanes = 0, i.pendingProps = c, t.deletions = null) : (i = Rc(a, c)).subtreeFlags = 14680064 & a.subtreeFlags, null !== r ? s = Rc(r, s) : (s = Ac(s, l, n, null)).flags |= 2, s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, l = null === (l = e.child.memoizedState) ? zs(n) : { baseLanes: l.baseLanes | n, cachePool: null, transitions: l.transitions }, s.memoizedState = l, s.childLanes = e.childLanes & ~n, t.memoizedState = As, i } return e = (s = e.child).sibling, i = Rc(s, { mode: "visible", children: i.children }), 0 === (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function Fs(e, t) { return (t = zc({ mode: "visible", children: t }, e.mode, 0, null)).return = e, e.child = t } function Bs(e, t, n, r) { return null !== r && go(r), Go(t, e.child, null, n), (e = Fs(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e } function Ws(e, t, n) { e.lanes |= t; var r = e.alternate; null !== r && (r.lanes |= t), So(e.return, t, n) } function Vs(e, t, n, r, i) { var o = e.memoizedState; null === o ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i) } function Hs(e, t, n) { var r = t.pendingProps, i = r.revealOrder, o = r.tail; if (ws(e, t, r.children, n), 0 !== (2 & (r = la.current))) r = 1 & r | 2, t.flags |= 128; else { if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) { if (13 === e.tag) null !== e.memoizedState && Ws(e, n, t); else if (19 === e.tag) Ws(e, n, t); else if (null !== e.child) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; null === e.sibling;) { if (null === e.return || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Ei(la, r), 0 === (1 & t.mode)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; null !== n;)null !== (e = n.alternate) && null === ca(e) && (i = n), n = n.sibling; null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Vs(t, !1, i, n, o); break; case "backwards": for (n = null, i = t.child, t.child = null; null !== i;) { if (null !== (e = i.alternate) && null === ca(e)) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } Vs(t, !0, n, null, o); break; case "together": Vs(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Us(e, t) { 0 === (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2) } function $s(e, t, n) { if (null !== e && (t.dependencies = e.dependencies), zl |= t.lanes, 0 === (n & t.childLanes)) return null; if (null !== e && t.child !== e.child) throw Error(o(153)); if (null !== t.child) { for (n = Rc(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;)e = e.sibling, (n = n.sibling = Rc(e, e.pendingProps)).return = t; n.sibling = null } return t.child } function Ys(e, t) { if (!io) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; null !== t;)null !== t.alternate && (n = t), t = t.sibling; null === n ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; null !== n;)null !== n.alternate && (r = n), n = n.sibling; null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function qs(e) { var t = null !== e.alternate && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling; else for (i = e.child; null !== i;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function Ks(e, t, n) { var r = t.pendingProps; switch (to(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return qs(t), null; case 1: case 17: return ji(t.type) && Di(), qs(t), null; case 3: return r = t.stateNode, oa(), Ci(Pi), Ci(Oi), da(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (ho(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== oo && (sc(oo), oo = null))), Ds(e, t), qs(t), null; case 5: sa(t); var i = ra(na.current); if (n = t.type, null !== e && null != t.stateNode) Rs(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (null === t.stateNode) throw Error(o(166)); return qs(t), null } if (e = ra(ea.current), ho(t)) { r = t.stateNode, n = t.type; var a = t.memoizedProps; switch (r[hi] = t, r[fi] = a, e = 0 !== (1 & t.mode), n) { case "dialog": Fr("cancel", r), Fr("close", r); break; case "iframe": case "object": case "embed": Fr("load", r); break; case "video": case "audio": for (i = 0; i < Lr.length; i++)Fr(Lr[i], r); break; case "source": Fr("error", r); break; case "img": case "image": case "link": Fr("error", r), Fr("load", r); break; case "details": Fr("toggle", r); break; case "input": X(r, a), Fr("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!a.multiple }, Fr("invalid", r); break; case "textarea": ie(r, a), Fr("invalid", r) }for (var l in ve(n, a), i = null, a) if (a.hasOwnProperty(l)) { var c = a[l]; "children" === l ? "string" === typeof c ? r.textContent !== c && (!0 !== a.suppressHydrationWarning && Jr(r.textContent, c, e), i = ["children", c]) : "number" === typeof c && r.textContent !== "" + c && (!0 !== a.suppressHydrationWarning && Jr(r.textContent, c, e), i = ["children", "" + c]) : s.hasOwnProperty(l) && null != c && "onScroll" === l && Fr("scroll", r) } switch (n) { case "input": Y(r), Z(r, a, !0); break; case "textarea": Y(r), ae(r); break; case "select": case "option": break; default: "function" === typeof a.onClick && (r.onclick = Zr) }r = i, t.updateQueue = r, null !== r && (t.flags |= 4) } else { l = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = se(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = l.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = l.createElement(n, { is: r.is }) : (e = l.createElement(n), "select" === n && (l = e, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : e = l.createElementNS(e, n), e[hi] = t, e[fi] = r, js(e, t, !1, !1), t.stateNode = e; e: { switch (l = ye(n, r), n) { case "dialog": Fr("cancel", e), Fr("close", e), i = r; break; case "iframe": case "object": case "embed": Fr("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Lr.length; i++)Fr(Lr[i], e); i = r; break; case "source": Fr("error", e), i = r; break; case "img": case "image": case "link": Fr("error", e), Fr("load", e), i = r; break; case "details": Fr("toggle", e), i = r; break; case "input": X(e, r), i = Q(e, r), Fr("invalid", e); break; case "option": default: i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = z({}, r, { value: void 0 }), Fr("invalid", e); break; case "textarea": ie(e, r), i = re(e, r), Fr("invalid", e) }for (a in ve(n, i), c = i) if (c.hasOwnProperty(a)) { var u = c[a]; "style" === a ? me(e, u) : "dangerouslySetInnerHTML" === a ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === a ? "string" === typeof u ? ("textarea" !== n || "" !== u) && he(e, u) : "number" === typeof u && he(e, "" + u) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (s.hasOwnProperty(a) ? null != u && "onScroll" === a && Fr("scroll", e) : null != u && y(e, a, u, l)) } switch (n) { case "input": Y(e), Z(e, r, !1); break; case "textarea": Y(e), ae(e); break; case "option": null != r.value && e.setAttribute("value", "" + U(r.value)); break; case "select": e.multiple = !!r.multiple, null != (a = r.value) ? ne(e, !!r.multiple, a, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0); break; default: "function" === typeof i.onClick && (e.onclick = Zr) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } null !== t.ref && (t.flags |= 512, t.flags |= 2097152) } return qs(t), null; case 6: if (e && null != t.stateNode) Ls(e, t, e.memoizedProps, r); else { if ("string" !== typeof r && null === t.stateNode) throw Error(o(166)); if (n = ra(na.current), ra(ea.current), ho(t)) { if (r = t.stateNode, n = t.memoizedProps, r[hi] = t, (a = r.nodeValue !== n) && null !== (e = no)) switch (e.tag) { case 3: Jr(r.nodeValue, n, 0 !== (1 & e.mode)); break; case 5: !0 !== e.memoizedProps.suppressHydrationWarning && Jr(r.nodeValue, n, 0 !== (1 & e.mode)) }a && (t.flags |= 4) } else (r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[hi] = t, t.stateNode = r } return qs(t), null; case 13: if (Ci(la), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) { if (io && null !== ro && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) fo(), po(), t.flags |= 98560, a = !1; else if (a = ho(t), null !== r && null !== r.dehydrated) { if (null === e) { if (!a) throw Error(o(318)); if (!(a = null !== (a = t.memoizedState) ? a.dehydrated : null)) throw Error(o(317)); a[hi] = t } else po(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4; qs(t), a = !1 } else null !== oo && (sc(oo), oo = null), a = !0; if (!a) return 65536 & t.flags ? t : null } return 0 !== (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & la.current) ? 0 === Ll && (Ll = 3) : mc())), null !== t.updateQueue && (t.flags |= 4), qs(t), null); case 4: return oa(), Ds(e, t), null === e && Vr(t.stateNode.containerInfo), qs(t), null; case 10: return ko(t.type._context), qs(t), null; case 19: if (Ci(la), null === (a = t.memoizedState)) return qs(t), null; if (r = 0 !== (128 & t.flags), null === (l = a.rendering)) if (r) Ys(a, !1); else { if (0 !== Ll || null !== e && 0 !== (128 & e.flags)) for (e = t.child; null !== e;) { if (null !== (l = ca(e))) { for (t.flags |= 128, Ys(a, !1), null !== (r = l.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;)e = r, (a = n).flags &= 14680066, null === (l = a.alternate) ? (a.childLanes = 0, a.lanes = e, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = l.childLanes, a.lanes = l.lanes, a.child = l.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = l.memoizedProps, a.memoizedState = l.memoizedState, a.updateQueue = l.updateQueue, a.type = l.type, e = l.dependencies, a.dependencies = null === e ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Ei(la, 1 & la.current | 2), t.child } e = e.sibling } null !== a.tail && Ge() > Hl && (t.flags |= 128, r = !0, Ys(a, !1), t.lanes = 4194304) } else { if (!r) if (null !== (e = ca(l))) { if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), Ys(a, !0), null === a.tail && "hidden" === a.tailMode && !l.alternate && !io) return qs(t), null } else 2 * Ge() - a.renderingStartTime > Hl && 1073741824 !== n && (t.flags |= 128, r = !0, Ys(a, !1), t.lanes = 4194304); a.isBackwards ? (l.sibling = t.child, t.child = l) : (null !== (n = a.last) ? n.sibling = l : t.child = l, a.last = l) } return null !== a.tail ? (t = a.tail, a.rendering = t, a.tail = t.sibling, a.renderingStartTime = Ge(), t.sibling = null, n = la.current, Ei(la, r ? 1 & n | 2 : 1 & n), t) : (qs(t), null); case 22: case 23: return hc(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Dl) && (qs(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : qs(t), null; case 24: case 25: return null }throw Error(o(156, t.tag)) } function Qs(e, t) { switch (to(t), t.tag) { case 1: return ji(t.type) && Di(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 3: return oa(), Ci(Pi), Ci(Oi), da(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null; case 5: return sa(t), null; case 13: if (Ci(la), null !== (e = t.memoizedState) && null !== e.dehydrated) { if (null === t.alternate) throw Error(o(340)); po() } return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null; case 19: return Ci(la), null; case 4: return oa(), null; case 10: return ko(t.type._context), null; case 22: case 23: return hc(), null; default: return null } } js = function (e, t) { for (var n = t.child; null !== n;) { if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode); else if (4 !== n.tag && null !== n.child) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; null === n.sibling;) { if (null === n.return || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }, Ds = function () { }, Rs = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, ra(ea.current); var o, a = null; switch (n) { case "input": i = Q(e, i), r = Q(e, r), a = []; break; case "select": i = z({}, i, { value: void 0 }), r = z({}, r, { value: void 0 }), a = []; break; case "textarea": i = re(e, i), r = re(e, r), a = []; break; default: "function" !== typeof i.onClick && "function" === typeof r.onClick && (e.onclick = Zr) }for (u in ve(n, r), n = null, i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u]) if ("style" === u) { var l = i[u]; for (o in l) l.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (s.hasOwnProperty(u) ? a || (a = []) : (a = a || []).push(u, null)); for (u in r) { var c = r[u]; if (l = null != i ? i[u] : void 0, r.hasOwnProperty(u) && c !== l && (null != c || null != l)) if ("style" === u) if (l) { for (o in l) !l.hasOwnProperty(o) || c && c.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in c) c.hasOwnProperty(o) && l[o] !== c[o] && (n || (n = {}), n[o] = c[o]) } else n || (a || (a = []), a.push(u, n)), n = c; else "dangerouslySetInnerHTML" === u ? (c = c ? c.__html : void 0, l = l ? l.__html : void 0, null != c && l !== c && (a = a || []).push(u, c)) : "children" === u ? "string" !== typeof c && "number" !== typeof c || (a = a || []).push(u, "" + c) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (s.hasOwnProperty(u) ? (null != c && "onScroll" === u && Fr("scroll", e), a || l === c || (a = [])) : (a = a || []).push(u, c)) } n && (a = a || []).push("style", n); var u = a; (t.updateQueue = u) && (t.flags |= 4) } }, Ls = function (e, t, n, r) { n !== r && (t.flags |= 4) }; var Xs = !1, Gs = !1, Js = "function" === typeof WeakSet ? WeakSet : Set, Zs = null; function el(e, t) { var n = e.ref; if (null !== n) if ("function" === typeof n) try { n(null) } catch (r) { Cc(e, t, r) } else n.current = null } function tl(e, t, n) { try { n() } catch (r) { Cc(e, t, r) } } var nl = !1; function rl(e, t, n) { var r = t.updateQueue; if (null !== (r = null !== r ? r.lastEffect : null)) { var i = r = r.next; do { if ((i.tag & e) === e) { var o = i.destroy; i.destroy = void 0, void 0 !== o && tl(t, n, o) } i = i.next } while (i !== r) } } function il(e, t) { if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function ol(e) { var t = e.ref; if (null !== t) { var n = e.stateNode; e.tag, e = n, "function" === typeof t ? t(e) : t.current = e } } function al(e) { var t = e.alternate; null !== t && (e.alternate = null, al(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && (delete t[hi], delete t[fi], delete t[gi], delete t[mi], delete t[bi])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function sl(e) { return 5 === e.tag || 3 === e.tag || 4 === e.tag } function ll(e) { e: for (; ;) { for (; null === e.sibling;) { if (null === e.return || sl(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) { if (2 & e.flags) continue e; if (null === e.child || 4 === e.tag) continue e; e.child.return = e, e = e.child } if (!(2 & e.flags)) return e.stateNode } } function cl(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = Zr)); else if (4 !== r && null !== (e = e.child)) for (cl(e, t, n), e = e.sibling; null !== e;)cl(e, t, n), e = e.sibling } function ul(e, t, n) { var r = e.tag; if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (4 !== r && null !== (e = e.child)) for (ul(e, t, n), e = e.sibling; null !== e;)ul(e, t, n), e = e.sibling } var dl = null, hl = !1; function fl(e, t, n) { for (n = n.child; null !== n;)pl(e, t, n), n = n.sibling } function pl(e, t, n) { if (ot && "function" === typeof ot.onCommitFiberUnmount) try { ot.onCommitFiberUnmount(it, n) } catch (s) { } switch (n.tag) { case 5: Gs || el(n, t); case 6: var r = dl, i = hl; dl = null, fl(e, t, n), hl = i, null !== (dl = r) && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : dl.removeChild(n.stateNode)); break; case 18: null !== dl && (hl ? (e = dl, n = n.stateNode, 8 === e.nodeType ? li(e.parentNode, n) : 1 === e.nodeType && li(e, n), Vt(e)) : li(dl, n.stateNode)); break; case 4: r = dl, i = hl, dl = n.stateNode.containerInfo, hl = !0, fl(e, t, n), dl = r, hl = i; break; case 0: case 11: case 14: case 15: if (!Gs && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) { i = r = r.next; do { var o = i, a = o.destroy; o = o.tag, void 0 !== a && (0 !== (2 & o) || 0 !== (4 & o)) && tl(n, t, a), i = i.next } while (i !== r) } fl(e, t, n); break; case 1: if (!Gs && (el(n, t), "function" === typeof (r = n.stateNode).componentWillUnmount)) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (s) { Cc(n, t, s) } fl(e, t, n); break; case 21: fl(e, t, n); break; case 22: 1 & n.mode ? (Gs = (r = Gs) || null !== n.memoizedState, fl(e, t, n), Gs = r) : fl(e, t, n); break; default: fl(e, t, n) } } function gl(e) { var t = e.updateQueue; if (null !== t) { e.updateQueue = null; var n = e.stateNode; null === n && (n = e.stateNode = new Js), t.forEach((function (t) { var r = Pc.bind(null, e, t); n.has(t) || (n.add(t), t.then(r, r)) })) } } function ml(e, t) { var n = t.deletions; if (null !== n) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var a = e, s = t, l = s; e: for (; null !== l;) { switch (l.tag) { case 5: dl = l.stateNode, hl = !1; break e; case 3: case 4: dl = l.stateNode.containerInfo, hl = !0; break e }l = l.return } if (null === dl) throw Error(o(160)); pl(a, s, i), dl = null, hl = !1; var c = i.alternate; null !== c && (c.return = null), i.return = null } catch (u) { Cc(i, t, u) } } if (12854 & t.subtreeFlags) for (t = t.child; null !== t;)bl(t, e), t = t.sibling } function bl(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (ml(t, e), vl(e), 4 & r) { try { rl(3, e, e.return), il(3, e) } catch (m) { Cc(e, e.return, m) } try { rl(5, e, e.return) } catch (m) { Cc(e, e.return, m) } } break; case 1: ml(t, e), vl(e), 512 & r && null !== n && el(n, n.return); break; case 5: if (ml(t, e), vl(e), 512 & r && null !== n && el(n, n.return), 32 & e.flags) { var i = e.stateNode; try { he(i, "") } catch (m) { Cc(e, e.return, m) } } if (4 & r && null != (i = e.stateNode)) { var a = e.memoizedProps, s = null !== n ? n.memoizedProps : a, l = e.type, c = e.updateQueue; if (e.updateQueue = null, null !== c) try { "input" === l && "radio" === a.type && null != a.name && G(i, a), ye(l, s); var u = ye(l, a); for (s = 0; s < c.length; s += 2) { var d = c[s], h = c[s + 1]; "style" === d ? me(i, h) : "dangerouslySetInnerHTML" === d ? de(i, h) : "children" === d ? he(i, h) : y(i, d, h, u) } switch (l) { case "input": J(i, a); break; case "textarea": oe(i, a); break; case "select": var f = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!a.multiple; var p = a.value; null != p ? ne(i, !!a.multiple, p, !1) : f !== !!a.multiple && (null != a.defaultValue ? ne(i, !!a.multiple, a.defaultValue, !0) : ne(i, !!a.multiple, a.multiple ? [] : "", !1)) }i[fi] = a } catch (m) { Cc(e, e.return, m) } } break; case 6: if (ml(t, e), vl(e), 4 & r) { if (null === e.stateNode) throw Error(o(162)); i = e.stateNode, a = e.memoizedProps; try { i.nodeValue = a } catch (m) { Cc(e, e.return, m) } } break; case 3: if (ml(t, e), vl(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try { Vt(t.containerInfo) } catch (m) { Cc(e, e.return, m) } break; case 4: default: ml(t, e), vl(e); break; case 13: ml(t, e), vl(e), 8192 & (i = e.child).flags && (a = null !== i.memoizedState, i.stateNode.isHidden = a, !a || null !== i.alternate && null !== i.alternate.memoizedState || (Vl = Ge())), 4 & r && gl(e); break; case 22: if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (Gs = (u = Gs) || d, ml(t, e), Gs = u) : ml(t, e), vl(e), 8192 & r) { if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !d && 0 !== (1 & e.mode)) for (Zs = e, d = e.child; null !== d;) { for (h = Zs = d; null !== Zs;) { switch (p = (f = Zs).child, f.tag) { case 0: case 11: case 14: case 15: rl(4, f, f.return); break; case 1: el(f, f.return); var g = f.stateNode; if ("function" === typeof g.componentWillUnmount) { r = f, n = f.return; try { t = r, g.props = t.memoizedProps, g.state = t.memoizedState, g.componentWillUnmount() } catch (m) { Cc(r, n, m) } } break; case 5: el(f, f.return); break; case 22: if (null !== f.memoizedState) { _l(h); continue } }null !== p ? (p.return = f, Zs = p) : _l(h) } d = d.sibling } e: for (d = null, h = e; ;) { if (5 === h.tag) { if (null === d) { d = h; try { i = h.stateNode, u ? "function" === typeof (a = i.style).setProperty ? a.setProperty("display", "none", "important") : a.display = "none" : (l = h.stateNode, s = void 0 !== (c = h.memoizedProps.style) && null !== c && c.hasOwnProperty("display") ? c.display : null, l.style.display = ge("display", s)) } catch (m) { Cc(e, e.return, m) } } } else if (6 === h.tag) { if (null === d) try { h.stateNode.nodeValue = u ? "" : h.memoizedProps } catch (m) { Cc(e, e.return, m) } } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) { h.child.return = h, h = h.child; continue } if (h === e) break e; for (; null === h.sibling;) { if (null === h.return || h.return === e) break e; d === h && (d = null), h = h.return } d === h && (d = null), h.sibling.return = h.return, h = h.sibling } } break; case 19: ml(t, e), vl(e), 4 & r && gl(e); case 21: } } function vl(e) { var t = e.flags; if (2 & t) { try { e: { for (var n = e.return; null !== n;) { if (sl(n)) { var r = n; break e } n = n.return } throw Error(o(160)) } switch (r.tag) { case 5: var i = r.stateNode; 32 & r.flags && (he(i, ""), r.flags &= -33), ul(e, ll(e), i); break; case 3: case 4: var a = r.stateNode.containerInfo; cl(e, ll(e), a); break; default: throw Error(o(161)) } } catch (s) { Cc(e, e.return, s) } e.flags &= -3 } 4096 & t && (e.flags &= -4097) } function yl(e, t, n) { Zs = e, xl(e, t, n) } function xl(e, t, n) { for (var r = 0 !== (1 & e.mode); null !== Zs;) { var i = Zs, o = i.child; if (22 === i.tag && r) { var a = null !== i.memoizedState || Xs; if (!a) { var s = i.alternate, l = null !== s && null !== s.memoizedState || Gs; s = Xs; var c = Gs; if (Xs = a, (Gs = l) && !c) for (Zs = i; null !== Zs;)l = (a = Zs).child, 22 === a.tag && null !== a.memoizedState ? kl(i) : null !== l ? (l.return = a, Zs = l) : kl(i); for (; null !== o;)Zs = o, xl(o, t, n), o = o.sibling; Zs = i, Xs = s, Gs = c } wl(e) } else 0 !== (8772 & i.subtreeFlags) && null !== o ? (o.return = i, Zs = o) : wl(e) } } function wl(e) { for (; null !== Zs;) { var t = Zs; if (0 !== (8772 & t.flags)) { var n = t.alternate; try { if (0 !== (8772 & t.flags)) switch (t.tag) { case 0: case 11: case 15: Gs || il(5, t); break; case 1: var r = t.stateNode; if (4 & t.flags && !Gs) if (null === n) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : bo(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var a = t.updateQueue; null !== a && Fo(t, a, r); break; case 3: var s = t.updateQueue; if (null !== s) { if (n = null, null !== t.child) switch (t.child.tag) { case 5: case 1: n = t.child.stateNode }Fo(t, s, n) } break; case 5: var l = t.stateNode; if (null === n && 4 & t.flags) { n = l; var c = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": c.autoFocus && n.focus(); break; case "img": c.src && (n.src = c.src) } } break; case 6: case 4: case 12: case 19: case 17: case 21: case 22: case 23: case 25: break; case 13: if (null === t.memoizedState) { var u = t.alternate; if (null !== u) { var d = u.memoizedState; if (null !== d) { var h = d.dehydrated; null !== h && Vt(h) } } } break; default: throw Error(o(163)) }Gs || 512 & t.flags && ol(t) } catch (f) { Cc(t, t.return, f) } } if (t === e) { Zs = null; break } if (null !== (n = t.sibling)) { n.return = t.return, Zs = n; break } Zs = t.return } } function _l(e) { for (; null !== Zs;) { var t = Zs; if (t === e) { Zs = null; break } var n = t.sibling; if (null !== n) { n.return = t.return, Zs = n; break } Zs = t.return } } function kl(e) { for (; null !== Zs;) { var t = Zs; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { il(4, t) } catch (l) { Cc(t, n, l) } break; case 1: var r = t.stateNode; if ("function" === typeof r.componentDidMount) { var i = t.return; try { r.componentDidMount() } catch (l) { Cc(t, i, l) } } var o = t.return; try { ol(t) } catch (l) { Cc(t, o, l) } break; case 5: var a = t.return; try { ol(t) } catch (l) { Cc(t, a, l) } } } catch (l) { Cc(t, t.return, l) } if (t === e) { Zs = null; break } var s = t.sibling; if (null !== s) { s.return = t.return, Zs = s; break } Zs = t.return } } var Sl, Cl = Math.ceil, El = x.ReactCurrentDispatcher, Ml = x.ReactCurrentOwner, Ol = x.ReactCurrentBatchConfig, Pl = 0, Nl = null, Tl = null, jl = 0, Dl = 0, Rl = Si(0), Ll = 0, Al = null, zl = 0, Il = 0, Fl = 0, Bl = null, Wl = null, Vl = 0, Hl = 1 / 0, Ul = null, $l = !1, Yl = null, ql = null, Kl = !1, Ql = null, Xl = 0, Gl = 0, Jl = null, Zl = -1, ec = 0; function tc() { return 0 !== (6 & Pl) ? Ge() : -1 !== Zl ? Zl : Zl = Ge() } function nc(e) { return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Pl) && 0 !== jl ? jl & -jl : null !== mo.transition ? (0 === ec && (ec = gt()), ec) : 0 !== (e = yt) ? e : e = void 0 === (e = window.event) ? 16 : Xt(e.type) } function rc(e, t, n, r) { if (50 < Gl) throw Gl = 0, Jl = null, Error(o(185)); bt(e, n, r), 0 !== (2 & Pl) && e === Nl || (e === Nl && (0 === (2 & Pl) && (Il |= n), 4 === Ll && lc(e, jl)), ic(e, r), 1 === n && 0 === Pl && 0 === (1 & t.mode) && (Hl = Ge() + 500, Fi && Vi())) } function ic(e, t) { var n = e.callbackNode; !function (e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var a = 31 - at(o), s = 1 << a, l = i[a]; -1 === l ? 0 !== (s & n) && 0 === (s & r) || (i[a] = ft(s, t)) : l <= t && (e.expiredLanes |= s), o &= ~s } }(e, t); var r = ht(e, e === Nl ? jl : 0); if (0 === r) null !== n && Ke(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (null != n && Ke(n), 1 === t) 0 === e.tag ? function (e) { Fi = !0, Wi(e) }(cc.bind(null, e)) : Wi(cc.bind(null, e)), ai((function () { 0 === (6 & Pl) && Vi() })), n = null; else { switch (xt(r)) { case 1: n = Ze; break; case 4: n = et; break; case 16: default: n = tt; break; case 536870912: n = rt }n = Nc(n, oc.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function oc(e, t) { if (Zl = -1, ec = 0, 0 !== (6 & Pl)) throw Error(o(327)); var n = e.callbackNode; if (kc() && e.callbackNode !== n) return null; var r = ht(e, e === Nl ? jl : 0); if (0 === r) return null; if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = bc(e, r); else { t = r; var i = Pl; Pl |= 2; var a = gc(); for (Nl === e && jl === t || (Ul = null, Hl = Ge() + 500, fc(e, t)); ;)try { yc(); break } catch (l) { pc(e, l) } _o(), El.current = a, Pl = i, null !== Tl ? t = 0 : (Nl = null, jl = 0, t = Ll) } if (0 !== t) { if (2 === t && (0 !== (i = pt(e)) && (r = i, t = ac(e, i))), 1 === t) throw n = Al, fc(e, 0), lc(e, r), ic(e, Ge()), n; if (6 === t) lc(e, r); else { if (i = e.current.alternate, 0 === (30 & r) && !function (e) { for (var t = e; ;) { if (16384 & t.flags) { var n = t.updateQueue; if (null !== n && null !== (n = n.stores)) for (var r = 0; r < n.length; r++) { var i = n[r], o = i.getSnapshot; i = i.value; try { if (!sr(o(), i)) return !1 } catch (s) { return !1 } } } if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n; else { if (t === e) break; for (; null === t.sibling;) { if (null === t.return || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 }(i) && (2 === (t = bc(e, r)) && (0 !== (a = pt(e)) && (r = a, t = ac(e, a))), 1 === t)) throw n = Al, fc(e, 0), lc(e, r), ic(e, Ge()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(o(345)); case 2: case 5: _c(e, Wl, Ul); break; case 3: if (lc(e, r), (130023424 & r) === r && 10 < (t = Vl + 500 - Ge())) { if (0 !== ht(e, 0)) break; if (((i = e.suspendedLanes) & r) !== r) { tc(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = ri(_c.bind(null, e, Wl, Ul), t); break } _c(e, Wl, Ul); break; case 4: if (lc(e, r), (4194240 & r) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - at(r); a = 1 << s, (s = t[s]) > i && (i = s), r &= ~a } if (r = i, 10 < (r = (120 > (r = Ge() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Cl(r / 1960)) - r)) { e.timeoutHandle = ri(_c.bind(null, e, Wl, Ul), r); break } _c(e, Wl, Ul); break; default: throw Error(o(329)) } } } return ic(e, Ge()), e.callbackNode === n ? oc.bind(null, e) : null } function ac(e, t) { var n = Bl; return e.current.memoizedState.isDehydrated && (fc(e, t).flags |= 256), 2 !== (e = bc(e, t)) && (t = Wl, Wl = n, null !== t && sc(t)), e } function sc(e) { null === Wl ? Wl = e : Wl.push.apply(Wl, e) } function lc(e, t) { for (t &= ~Fl, t &= ~Il, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - at(t), r = 1 << n; e[n] = -1, t &= ~r } } function cc(e) { if (0 !== (6 & Pl)) throw Error(o(327)); kc(); var t = ht(e, 0); if (0 === (1 & t)) return ic(e, Ge()), null; var n = bc(e, t); if (0 !== e.tag && 2 === n) { var r = pt(e); 0 !== r && (t = r, n = ac(e, r)) } if (1 === n) throw n = Al, fc(e, 0), lc(e, t), ic(e, Ge()), n; if (6 === n) throw Error(o(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, _c(e, Wl, Ul), ic(e, Ge()), null } function uc(e, t) { var n = Pl; Pl |= 1; try { return e(t) } finally { 0 === (Pl = n) && (Hl = Ge() + 500, Fi && Vi()) } } function dc(e) { null !== Ql && 0 === Ql.tag && 0 === (6 & Pl) && kc(); var t = Pl; Pl |= 1; var n = Ol.transition, r = yt; try { if (Ol.transition = null, yt = 1, e) return e() } finally { yt = r, Ol.transition = n, 0 === (6 & (Pl = t)) && Vi() } } function hc() { Dl = Rl.current, Ci(Rl) } function fc(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Tl) for (n = Tl.return; null !== n;) { var r = n; switch (to(r), r.tag) { case 1: null !== (r = r.type.childContextTypes) && void 0 !== r && Di(); break; case 3: oa(), Ci(Pi), Ci(Oi), da(); break; case 5: sa(r); break; case 4: oa(); break; case 13: case 19: Ci(la); break; case 10: ko(r.type._context); break; case 22: case 23: hc() }n = n.return } if (Nl = e, Tl = e = Rc(e.current, null), jl = Dl = t, Ll = 0, Al = null, Fl = Il = zl = 0, Wl = Bl = null, null !== Mo) { for (t = 0; t < Mo.length; t++)if (null !== (r = (n = Mo[t]).interleaved)) { n.interleaved = null; var i = r.next, o = n.pending; if (null !== o) { var a = o.next; o.next = i, r.next = a } n.pending = r } Mo = null } return e } function pc(e, t) { for (; ;) { var n = Tl; try { if (_o(), ha.current = as, va) { for (var r = ga.memoizedState; null !== r;) { var i = r.queue; null !== i && (i.pending = null), r = r.next } va = !1 } if (pa = 0, ba = ma = ga = null, ya = !1, xa = 0, Ml.current = null, null === n || null === n.return) { Ll = 1, Al = t, Tl = null; break } e: { var a = e, s = n.return, l = n, c = t; if (t = jl, l.flags |= 32768, null !== c && "object" === typeof c && "function" === typeof c.then) { var u = c, d = l, h = d.tag; if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) { var f = d.alternate; f ? (d.updateQueue = f.updateQueue, d.memoizedState = f.memoizedState, d.lanes = f.lanes) : (d.updateQueue = null, d.memoizedState = null) } var p = bs(s); if (null !== p) { p.flags &= -257, vs(p, s, l, 0, t), 1 & p.mode && ms(a, u, t), c = u; var g = (t = p).updateQueue; if (null === g) { var m = new Set; m.add(c), t.updateQueue = m } else g.add(c); break e } if (0 === (1 & t)) { ms(a, u, t), mc(); break e } c = Error(o(426)) } else if (io && 1 & l.mode) { var b = bs(s); if (null !== b) { 0 === (65536 & b.flags) && (b.flags |= 256), vs(b, s, l, 0, t), go(us(c, l)); break e } } a = c = us(c, l), 4 !== Ll && (Ll = 2), null === Bl ? Bl = [a] : Bl.push(a), a = s; do { switch (a.tag) { case 3: a.flags |= 65536, t &= -t, a.lanes |= t, zo(a, ps(0, c, t)); break e; case 1: l = c; var v = a.type, y = a.stateNode; if (0 === (128 & a.flags) && ("function" === typeof v.getDerivedStateFromError || null !== y && "function" === typeof y.componentDidCatch && (null === ql || !ql.has(y)))) { a.flags |= 65536, t &= -t, a.lanes |= t, zo(a, gs(a, l, t)); break e } }a = a.return } while (null !== a) } wc(n) } catch (x) { t = x, Tl === n && null !== n && (Tl = n = n.return); continue } break } } function gc() { var e = El.current; return El.current = as, null === e ? as : e } function mc() { 0 !== Ll && 3 !== Ll && 2 !== Ll || (Ll = 4), null === Nl || 0 === (268435455 & zl) && 0 === (268435455 & Il) || lc(Nl, jl) } function bc(e, t) { var n = Pl; Pl |= 2; var r = gc(); for (Nl === e && jl === t || (Ul = null, fc(e, t)); ;)try { vc(); break } catch (i) { pc(e, i) } if (_o(), Pl = n, El.current = r, null !== Tl) throw Error(o(261)); return Nl = null, jl = 0, Ll } function vc() { for (; null !== Tl;)xc(Tl) } function yc() { for (; null !== Tl && !Qe();)xc(Tl) } function xc(e) { var t = Sl(e.alternate, e, Dl); e.memoizedProps = e.pendingProps, null === t ? wc(e) : Tl = t, Ml.current = null } function wc(e) { var t = e; do { var n = t.alternate; if (e = t.return, 0 === (32768 & t.flags)) { if (null !== (n = Ks(n, t, Dl))) return void (Tl = n) } else { if (null !== (n = Qs(n, t))) return n.flags &= 32767, void (Tl = n); if (null === e) return Ll = 6, void (Tl = null); e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null } if (null !== (t = t.sibling)) return void (Tl = t); Tl = t = e } while (null !== t); 0 === Ll && (Ll = 5) } function _c(e, t, n) { var r = yt, i = Ol.transition; try { Ol.transition = null, yt = 1, function (e, t, n, r) { do { kc() } while (null !== Ql); if (0 !== (6 & Pl)) throw Error(o(327)); n = e.finishedWork; var i = e.finishedLanes; if (null === n) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(o(177)); e.callbackNode = null, e.callbackPriority = 0; var a = n.lanes | n.childLanes; if (function (e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - at(n), o = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o } }(e, a), e === Nl && (Tl = Nl = null, jl = 0), 0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Kl || (Kl = !0, Nc(tt, (function () { return kc(), null }))), a = 0 !== (15990 & n.flags), 0 !== (15990 & n.subtreeFlags) || a) { a = Ol.transition, Ol.transition = null; var s = yt; yt = 1; var l = Pl; Pl |= 4, Ml.current = null, function (e, t) { if (ei = Ut, fr(e = hr())) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection(); if (r && 0 !== r.rangeCount) { n = r.anchorNode; var i = r.anchorOffset, a = r.focusNode; r = r.focusOffset; try { n.nodeType, a.nodeType } catch (w) { n = null; break e } var s = 0, l = -1, c = -1, u = 0, d = 0, h = e, f = null; t: for (; ;) { for (var p; h !== n || 0 !== i && 3 !== h.nodeType || (l = s + i), h !== a || 0 !== r && 3 !== h.nodeType || (c = s + r), 3 === h.nodeType && (s += h.nodeValue.length), null !== (p = h.firstChild);)f = h, h = p; for (; ;) { if (h === e) break t; if (f === n && ++u === i && (l = s), f === a && ++d === r && (c = s), null !== (p = h.nextSibling)) break; f = (h = f).parentNode } h = p } n = -1 === l || -1 === c ? null : { start: l, end: c } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (ti = { focusedElem: e, selectionRange: n }, Ut = !1, Zs = t; null !== Zs;)if (e = (t = Zs).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, Zs = e; else for (; null !== Zs;) { t = Zs; try { var g = t.alternate; if (0 !== (1024 & t.flags)) switch (t.tag) { case 0: case 11: case 15: case 5: case 6: case 4: case 17: break; case 1: if (null !== g) { var m = g.memoizedProps, b = g.memoizedState, v = t.stateNode, y = v.getSnapshotBeforeUpdate(t.elementType === t.type ? m : bo(t.type, m), b); v.__reactInternalSnapshotBeforeUpdate = y } break; case 3: var x = t.stateNode.containerInfo; 1 === x.nodeType ? x.textContent = "" : 9 === x.nodeType && x.documentElement && x.removeChild(x.documentElement); break; default: throw Error(o(163)) } } catch (w) { Cc(t, t.return, w) } if (null !== (e = t.sibling)) { e.return = t.return, Zs = e; break } Zs = t.return } g = nl, nl = !1 }(e, n), bl(n, e), pr(ti), Ut = !!ei, ti = ei = null, e.current = n, yl(n, e, i), Xe(), Pl = l, yt = s, Ol.transition = a } else e.current = n; if (Kl && (Kl = !1, Ql = e, Xl = i), a = e.pendingLanes, 0 === a && (ql = null), function (e) { if (ot && "function" === typeof ot.onCommitFiberRoot) try { ot.onCommitFiberRoot(it, e, void 0, 128 === (128 & e.current.flags)) } catch (t) { } }(n.stateNode), ic(e, Ge()), null !== t) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if ($l) throw $l = !1, e = Yl, Yl = null, e; 0 !== (1 & Xl) && 0 !== e.tag && kc(), a = e.pendingLanes, 0 !== (1 & a) ? e === Jl ? Gl++ : (Gl = 0, Jl = e) : Gl = 0, Vi() }(e, t, n, r) } finally { Ol.transition = i, yt = r } return null } function kc() { if (null !== Ql) { var e = xt(Xl), t = Ol.transition, n = yt; try { if (Ol.transition = null, yt = 16 > e ? 16 : e, null === Ql) var r = !1; else { if (e = Ql, Ql = null, Xl = 0, 0 !== (6 & Pl)) throw Error(o(331)); var i = Pl; for (Pl |= 4, Zs = e.current; null !== Zs;) { var a = Zs, s = a.child; if (0 !== (16 & Zs.flags)) { var l = a.deletions; if (null !== l) { for (var c = 0; c < l.length; c++) { var u = l[c]; for (Zs = u; null !== Zs;) { var d = Zs; switch (d.tag) { case 0: case 11: case 15: rl(8, d, a) }var h = d.child; if (null !== h) h.return = d, Zs = h; else for (; null !== Zs;) { var f = (d = Zs).sibling, p = d.return; if (al(d), d === u) { Zs = null; break } if (null !== f) { f.return = p, Zs = f; break } Zs = p } } } var g = a.alternate; if (null !== g) { var m = g.child; if (null !== m) { g.child = null; do { var b = m.sibling; m.sibling = null, m = b } while (null !== m) } } Zs = a } } if (0 !== (2064 & a.subtreeFlags) && null !== s) s.return = a, Zs = s; else e: for (; null !== Zs;) { if (0 !== (2048 & (a = Zs).flags)) switch (a.tag) { case 0: case 11: case 15: rl(9, a, a.return) }var v = a.sibling; if (null !== v) { v.return = a.return, Zs = v; break e } Zs = a.return } } var y = e.current; for (Zs = y; null !== Zs;) { var x = (s = Zs).child; if (0 !== (2064 & s.subtreeFlags) && null !== x) x.return = s, Zs = x; else e: for (s = y; null !== Zs;) { if (0 !== (2048 & (l = Zs).flags)) try { switch (l.tag) { case 0: case 11: case 15: il(9, l) } } catch (_) { Cc(l, l.return, _) } if (l === s) { Zs = null; break e } var w = l.sibling; if (null !== w) { w.return = l.return, Zs = w; break e } Zs = l.return } } if (Pl = i, Vi(), ot && "function" === typeof ot.onPostCommitFiberRoot) try { ot.onPostCommitFiberRoot(it, e) } catch (_) { } r = !0 } return r } finally { yt = n, Ol.transition = t } } return !1 } function Sc(e, t, n) { e = Lo(e, t = ps(0, t = us(n, t), 1), 1), t = tc(), null !== e && (bt(e, 1, t), ic(e, t)) } function Cc(e, t, n) { if (3 === e.tag) Sc(e, e, n); else for (; null !== t;) { if (3 === t.tag) { Sc(t, e, n); break } if (1 === t.tag) { var r = t.stateNode; if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === ql || !ql.has(r))) { t = Lo(t, e = gs(t, e = us(n, e), 1), 1), e = tc(), null !== t && (bt(t, 1, e), ic(t, e)); break } } t = t.return } } function Ec(e, t, n) { var r = e.pingCache; null !== r && r.delete(t), t = tc(), e.pingedLanes |= e.suspendedLanes & n, Nl === e && (jl & n) === n && (4 === Ll || 3 === Ll && (130023424 & jl) === jl && 500 > Ge() - Vl ? fc(e, 0) : Fl |= n), ic(e, t) } function Mc(e, t) { 0 === t && (0 === (1 & e.mode) ? t = 1 : (t = ut, 0 === (130023424 & (ut <<= 1)) && (ut = 4194304))); var n = tc(); null !== (e = No(e, t)) && (bt(e, t, n), ic(e, n)) } function Oc(e) { var t = e.memoizedState, n = 0; null !== t && (n = t.retryLane), Mc(e, n) } function Pc(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; null !== i && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(o(314)) }null !== r && r.delete(t), Mc(e, n) } function Nc(e, t) { return qe(e, t) } function Tc(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function jc(e, t, n, r) { return new Tc(e, t, n, r) } function Dc(e) { return !(!(e = e.prototype) || !e.isReactComponent) } function Rc(e, t) { var n = e.alternate; return null === n ? ((n = jc(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Lc(e, t, n, r, i, a) { var s = 2; if (r = e, "function" === typeof e) Dc(e) && (s = 1); else if ("string" === typeof e) s = 5; else e: switch (e) { case k: return Ac(n.children, i, a, t); case S: s = 8, i |= 8; break; case C: return (e = jc(12, n, t, 2 | i)).elementType = C, e.lanes = a, e; case P: return (e = jc(13, n, t, i)).elementType = P, e.lanes = a, e; case N: return (e = jc(19, n, t, i)).elementType = N, e.lanes = a, e; case D: return zc(n, i, a, t); default: if ("object" === typeof e && null !== e) switch (e.$$typeof) { case E: s = 10; break e; case M: s = 9; break e; case O: s = 11; break e; case T: s = 14; break e; case j: s = 16, r = null; break e }throw Error(o(130, null == e ? e : typeof e, "")) }return (t = jc(s, n, t, i)).elementType = e, t.type = r, t.lanes = a, t } function Ac(e, t, n, r) { return (e = jc(7, e, r, t)).lanes = n, e } function zc(e, t, n, r) { return (e = jc(22, e, r, t)).elementType = D, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function Ic(e, t, n) { return (e = jc(6, e, null, t)).lanes = n, e } function Fc(e, t, n) { return (t = jc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function Bc(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = mt(0), this.expirationTimes = mt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = mt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Wc(e, t, n, r, i, o, a, s, l) { return e = new Bc(e, t, n, s, l), 1 === t ? (t = 1, !0 === o && (t |= 8)) : t = 0, o = jc(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, jo(o), e } function Vc(e) { if (!e) return Mi; e: { if (Ve(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(o(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (ji(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (null !== t); throw Error(o(171)) } if (1 === e.tag) { var n = e.type; if (ji(n)) return Li(e, n, t) } return t } function Hc(e, t, n, r, i, o, a, s, l) { return (e = Wc(n, r, !0, e, 0, o, 0, s, l)).context = Vc(null), n = e.current, (o = Ro(r = tc(), i = nc(n))).callback = void 0 !== t && null !== t ? t : null, Lo(n, o, i), e.current.lanes = i, bt(e, i, r), ic(e, r), e } function Uc(e, t, n, r) { var i = t.current, o = tc(), a = nc(i); return n = Vc(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Ro(o, a)).payload = { element: e }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = Lo(i, t, a)) && (rc(e, i, a, o), Ao(e, i, a)), a } function $c(e) { return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null } function Yc(e, t) { if (null !== (e = e.memoizedState) && null !== e.dehydrated) { var n = e.retryLane; e.retryLane = 0 !== n && n < t ? n : t } } function qc(e, t) { Yc(e, t), (e = e.alternate) && Yc(e, t) } Sl = function (e, t, n) { if (null !== e) if (e.memoizedProps !== t.pendingProps || Pi.current) xs = !0; else { if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return xs = !1, function (e, t, n) { switch (t.tag) { case 3: Ns(t), po(); break; case 5: aa(t); break; case 1: ji(t.type) && Ai(t); break; case 4: ia(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Ei(vo, r._currentValue), r._currentValue = i; break; case 13: if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ei(la, 1 & la.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? Is(e, t, n) : (Ei(la, 1 & la.current), null !== (e = $s(e, t, n)) ? e.sibling : null); Ei(la, 1 & la.current); break; case 19: if (r = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) { if (r) return Hs(e, t, n); t.flags |= 128 } if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ei(la, la.current), r) break; return null; case 22: case 23: return t.lanes = 0, Cs(e, t, n) }return $s(e, t, n) }(e, t, n); xs = 0 !== (131072 & e.flags) } else xs = !1, io && 0 !== (1048576 & t.flags) && Zi(t, Yi, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Us(e, t), e = t.pendingProps; var i = Ti(t, Oi.current); Co(t, n), i = Sa(null, t, r, e, i, n); var a = Ca(); return t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, ji(r) ? (a = !0, Ai(t)) : a = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, jo(t), i.updater = Vo, t.stateNode = i, i._reactInternals = t, Yo(t, r, e, n), t = Ps(null, t, r, !0, a, n)) : (t.tag = 0, io && a && eo(t), ws(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Us(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function (e) { if ("function" === typeof e) return Dc(e) ? 1 : 0; if (void 0 !== e && null !== e) { if ((e = e.$$typeof) === O) return 11; if (e === T) return 14 } return 2 }(r), e = bo(r, e), i) { case 0: t = Ms(null, t, r, e, n); break e; case 1: t = Os(null, t, r, e, n); break e; case 11: t = _s(null, t, r, e, n); break e; case 14: t = ks(null, t, r, bo(r.type, e), n); break e }throw Error(o(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, Ms(e, t, r, i = t.elementType === r ? i : bo(r, i), n); case 1: return r = t.type, i = t.pendingProps, Os(e, t, r, i = t.elementType === r ? i : bo(r, i), n); case 3: e: { if (Ns(t), null === e) throw Error(o(387)); r = t.pendingProps, i = (a = t.memoizedState).element, Do(e, t), Io(t, r, null, n); var s = t.memoizedState; if (r = s.element, a.isDehydrated) { if (a = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = a, t.memoizedState = a, 256 & t.flags) { t = Ts(e, t, r, n, i = us(Error(o(423)), t)); break e } if (r !== i) { t = Ts(e, t, r, n, i = us(Error(o(424)), t)); break e } for (ro = ci(t.stateNode.containerInfo.firstChild), no = t, io = !0, oo = null, n = Jo(t, null, r, n), t.child = n; n;)n.flags = -3 & n.flags | 4096, n = n.sibling } else { if (po(), r === i) { t = $s(e, t, n); break e } ws(e, t, r, n) } t = t.child } return t; case 5: return aa(t), null === e && co(t), r = t.type, i = t.pendingProps, a = null !== e ? e.memoizedProps : null, s = i.children, ni(r, i) ? s = null : null !== a && ni(r, a) && (t.flags |= 32), Es(e, t), ws(e, t, s, n), t.child; case 6: return null === e && co(t), null; case 13: return Is(e, t, n); case 4: return ia(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = Go(t, null, r, n) : ws(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, _s(e, t, r, i = t.elementType === r ? i : bo(r, i), n); case 7: return ws(e, t, t.pendingProps, n), t.child; case 8: case 12: return ws(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, a = t.memoizedProps, s = i.value, Ei(vo, r._currentValue), r._currentValue = s, null !== a) if (sr(a.value, s)) { if (a.children === i.children && !Pi.current) { t = $s(e, t, n); break e } } else for (null !== (a = t.child) && (a.return = t); null !== a;) { var l = a.dependencies; if (null !== l) { s = a.child; for (var c = l.firstContext; null !== c;) { if (c.context === r) { if (1 === a.tag) { (c = Ro(-1, n & -n)).tag = 2; var u = a.updateQueue; if (null !== u) { var d = (u = u.shared).pending; null === d ? c.next = c : (c.next = d.next, d.next = c), u.pending = c } } a.lanes |= n, null !== (c = a.alternate) && (c.lanes |= n), So(a.return, n, t), l.lanes |= n; break } c = c.next } } else if (10 === a.tag) s = a.type === t.type ? null : a.child; else if (18 === a.tag) { if (null === (s = a.return)) throw Error(o(341)); s.lanes |= n, null !== (l = s.alternate) && (l.lanes |= n), So(s, n, t), s = a.sibling } else s = a.child; if (null !== s) s.return = a; else for (s = a; null !== s;) { if (s === t) { s = null; break } if (null !== (a = s.sibling)) { a.return = s.return, s = a; break } s = s.return } a = s } ws(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, Co(t, n), r = r(i = Eo(i)), t.flags |= 1, ws(e, t, r, n), t.child; case 14: return i = bo(r = t.type, t.pendingProps), ks(e, t, r, i = bo(r.type, i), n); case 15: return Ss(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : bo(r, i), Us(e, t), t.tag = 1, ji(r) ? (e = !0, Ai(t)) : e = !1, Co(t, n), Uo(t, r, i), Yo(t, r, i, n), Ps(null, t, r, !0, e, n); case 19: return Hs(e, t, n); case 22: return Cs(e, t, n) }throw Error(o(156, t.tag)) }; var Kc = "function" === typeof reportError ? reportError : function (e) { console.error(e) }; function Qc(e) { this._internalRoot = e } function Xc(e) { this._internalRoot = e } function Gc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType) } function Jc(e) { return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue)) } function Zc() { } function eu(e, t, n, r, i) { var o = n._reactRootContainer; if (o) { var a = o; if ("function" === typeof i) { var s = i; i = function () { var e = $c(a); s.call(e) } } Uc(t, a, e, i) } else a = function (e, t, n, r, i) { if (i) { if ("function" === typeof r) { var o = r; r = function () { var e = $c(a); o.call(e) } } var a = Hc(t, r, e, 0, null, !1, 0, "", Zc); return e._reactRootContainer = a, e[pi] = a.current, Vr(8 === e.nodeType ? e.parentNode : e), dc(), a } for (; i = e.lastChild;)e.removeChild(i); if ("function" === typeof r) { var s = r; r = function () { var e = $c(l); s.call(e) } } var l = Wc(e, 0, !1, null, 0, !1, 0, "", Zc); return e._reactRootContainer = l, e[pi] = l.current, Vr(8 === e.nodeType ? e.parentNode : e), dc((function () { Uc(t, l, n, r) })), l }(n, t, e, i, r); return $c(a) } Xc.prototype.render = Qc.prototype.render = function (e) { var t = this._internalRoot; if (null === t) throw Error(o(409)); Uc(e, t, null, null) }, Xc.prototype.unmount = Qc.prototype.unmount = function () { var e = this._internalRoot; if (null !== e) { this._internalRoot = null; var t = e.containerInfo; dc((function () { Uc(null, e, null, null) })), t[pi] = null } }, Xc.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = St(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Dt.length && 0 !== t && t < Dt[n].priority; n++); Dt.splice(n, 0, e), 0 === n && zt(e) } }, wt = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = dt(t.pendingLanes); 0 !== n && (vt(t, 1 | n), ic(t, Ge()), 0 === (6 & Pl) && (Hl = Ge() + 500, Vi())) } break; case 13: dc((function () { var t = No(e, 1); if (null !== t) { var n = tc(); rc(t, e, 1, n) } })), qc(e, 1) } }, _t = function (e) { if (13 === e.tag) { var t = No(e, 134217728); if (null !== t) rc(t, e, 134217728, tc()); qc(e, 134217728) } }, kt = function (e) { if (13 === e.tag) { var t = nc(e), n = No(e, t); if (null !== n) rc(n, e, t, tc()); qc(e, t) } }, St = function () { return yt }, Ct = function (e, t) { var n = yt; try { return yt = e, t() } finally { yt = n } }, _e = function (e, t, n) { switch (t) { case "input": if (J(e, n), t = n.name, "radio" === n.type && null != t) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = wi(r); if (!i) throw Error(o(90)); q(r), J(r, i) } } } break; case "textarea": oe(e, n); break; case "select": null != (t = n.value) && ne(e, !!n.multiple, t, !1) } }, Oe = uc, Pe = dc; var tu = { usingClientEntryPoint: !1, Events: [yi, xi, wi, Ee, Me, uc] }, nu = { findFiberByHostInstance: vi, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, ru = { bundleType: nu.bundleType, version: nu.version, rendererPackageName: nu.rendererPackageName, rendererConfig: nu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: x.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return null === (e = $e(e)) ? null : e.stateNode }, findFiberByHostInstance: nu.findFiberByHostInstance || function () { return null }, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) { var iu = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!iu.isDisabled && iu.supportsFiber) try { it = iu.inject(ru), ot = iu } catch (ue) { } } t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu, t.createPortal = function (e, t) { var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null; if (!Gc(t)) throw Error(o(200)); return function (e, t, n) { var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null; return { $$typeof: _, key: null == r ? null : "" + r, children: e, containerInfo: t, implementation: n } }(e, t, null, n) }, t.createRoot = function (e, t) { if (!Gc(e)) throw Error(o(299)); var n = !1, r = "", i = Kc; return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Wc(e, 1, !1, null, 0, n, 0, r, i), e[pi] = t.current, Vr(8 === e.nodeType ? e.parentNode : e), new Qc(t) }, t.findDOMNode = function (e) { if (null == e) return null; if (1 === e.nodeType) return e; var t = e._reactInternals; if (void 0 === t) { if ("function" === typeof e.render) throw Error(o(188)); throw e = Object.keys(e).join(","), Error(o(268, e)) } return e = null === (e = $e(t)) ? null : e.stateNode }, t.flushSync = function (e) { return dc(e) }, t.hydrate = function (e, t, n) { if (!Jc(t)) throw Error(o(200)); return eu(null, e, t, !0, n) }, t.hydrateRoot = function (e, t, n) { if (!Gc(e)) throw Error(o(405)); var r = null != n && n.hydratedSources || null, i = !1, a = "", s = Kc; if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (a = n.identifierPrefix), void 0 !== n.onRecoverableError && (s = n.onRecoverableError)), t = Hc(t, null, e, 1, null != n ? n : null, i, 0, a, s), e[pi] = t.current, Vr(e), r) for (e = 0; e < r.length; e++)i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Xc(t) }, t.render = function (e, t, n) { if (!Jc(t)) throw Error(o(200)); return eu(null, e, t, !1, n) }, t.unmountComponentAtNode = function (e) { if (!Jc(e)) throw Error(o(40)); return !!e._reactRootContainer && (dc((function () { eu(null, null, e, !1, (function () { e._reactRootContainer = null, e[pi] = null })) })), !0) }, t.unstable_batchedUpdates = uc, t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Jc(n)) throw Error(o(200)); if (null == e || void 0 === e._reactInternals) throw Error(o(38)); return eu(e, t, n, !1, r) }, t.version = "18.2.0-next-9e3b772b8-20220608" }, 250: (e, t, n) => { "use strict"; var r = n(164); t.createRoot = r.createRoot, t.hydrateRoot = r.hydrateRoot }, 164: (e, t, n) => { "use strict"; !function e() { if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } }(), e.exports = n(463) }, 374: (e, t, n) => { "use strict"; var r = n(791), i = Symbol.for("react.element"), o = Symbol.for("react.fragment"), a = Object.prototype.hasOwnProperty, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, l = { key: !0, ref: !0, __self: !0, __source: !0 }; function c(e, t, n) { var r, o = {}, c = null, u = null; for (r in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (u = t.ref), t) a.call(t, r) && !l.hasOwnProperty(r) && (o[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === o[r] && (o[r] = t[r]); return { $$typeof: i, type: e, key: c, ref: u, props: o, _owner: s.current } } t.Fragment = o, t.jsx = c, t.jsxs = c }, 117: (e, t) => { "use strict"; var n = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.iterator; var p = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, g = Object.assign, m = {}; function b(e, t, n) { this.props = e, this.context = t, this.refs = m, this.updater = n || p } function v() { } function y(e, t, n) { this.props = e, this.context = t, this.refs = m, this.updater = n || p } b.prototype.isReactComponent = {}, b.prototype.setState = function (e, t) { if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }, b.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }, v.prototype = b.prototype; var x = y.prototype = new v; x.constructor = y, g(x, b.prototype), x.isPureReactComponent = !0; var w = Array.isArray, _ = Object.prototype.hasOwnProperty, k = { current: null }, S = { key: !0, ref: !0, __self: !0, __source: !0 }; function C(e, t, r) { var i, o = {}, a = null, s = null; if (null != t) for (i in void 0 !== t.ref && (s = t.ref), void 0 !== t.key && (a = "" + t.key), t) _.call(t, i) && !S.hasOwnProperty(i) && (o[i] = t[i]); var l = arguments.length - 2; if (1 === l) o.children = r; else if (1 < l) { for (var c = Array(l), u = 0; u < l; u++)c[u] = arguments[u + 2]; o.children = c } if (e && e.defaultProps) for (i in l = e.defaultProps) void 0 === o[i] && (o[i] = l[i]); return { $$typeof: n, type: e, key: a, ref: s, props: o, _owner: k.current } } function E(e) { return "object" === typeof e && null !== e && e.$$typeof === n } var M = /\/+/g; function O(e, t) { return "object" === typeof e && null !== e && null != e.key ? function (e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, (function (e) { return t[e] })) }("" + e.key) : t.toString(36) } function P(e, t, i, o, a) { var s = typeof e; "undefined" !== s && "boolean" !== s || (e = null); var l = !1; if (null === e) l = !0; else switch (s) { case "string": case "number": l = !0; break; case "object": switch (e.$$typeof) { case n: case r: l = !0 } }if (l) return a = a(l = e), e = "" === o ? "." + O(l, 0) : o, w(a) ? (i = "", null != e && (i = e.replace(M, "$&/") + "/"), P(a, t, i, "", (function (e) { return e }))) : null != a && (E(a) && (a = function (e, t) { return { $$typeof: n, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } }(a, i + (!a.key || l && l.key === a.key ? "" : ("" + a.key).replace(M, "$&/") + "/") + e)), t.push(a)), 1; if (l = 0, o = "" === o ? "." : o + ":", w(e)) for (var c = 0; c < e.length; c++) { var u = o + O(s = e[c], c); l += P(s, t, i, u, a) } else if (u = function (e) { return null === e || "object" !== typeof e ? null : "function" === typeof (e = f && e[f] || e["@@iterator"]) ? e : null }(e), "function" === typeof u) for (e = u.call(e), c = 0; !(s = e.next()).done;)l += P(s = s.value, t, i, u = o + O(s, c++), a); else if ("object" === s) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return l } function N(e, t, n) { if (null == e) return e; var r = [], i = 0; return P(e, r, "", "", (function (e) { return t.call(n, e, i++) })), r } function T(e) { if (-1 === e._status) { var t = e._result; (t = t()).then((function (t) { 0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t) }), (function (t) { 0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t) })), -1 === e._status && (e._status = 0, e._result = t) } if (1 === e._status) return e._result.default; throw e._result } var j = { current: null }, D = { transition: null }, R = { ReactCurrentDispatcher: j, ReactCurrentBatchConfig: D, ReactCurrentOwner: k }; t.Children = { map: N, forEach: function (e, t, n) { N(e, (function () { t.apply(this, arguments) }), n) }, count: function (e) { var t = 0; return N(e, (function () { t++ })), t }, toArray: function (e) { return N(e, (function (e) { return e })) || [] }, only: function (e) { if (!E(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }, t.Component = b, t.Fragment = i, t.Profiler = a, t.PureComponent = y, t.StrictMode = o, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = R, t.cloneElement = function (e, t, r) { if (null === e || void 0 === e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var i = g({}, e.props), o = e.key, a = e.ref, s = e._owner; if (null != t) { if (void 0 !== t.ref && (a = t.ref, s = k.current), void 0 !== t.key && (o = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps; for (c in t) _.call(t, c) && !S.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== l ? l[c] : t[c]) } var c = arguments.length - 2; if (1 === c) i.children = r; else if (1 < c) { l = Array(c); for (var u = 0; u < c; u++)l[u] = arguments[u + 2]; i.children = l } return { $$typeof: n, type: e.type, key: o, ref: a, props: i, _owner: s } }, t.createContext = function (e) { return (e = { $$typeof: l, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }).Provider = { $$typeof: s, _context: e }, e.Consumer = e }, t.createElement = C, t.createFactory = function (e) { var t = C.bind(null, e); return t.type = e, t }, t.createRef = function () { return { current: null } }, t.forwardRef = function (e) { return { $$typeof: c, render: e } }, t.isValidElement = E, t.lazy = function (e) { return { $$typeof: h, _payload: { _status: -1, _result: e }, _init: T } }, t.memo = function (e, t) { return { $$typeof: d, type: e, compare: void 0 === t ? null : t } }, t.startTransition = function (e) { var t = D.transition; D.transition = {}; try { e() } finally { D.transition = t } }, t.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }, t.useCallback = function (e, t) { return j.current.useCallback(e, t) }, t.useContext = function (e) { return j.current.useContext(e) }, t.useDebugValue = function () { }, t.useDeferredValue = function (e) { return j.current.useDeferredValue(e) }, t.useEffect = function (e, t) { return j.current.useEffect(e, t) }, t.useId = function () { return j.current.useId() }, t.useImperativeHandle = function (e, t, n) { return j.current.useImperativeHandle(e, t, n) }, t.useInsertionEffect = function (e, t) { return j.current.useInsertionEffect(e, t) }, t.useLayoutEffect = function (e, t) { return j.current.useLayoutEffect(e, t) }, t.useMemo = function (e, t) { return j.current.useMemo(e, t) }, t.useReducer = function (e, t, n) { return j.current.useReducer(e, t, n) }, t.useRef = function (e) { return j.current.useRef(e) }, t.useState = function (e) { return j.current.useState(e) }, t.useSyncExternalStore = function (e, t, n) { return j.current.useSyncExternalStore(e, t, n) }, t.useTransition = function () { return j.current.useTransition() }, t.version = "18.2.0" }, 791: (e, t, n) => { "use strict"; e.exports = n(117) }, 184: (e, t, n) => { "use strict"; e.exports = n(374) }, 813: (e, t) => { "use strict"; function n(e, t) { var n = e.length; e.push(t); e: for (; 0 < n;) { var r = n - 1 >>> 1, i = e[r]; if (!(0 < o(i, t))) break e; e[r] = t, e[n] = i, n = r } } function r(e) { return 0 === e.length ? null : e[0] } function i(e) { if (0 === e.length) return null; var t = e[0], n = e.pop(); if (n !== t) { e[0] = n; e: for (var r = 0, i = e.length, a = i >>> 1; r < a;) { var s = 2 * (r + 1) - 1, l = e[s], c = s + 1, u = e[c]; if (0 > o(l, n)) c < i && 0 > o(u, l) ? (e[r] = u, e[c] = n, r = c) : (e[r] = l, e[s] = n, r = s); else { if (!(c < i && 0 > o(u, n))) break e; e[r] = u, e[c] = n, r = c } } } return t } function o(e, t) { var n = e.sortIndex - t.sortIndex; return 0 !== n ? n : e.id - t.id } if ("object" === typeof performance && "function" === typeof performance.now) { var a = performance; t.unstable_now = function () { return a.now() } } else { var s = Date, l = s.now(); t.unstable_now = function () { return s.now() - l } } var c = [], u = [], d = 1, h = null, f = 3, p = !1, g = !1, m = !1, b = "function" === typeof setTimeout ? setTimeout : null, v = "function" === typeof clearTimeout ? clearTimeout : null, y = "undefined" !== typeof setImmediate ? setImmediate : null; function x(e) { for (var t = r(u); null !== t;) { if (null === t.callback) i(u); else { if (!(t.startTime <= e)) break; i(u), t.sortIndex = t.expirationTime, n(c, t) } t = r(u) } } function w(e) { if (m = !1, x(e), !g) if (null !== r(c)) g = !0, D(_); else { var t = r(u); null !== t && R(w, t.startTime - e) } } function _(e, n) { g = !1, m && (m = !1, v(E), E = -1), p = !0; var o = f; try { for (x(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !P());) { var a = h.callback; if ("function" === typeof a) { h.callback = null, f = h.priorityLevel; var s = a(h.expirationTime <= n); n = t.unstable_now(), "function" === typeof s ? h.callback = s : h === r(c) && i(c), x(n) } else i(c); h = r(c) } if (null !== h) var l = !0; else { var d = r(u); null !== d && R(w, d.startTime - n), l = !1 } return l } finally { h = null, f = o, p = !1 } } "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling); var k, S = !1, C = null, E = -1, M = 5, O = -1; function P() { return !(t.unstable_now() - O < M) } function N() { if (null !== C) { var e = t.unstable_now(); O = e; var n = !0; try { n = C(!0, e) } finally { n ? k() : (S = !1, C = null) } } else S = !1 } if ("function" === typeof y) k = function () { y(N) }; else if ("undefined" !== typeof MessageChannel) { var T = new MessageChannel, j = T.port2; T.port1.onmessage = N, k = function () { j.postMessage(null) } } else k = function () { b(N, 0) }; function D(e) { C = e, S || (S = !0, k()) } function R(e, n) { E = b((function () { e(t.unstable_now()) }), n) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (e) { e.callback = null }, t.unstable_continueExecution = function () { g || p || (g = !0, D(_)) }, t.unstable_forceFrameRate = function (e) { 0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : M = 0 < e ? Math.floor(1e3 / e) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return f }, t.unstable_getFirstCallbackNode = function () { return r(c) }, t.unstable_next = function (e) { switch (f) { case 1: case 2: case 3: var t = 3; break; default: t = f }var n = f; f = t; try { return e() } finally { f = n } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (e, t) { switch (e) { case 1: case 2: case 3: case 4: case 5: break; default: e = 3 }var n = f; f = e; try { return t() } finally { f = n } }, t.unstable_scheduleCallback = function (e, i, o) { var a = t.unstable_now(); switch ("object" === typeof o && null !== o ? o = "number" === typeof (o = o.delay) && 0 < o ? a + o : a : o = a, e) { case 1: var s = -1; break; case 2: s = 250; break; case 5: s = 1073741823; break; case 4: s = 1e4; break; default: s = 5e3 }return e = { id: d++, callback: i, priorityLevel: e, startTime: o, expirationTime: s = o + s, sortIndex: -1 }, o > a ? (e.sortIndex = o, n(u, e), null === r(c) && e === r(u) && (m ? (v(E), E = -1) : m = !0, R(w, o - a))) : (e.sortIndex = s, n(c, e), g || p || (g = !0, D(_))), e }, t.unstable_shouldYield = P, t.unstable_wrapCallback = function (e) { var t = f; return function () { var n = f; f = t; try { return e.apply(this, arguments) } finally { f = n } } } }, 296: (e, t, n) => { "use strict"; e.exports = n(813) }, 391: e => { "use strict"; var t = function () { }; e.exports = t } }, t = {}; function n(r) { var i = t[r]; if (void 0 !== i) return i.exports; var o = t[r] = { exports: {} }; return e[r](o, o.exports, n), o.exports } n.m = e, n.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return n.d(t, { a: t }), t }, (() => { var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__; n.t = function (r, i) { if (1 & i && (r = this(r)), 8 & i) return r; if ("object" === typeof r && r) { if (4 & i && r.__esModule) return r; if (16 & i && "function" === typeof r.then) return r } var o = Object.create(null); n.r(o); var a = {}; e = e || [null, t({}), t([]), t(t)]; for (var s = 2 & i && r; "object" == typeof s && !~e.indexOf(s); s = t(s))Object.getOwnPropertyNames(s).forEach((e => a[e] = () => r[e])); return a.default = () => r, n.d(o, a), o } })(), n.d = (e, t) => { for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }) }, n.f = {}, n.e = e => Promise.all(Object.keys(n.f).reduce(((t, r) => (n.f[r](e, t), t)), [])), n.u = e => "static/js/" + e + ".01bef41c.chunk.js", n.miniCssF = e => { }, n.g = function () { if ("object" === typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (e) { if ("object" === typeof window) return window } }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => { var e = {}, t = "ut-grade-dist-plus:"; n.l = (r, i, o, a) => { if (e[r]) e[r].push(i); else { var s, l; if (void 0 !== o) for (var c = document.getElementsByTagName("script"), u = 0; u < c.length; u++) { var d = c[u]; if (d.getAttribute("src") == r || d.getAttribute("data-webpack") == t + o) { s = d; break } } s || (l = !0, (s = document.createElement("script")).charset = "utf-8", s.timeout = 120, n.nc && s.setAttribute("nonce", n.nc), s.setAttribute("data-webpack", t + o), s.src = r), e[r] = [i]; var h = (t, n) => { s.onerror = s.onload = null, clearTimeout(f); var i = e[r]; if (delete e[r], s.parentNode && s.parentNode.removeChild(s), i && i.forEach((e => e(n))), t) return t(n) }, f = setTimeout(h.bind(null, void 0, { type: "timeout", target: s }), 12e4); s.onerror = h.bind(null, s.onerror), s.onload = h.bind(null, s.onload), l && document.head.appendChild(s) } } })(), n.r = e => { "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.p = "/", (() => { var e = { 179: 0 }; n.f.j = (t, r) => { var i = n.o(e, t) ? e[t] : void 0; if (0 !== i) if (i) r.push(i[2]); else { var o = new Promise(((n, r) => i = e[t] = [n, r])); r.push(i[2] = o); var a = n.p + n.u(t), s = new Error; n.l(a, (r => { if (n.o(e, t) && (0 !== (i = e[t]) && (e[t] = void 0), i)) { var o = r && ("load" === r.type ? "missing" : r.type), a = r && r.target && r.target.src; s.message = "Loading chunk " + t + " failed.\n(" + o + ": " + a + ")", s.name = "ChunkLoadError", s.type = o, s.request = a, i[1](s) } }), "chunk-" + t, t) } }; var t = (t, r) => { var i, o, a = r[0], s = r[1], l = r[2], c = 0; if (a.some((t => 0 !== e[t]))) { for (i in s) n.o(s, i) && (n.m[i] = s[i]); if (l) l(n) } for (t && t(r); c < a.length; c++)o = a[c], n.o(e, o) && e[o] && e[o][0](), e[o] = 0 }, r = self.webpackChunkut_grade_dist_plus = self.webpackChunkut_grade_dist_plus || []; r.forEach(t.bind(null, 0)), r.push = t.bind(null, r.push.bind(r)) })(), (() => { "use strict"; var e = n(791), t = n.t(e, 2), r = n(250), i = n(694), o = n.n(i), a = n(184); const s = ["xxl", "xl", "lg", "md", "sm", "xs"], l = "xs", c = e.createContext({ prefixes: {}, breakpoints: s, minBreakpoint: l }), { Consumer: u, Provider: d } = c; function h(t, n) { const { prefixes: r } = (0, e.useContext)(c); return t || r[n] || n } function f() { const { breakpoints: t } = (0, e.useContext)(c); return t } function p() { const { minBreakpoint: t } = (0, e.useContext)(c); return t } function g() { const { dir: t } = (0, e.useContext)(c); return "rtl" === t } const m = e.forwardRef(((e, t) => { let { bsPrefix: n, fluid: r = !1, as: i = "div", className: s, ...l } = e; const c = h(n, "container"), u = "string" === typeof r ? "-".concat(r) : "-fluid"; return (0, a.jsx)(i, { ref: t, ...l, className: o()(s, r ? "".concat(c).concat(u) : c) }) })); m.displayName = "Container"; const b = m; var v = n(7), y = n.n(v); const x = { type: y().string, tooltip: y().bool, as: y().elementType }, w = e.forwardRef(((e, t) => { let { as: n = "div", className: r, type: i = "valid", tooltip: s = !1, ...l } = e; return (0, a.jsx)(n, { ...l, ref: t, className: o()(r, "".concat(i, "-").concat(s ? "tooltip" : "feedback")) }) })); w.displayName = "Feedback", w.propTypes = x; const _ = w, k = e.createContext({}), S = e.forwardRef(((t, n) => { let { id: r, bsPrefix: i, className: s, type: l = "checkbox", isValid: c = !1, isInvalid: u = !1, as: d = "input", ...f } = t; const { controlId: p } = (0, e.useContext)(k); return i = h(i, "form-check-input"), (0, a.jsx)(d, { ...f, ref: n, type: l, id: r || p, className: o()(s, i, c && "is-valid", u && "is-invalid") }) })); S.displayName = "FormCheckInput"; const C = S, E = e.forwardRef(((t, n) => { let { bsPrefix: r, className: i, htmlFor: s, ...l } = t; const { controlId: c } = (0, e.useContext)(k); return r = h(r, "form-check-label"), (0, a.jsx)("label", { ...l, ref: n, htmlFor: s || c, className: o()(i, r) }) })); E.displayName = "FormCheckLabel"; const M = E; const O = e.forwardRef(((t, n) => { let { id: r, bsPrefix: i, bsSwitchPrefix: s, inline: l = !1, reverse: c = !1, disabled: u = !1, isValid: d = !1, isInvalid: f = !1, feedbackTooltip: p = !1, feedback: g, feedbackType: m, className: b, style: v, title: y = "", type: x = "checkbox", label: w, children: S, as: E = "input", ...O } = t; i = h(i, "form-check"), s = h(s, "form-switch"); const { controlId: P } = (0, e.useContext)(k), N = (0, e.useMemo)((() => ({ controlId: r || P })), [P, r]), T = !S && null != w && !1 !== w || function (t, n) { return e.Children.toArray(t).some((t => e.isValidElement(t) && t.type === n)) }(S, M), j = (0, a.jsx)(C, { ...O, type: "switch" === x ? "checkbox" : x, ref: n, isValid: d, isInvalid: f, disabled: u, as: E }); return (0, a.jsx)(k.Provider, { value: N, children: (0, a.jsx)("div", { style: v, className: o()(b, T && i, l && "".concat(i, "-inline"), c && "".concat(i, "-reverse"), "switch" === x && s), children: S || (0, a.jsxs)(a.Fragment, { children: [j, T && (0, a.jsx)(M, { title: y, children: w }), g && (0, a.jsx)(_, { type: m, tooltip: p, children: g })] }) }) }) })); O.displayName = "FormCheck"; const P = Object.assign(O, { Input: C, Label: M }); var N = n(391), T = n.n(N); const j = e.forwardRef(((t, n) => { let { bsPrefix: r, type: i, size: s, htmlSize: l, id: c, className: u, isValid: d = !1, isInvalid: f = !1, plaintext: p, readOnly: g, as: m = "input", ...b } = t; const { controlId: v } = (0, e.useContext)(k); return r = h(r, "form-control"), (0, a.jsx)(m, { ...b, type: i, size: l, ref: n, readOnly: g, id: c || v, className: o()(u, p ? "".concat(r, "-plaintext") : r, s && "".concat(r, "-").concat(s), "color" === i && "".concat(r, "-color"), d && "is-valid", f && "is-invalid") }) })); j.displayName = "FormControl"; const D = Object.assign(j, { Feedback: _ }), R = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = h(r, "form-floating"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); R.displayName = "FormFloating"; const L = R, A = e.forwardRef(((t, n) => { let { controlId: r, as: i = "div", ...o } = t; const s = (0, e.useMemo)((() => ({ controlId: r })), [r]); return (0, a.jsx)(k.Provider, { value: s, children: (0, a.jsx)(i, { ...o, ref: n }) }) })); A.displayName = "FormGroup"; const z = A; const I = e.forwardRef(((e, t) => { const [{ className: n, ...r }, { as: i = "div", bsPrefix: s, spans: l }] = function (e) { let { as: t, bsPrefix: n, className: r, ...i } = e; n = h(n, "col"); const a = f(), s = p(), l = [], c = []; return a.forEach((e => { const t = i[e]; let r, o, a; delete i[e], "object" === typeof t && null != t ? ({ span: r, offset: o, order: a } = t) : r = t; const u = e !== s ? "-".concat(e) : ""; r && l.push(!0 === r ? "".concat(n).concat(u) : "".concat(n).concat(u, "-").concat(r)), null != a && c.push("order".concat(u, "-").concat(a)), null != o && c.push("offset".concat(u, "-").concat(o)) })), [{ ...i, className: o()(r, ...l, ...c) }, { as: t, bsPrefix: n, spans: l }] }(e); return (0, a.jsx)(i, { ...r, ref: t, className: o()(n, !l.length && s) }) })); I.displayName = "Col"; const F = I, B = e.forwardRef(((t, n) => { let { as: r = "label", bsPrefix: i, column: s = !1, visuallyHidden: l = !1, className: c, htmlFor: u, ...d } = t; const { controlId: f } = (0, e.useContext)(k); i = h(i, "form-label"); let p = "col-form-label"; "string" === typeof s && (p = "".concat(p, " ").concat(p, "-").concat(s)); const g = o()(c, i, l && "visually-hidden", s && p); return u = u || f, s ? (0, a.jsx)(F, { ref: n, as: "label", className: g, htmlFor: u, ...d }) : (0, a.jsx)(r, { ref: n, className: g, htmlFor: u, ...d }) })); B.displayName = "FormLabel"; const W = B, V = e.forwardRef(((t, n) => { let { bsPrefix: r, className: i, id: s, ...l } = t; const { controlId: c } = (0, e.useContext)(k); return r = h(r, "form-range"), (0, a.jsx)("input", { ...l, type: "range", ref: n, className: o()(i, r), id: s || c }) })); V.displayName = "FormRange"; const H = V, U = e.forwardRef(((t, n) => { let { bsPrefix: r, size: i, htmlSize: s, className: l, isValid: c = !1, isInvalid: u = !1, id: d, ...f } = t; const { controlId: p } = (0, e.useContext)(k); return r = h(r, "form-select"), (0, a.jsx)("select", { ...f, size: s, ref: n, className: o()(l, r, i && "".concat(r, "-").concat(i), c && "is-valid", u && "is-invalid"), id: d || p }) })); U.displayName = "FormSelect"; const $ = U, Y = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, as: i = "small", muted: s, ...l } = e; return n = h(n, "form-text"), (0, a.jsx)(i, { ...l, ref: t, className: o()(r, n, s && "text-muted") }) })); Y.displayName = "FormText"; const q = Y, K = e.forwardRef(((e, t) => (0, a.jsx)(P, { ...e, ref: t, type: "switch" }))); K.displayName = "Switch"; const Q = Object.assign(K, { Input: P.Input, Label: P.Label }), X = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, children: i, controlId: s, label: l, ...c } = e; return n = h(n, "form-floating"), (0, a.jsxs)(z, { ref: t, className: o()(r, n), controlId: s, ...c, children: [i, (0, a.jsx)("label", { htmlFor: s, children: l })] }) })); X.displayName = "FloatingLabel"; const G = X, J = { _ref: y().any, validated: y().bool, as: y().elementType }, Z = e.forwardRef(((e, t) => { let { className: n, validated: r, as: i = "form", ...s } = e; return (0, a.jsx)(i, { ...s, ref: t, className: o()(n, r && "was-validated") }) })); Z.displayName = "Form", Z.propTypes = J; const ee = Object.assign(Z, { Group: z, Control: D, Floating: L, Check: P, Switch: Q, Label: W, Text: q, Range: H, Select: $, FloatingLabel: G }), te = ["as", "disabled"]; function ne(e) { let { tagName: t, disabled: n, href: r, target: i, rel: o, role: a, onClick: s, tabIndex: l = 0, type: c } = e; t || (t = null != r || null != i || null != o ? "a" : "button"); const u = { tagName: t }; if ("button" === t) return [{ type: c || "button", disabled: n }, u]; const d = e => { (n || "a" === t && function (e) { return !e || "#" === e.trim() }(r)) && e.preventDefault(), n ? e.stopPropagation() : null == s || s(e) }; return "a" === t && (r || (r = "#"), n && (r = void 0)), [{ role: null != a ? a : "button", disabled: void 0, tabIndex: n ? void 0 : l, href: r, target: "a" === t ? i : void 0, "aria-disabled": n || void 0, rel: "a" === t ? o : void 0, onClick: d, onKeyDown: e => { " " === e.key && (e.preventDefault(), d(e)) } }, u] } const re = e.forwardRef(((e, t) => { let { as: n, disabled: r } = e, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, te); const [o, { tagName: s }] = ne(Object.assign({ tagName: n, disabled: r }, i)); return (0, a.jsx)(s, Object.assign({}, i, o, { ref: t })) })); re.displayName = "Button"; const ie = re, oe = e.forwardRef(((e, t) => { let { as: n, bsPrefix: r, variant: i = "primary", size: s, active: l = !1, disabled: c = !1, className: u, ...d } = e; const f = h(r, "btn"), [p, { tagName: g }] = ne({ tagName: n, disabled: c, ...d }), m = g; return (0, a.jsx)(m, { ...p, ...d, ref: t, disabled: c, className: o()(u, f, l && "active", i && "".concat(f, "-").concat(i), s && "".concat(f, "-").concat(s), d.href && c && "disabled") }) })); oe.displayName = "Button"; const ae = oe; var se = ["color", "size", "title"]; function le() { return le = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, le.apply(this, arguments) } function ce(e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } var ue = (0, e.forwardRef)((function (t, n) { var r = t.color, i = t.size, o = t.title, a = ce(t, se); return e.createElement("svg", le({ ref: n, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16", width: i, height: i, fill: r }, a), o ? e.createElement("title", null, o) : null, e.createElement("path", { d: "M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z" })) })); ue.propTypes = { color: y().string, size: y().oneOfType([y().string, y().number]), title: y().string }, ue.defaultProps = { color: "currentColor", size: "1em", title: null }; const de = ue; var he = ["color", "size", "title"]; function fe() { return fe = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, fe.apply(this, arguments) } function pe(e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } var ge = (0, e.forwardRef)((function (t, n) { var r = t.color, i = t.size, o = t.title, a = pe(t, he); return e.createElement("svg", fe({ ref: n, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16", width: i, height: i, fill: r }, a), o ? e.createElement("title", null, o) : null, e.createElement("path", { fillRule: "evenodd", d: "M4.475 5.458c-.284 0-.514-.237-.47-.517C4.28 3.24 5.576 2 7.825 2c2.25 0 3.767 1.36 3.767 3.215 0 1.344-.665 2.288-1.79 2.973-1.1.659-1.414 1.118-1.414 2.01v.03a.5.5 0 0 1-.5.5h-.77a.5.5 0 0 1-.5-.495l-.003-.2c-.043-1.221.477-2.001 1.645-2.712 1.03-.632 1.397-1.135 1.397-2.028 0-.979-.758-1.698-1.926-1.698-1.009 0-1.71.529-1.938 1.402-.066.254-.278.461-.54.461h-.777ZM7.496 14c.622 0 1.095-.474 1.095-1.09 0-.618-.473-1.092-1.095-1.092-.606 0-1.087.474-1.087 1.091S6.89 14 7.496 14Z" })) })); ge.propTypes = { color: y().string, size: y().oneOfType([y().string, y().number]), title: y().string }, ge.defaultProps = { color: "currentColor", size: "1em", title: null }; const me = ge, be = !("undefined" === typeof window || !window.document || !window.document.createElement); var ve = !1, ye = !1; try { var xe = { get passive() { return ve = !0 }, get once() { return ye = ve = !0 } }; be && (window.addEventListener("test", xe, xe), window.removeEventListener("test", xe, !0)) } catch (Da) { } const we = function (e, t, n, r) { if (r && "boolean" !== typeof r && !ye) { var i = r.once, o = r.capture, a = n; !ye && i && (a = n.__once || function e(r) { this.removeEventListener(t, e, o), n.call(this, r) }, n.__once = a), e.addEventListener(t, a, ve ? r : o) } e.addEventListener(t, n, r) }; function _e(e) { return e && e.ownerDocument || document } const ke = function (e, t, n, r) { var i = r && "boolean" !== typeof r ? r.capture : r; e.removeEventListener(t, n, i), n.__once && e.removeEventListener(t, n.__once, i) }; var Se; function Ce(e) { if ((!Se && 0 !== Se || e) && be) { var t = document.createElement("div"); t.style.position = "absolute", t.style.top = "-9999px", t.style.width = "50px", t.style.height = "50px", t.style.overflow = "scroll", document.body.appendChild(t), Se = t.offsetWidth - t.clientWidth, document.body.removeChild(t) } return Se } function Ee() { return (0, e.useState)(null) } const Me = function (t) { const n = (0, e.useRef)(t); return (0, e.useEffect)((() => { n.current = t }), [t]), n }; function Oe(t) { const n = Me(t); return (0, e.useCallback)((function () { return n.current && n.current(...arguments) }), [n]) } const Pe = e => e && "function" !== typeof e ? t => { e.current = t } : e; const Ne = function (t, n) { return (0, e.useMemo)((() => function (e, t) { const n = Pe(e), r = Pe(t); return e => { n && n(e), r && r(e) } }(t, n)), [t, n]) }; function Te(t) { const n = function (t) { const n = (0, e.useRef)(t); return n.current = t, n }(t); (0, e.useEffect)((() => () => n.current()), []) } function je(e, t) { return function (e) { var t = _e(e); return t && t.defaultView || window }(e).getComputedStyle(e, t) } var De = /([A-Z])/g; var Re = /^ms-/; function Le(e) { return function (e) { return e.replace(De, "-$1").toLowerCase() }(e).replace(Re, "-ms-") } var Ae = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i; const ze = function (e, t) { var n = "", r = ""; if ("string" === typeof t) return e.style.getPropertyValue(Le(t)) || je(e).getPropertyValue(Le(t)); Object.keys(t).forEach((function (i) { var o = t[i]; o || 0 === o ? !function (e) { return !(!e || !Ae.test(e)) }(i) ? n += Le(i) + ": " + o + ";" : r += i + "(" + o + ") " : e.style.removeProperty(Le(i)) })), r && (n += "transform: " + r + ";"), e.style.cssText += ";" + n }; const Ie = function (e, t, n, r) { return we(e, t, n, r), function () { ke(e, t, n, r) } }; function Fe(e, t, n) { void 0 === n && (n = 5); var r = !1, i = setTimeout((function () { r || function (e, t, n, r) { if (void 0 === n && (n = !1), void 0 === r && (r = !0), e) { var i = document.createEvent("HTMLEvents"); i.initEvent(t, n, r), e.dispatchEvent(i) } }(e, "transitionend", !0) }), t + n), o = Ie(e, "transitionend", (function () { r = !0 }), { once: !0 }); return function () { clearTimeout(i), o() } } function Be(e, t, n, r) { null == n && (n = function (e) { var t = ze(e, "transitionDuration") || "", n = -1 === t.indexOf("ms") ? 1e3 : 1; return parseFloat(t) * n }(e) || 0); var i = Fe(e, n, r), o = Ie(e, "transitionend", t); return function () { i(), o() } } function We(e) { void 0 === e && (e = _e()); try { var t = e.activeElement; return t && t.nodeName ? t : null } catch (Da) { return e.body } } function Ve(e, t) { return e.contains ? e.contains(t) : e.compareDocumentPosition ? e === t || !!(16 & e.compareDocumentPosition(t)) : void 0 } var He = n(164), Ue = n.t(He, 2); function $e() { const t = (0, e.useRef)(!0), n = (0, e.useRef)((() => t.current)); return (0, e.useEffect)((() => (t.current = !0, () => { t.current = !1 })), []), n.current } const Ye = "data-rr-ui-"; function qe(e) { return "".concat(Ye).concat(e) } const Ke = qe("modal-open"); const Qe = class { constructor() { let { ownerDocument: e, handleContainerOverflow: t = !0, isRTL: n = !1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.handleContainerOverflow = t, this.isRTL = n, this.modals = [], this.ownerDocument = e } getScrollbarWidth() { return function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document; const t = e.defaultView; return Math.abs(t.innerWidth - e.documentElement.clientWidth) }(this.ownerDocument) } getElement() { return (this.ownerDocument || document).body } setModalAttributes(e) { } removeModalAttributes(e) { } setContainerStyle(e) { const t = { overflow: "hidden" }, n = this.isRTL ? "paddingLeft" : "paddingRight", r = this.getElement(); e.style = { overflow: r.style.overflow, [n]: r.style[n] }, e.scrollBarWidth && (t[n] = "".concat(parseInt(ze(r, n) || "0", 10) + e.scrollBarWidth, "px")), r.setAttribute(Ke, ""), ze(r, t) } reset() { [...this.modals].forEach((e => this.remove(e))) } removeContainerStyle(e) { const t = this.getElement(); t.removeAttribute(Ke), Object.assign(t.style, e.style) } add(e) { let t = this.modals.indexOf(e); return -1 !== t ? t : (t = this.modals.length, this.modals.push(e), this.setModalAttributes(e), 0 !== t || (this.state = { scrollBarWidth: this.getScrollbarWidth(), style: {} }, this.handleContainerOverflow && this.setContainerStyle(this.state)), t) } remove(e) { const t = this.modals.indexOf(e); -1 !== t && (this.modals.splice(t, 1), !this.modals.length && this.handleContainerOverflow && this.removeContainerStyle(this.state), this.removeModalAttributes(e)) } isTopModal(e) { return !!this.modals.length && this.modals[this.modals.length - 1] === e } }, Xe = (0, e.createContext)(be ? window : void 0); Xe.Provider; function Ge() { return (0, e.useContext)(Xe) } const Je = (e, t) => be ? null == e ? (t || _e()).body : ("function" === typeof e && (e = e()), e && "current" in e && (e = e.current), e && ("nodeType" in e || e.getBoundingClientRect) ? e : null) : null; function Ze(t, n) { const r = Ge(), [i, o] = (0, e.useState)((() => Je(t, null == r ? void 0 : r.document))); if (!i) { const e = Je(t); e && o(e) } return (0, e.useEffect)((() => { n && i && n(i) }), [n, i]), (0, e.useEffect)((() => { const e = Je(t); e !== i && o(e) }), [t, i]), i } const et = "undefined" !== typeof n.g && n.g.navigator && "ReactNative" === n.g.navigator.product, tt = "undefined" !== typeof document || et ? e.useLayoutEffect : e.useEffect; const nt = function (t) { let { children: n, in: r, onExited: i, mountOnEnter: o, unmountOnExit: a } = t; const s = (0, e.useRef)(null), l = (0, e.useRef)(r), c = Oe(i); (0, e.useEffect)((() => { r ? l.current = !0 : c(s.current) }), [r, c]); const u = Ne(s, n.ref), d = (0, e.cloneElement)(n, { ref: u }); return r ? d : a || !l.current && o ? null : d }; function rt(t) { let { children: n, in: r, onExited: i, onEntered: o, transition: a } = t; const [s, l] = (0, e.useState)(!r); r && s && l(!1); const c = function (t) { let { in: n, onTransition: r } = t; const i = (0, e.useRef)(null), o = (0, e.useRef)(!0), a = Oe(r); return tt((() => { if (!i.current) return; let e = !1; return a({ in: n, element: i.current, initial: o.current, isStale: () => e }), () => { e = !0 } }), [n, a]), tt((() => (o.current = !1, () => { o.current = !0 })), []), i }({ in: !!r, onTransition: e => { Promise.resolve(a(e)).then((() => { e.isStale() || (e.in ? null == o || o(e.element, e.initial) : (l(!0), null == i || i(e.element))) }), (t => { throw e.in || l(!0), t })) } }), u = Ne(c, n.ref); return s && !r ? null : (0, e.cloneElement)(n, { ref: u }) } function it(e, t, n) { return e ? (0, a.jsx)(e, Object.assign({}, n)) : t ? (0, a.jsx)(rt, Object.assign({}, n, { transition: t })) : (0, a.jsx)(nt, Object.assign({}, n)) } function ot(e) { return "Escape" === e.code || 27 === e.keyCode } const at = ["show", "role", "className", "style", "children", "backdrop", "keyboard", "onBackdropClick", "onEscapeKeyDown", "transition", "runTransition", "backdropTransition", "runBackdropTransition", "autoFocus", "enforceFocus", "restoreFocus", "restoreFocusOptions", "renderDialog", "renderBackdrop", "manager", "container", "onShow", "onHide", "onExit", "onExited", "onExiting", "onEnter", "onEntering", "onEntered"]; let st; function lt(t) { const n = Ge(), r = t || function (e) { return st || (st = new Qe({ ownerDocument: null == e ? void 0 : e.document })), st }(n), i = (0, e.useRef)({ dialog: null, backdrop: null }); return Object.assign(i.current, { add: () => r.add(i.current), remove: () => r.remove(i.current), isTopModal: () => r.isTopModal(i.current), setDialogRef: (0, e.useCallback)((e => { i.current.dialog = e }), []), setBackdropRef: (0, e.useCallback)((e => { i.current.backdrop = e }), []) }) } const ct = (0, e.forwardRef)(((t, n) => { let { show: r = !1, role: i = "dialog", className: o, style: s, children: l, backdrop: c = !0, keyboard: u = !0, onBackdropClick: d, onEscapeKeyDown: h, transition: f, runTransition: p, backdropTransition: g, runBackdropTransition: m, autoFocus: b = !0, enforceFocus: v = !0, restoreFocus: y = !0, restoreFocusOptions: x, renderDialog: w, renderBackdrop: _ = (e => (0, a.jsx)("div", Object.assign({}, e))), manager: k, container: S, onShow: C, onHide: E = (() => { }), onExit: M, onExited: O, onExiting: P, onEnter: N, onEntering: T, onEntered: j } = t, D = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(t, at); const R = Ge(), L = Ze(S), A = lt(k), z = $e(), I = function (t) { const n = (0, e.useRef)(null); return (0, e.useEffect)((() => { n.current = t })), n.current }(r), [F, B] = (0, e.useState)(!r), W = (0, e.useRef)(null); (0, e.useImperativeHandle)(n, (() => A), [A]), be && !I && r && (W.current = We(null == R ? void 0 : R.document)), r && F && B(!1); const V = Oe((() => { if (A.add(), K.current = Ie(document, "keydown", Y), q.current = Ie(document, "focus", (() => setTimeout(U)), !0), C && C(), b) { var e, t; const n = We(null != (e = null == (t = A.dialog) ? void 0 : t.ownerDocument) ? e : null == R ? void 0 : R.document); A.dialog && n && !Ve(A.dialog, n) && (W.current = n, A.dialog.focus()) } })), H = Oe((() => { var e; (A.remove(), null == K.current || K.current(), null == q.current || q.current(), y) && (null == (e = W.current) || null == e.focus || e.focus(x), W.current = null) })); (0, e.useEffect)((() => { r && L && V() }), [r, L, V]), (0, e.useEffect)((() => { F && H() }), [F, H]), Te((() => { H() })); const U = Oe((() => { if (!v || !z() || !A.isTopModal()) return; const e = We(null == R ? void 0 : R.document); A.dialog && e && !Ve(A.dialog, e) && A.dialog.focus() })), $ = Oe((e => { e.target === e.currentTarget && (null == d || d(e), !0 === c && E()) })), Y = Oe((e => { u && ot(e) && A.isTopModal() && (null == h || h(e), e.defaultPrevented || E()) })), q = (0, e.useRef)(), K = (0, e.useRef)(); if (!L) return null; const Q = Object.assign({ role: i, ref: A.setDialogRef, "aria-modal": "dialog" === i || void 0 }, D, { style: s, className: o, tabIndex: -1 }); let X = w ? w(Q) : (0, a.jsx)("div", Object.assign({}, Q, { children: e.cloneElement(l, { role: "document" }) })); X = it(f, p, { unmountOnExit: !0, mountOnEnter: !0, appear: !0, in: !!r, onExit: M, onExiting: P, onExited: function () { B(!0), null == O || O(...arguments) }, onEnter: N, onEntering: T, onEntered: j, children: X }); let G = null; return c && (G = _({ ref: A.setBackdropRef, onClick: $ }), G = it(g, m, { in: !!r, appear: !0, mountOnEnter: !0, unmountOnExit: !0, children: G })), (0, a.jsx)(a.Fragment, { children: He.createPortal((0, a.jsxs)(a.Fragment, { children: [G, X] }), L) }) })); ct.displayName = "Modal"; const ut = Object.assign(ct, { Manager: Qe }); function dt(e, t) { return e.classList ? !!t && e.classList.contains(t) : -1 !== (" " + (e.className.baseVal || e.className) + " ").indexOf(" " + t + " ") } var ht = Function.prototype.bind.call(Function.prototype.call, [].slice); function ft(e, t) { return ht(e.querySelectorAll(t)) } function pt(e, t) { return e.replace(new RegExp("(^|\\s)" + t + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "") } const gt = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", mt = ".sticky-top", bt = ".navbar-toggler"; class vt extends Qe { adjustAndStore(e, t, n) { const r = t.style[e]; t.dataset[e] = r, ze(t, { [e]: "".concat(parseFloat(ze(t, e)) + n, "px") }) } restore(e, t) { const n = t.dataset[e]; void 0 !== n && (delete t.dataset[e], ze(t, { [e]: n })) } setContainerStyle(e) { super.setContainerStyle(e); const t = this.getElement(); var n, r; if (r = "modal-open", (n = t).classList ? n.classList.add(r) : dt(n, r) || ("string" === typeof n.className ? n.className = n.className + " " + r : n.setAttribute("class", (n.className && n.className.baseVal || "") + " " + r)), !e.scrollBarWidth) return; const i = this.isRTL ? "paddingLeft" : "paddingRight", o = this.isRTL ? "marginLeft" : "marginRight"; ft(t, gt).forEach((t => this.adjustAndStore(i, t, e.scrollBarWidth))), ft(t, mt).forEach((t => this.adjustAndStore(o, t, -e.scrollBarWidth))), ft(t, bt).forEach((t => this.adjustAndStore(o, t, e.scrollBarWidth))) } removeContainerStyle(e) { super.removeContainerStyle(e); const t = this.getElement(); var n, r; r = "modal-open", (n = t).classList ? n.classList.remove(r) : "string" === typeof n.className ? n.className = pt(n.className, r) : n.setAttribute("class", pt(n.className && n.className.baseVal || "", r)); const i = this.isRTL ? "paddingLeft" : "paddingRight", o = this.isRTL ? "marginLeft" : "marginRight"; ft(t, gt).forEach((e => this.restore(i, e))), ft(t, mt).forEach((e => this.restore(o, e))), ft(t, bt).forEach((e => this.restore(o, e))) } } let yt; function xt(e) { return yt || (yt = new vt(e)), yt } const wt = vt; function _t(e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i } function kt(e, t) { return kt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) { return e.__proto__ = t, e }, kt(e, t) } const St = !1, Ct = e.createContext(null); var Et = "unmounted", Mt = "exited", Ot = "entering", Pt = "entered", Nt = "exiting", Tt = function (t) { var n, r; function i(e, n) { var r; r = t.call(this, e, n) || this; var i, o = n && !n.isMounting ? e.enter : e.appear; return r.appearStatus = null, e.in ? o ? (i = Mt, r.appearStatus = Ot) : i = Pt : i = e.unmountOnExit || e.mountOnEnter ? Et : Mt, r.state = { status: i }, r.nextCallback = null, r } r = t, (n = i).prototype = Object.create(r.prototype), n.prototype.constructor = n, kt(n, r), i.getDerivedStateFromProps = function (e, t) { return e.in && t.status === Et ? { status: Mt } : null }; var o = i.prototype; return o.componentDidMount = function () { this.updateStatus(!0, this.appearStatus) }, o.componentDidUpdate = function (e) { var t = null; if (e !== this.props) { var n = this.state.status; this.props.in ? n !== Ot && n !== Pt && (t = Ot) : n !== Ot && n !== Pt || (t = Nt) } this.updateStatus(!1, t) }, o.componentWillUnmount = function () { this.cancelNextCallback() }, o.getTimeouts = function () { var e, t, n, r = this.props.timeout; return e = t = n = r, null != r && "number" !== typeof r && (e = r.exit, t = r.enter, n = void 0 !== r.appear ? r.appear : t), { exit: e, enter: t, appear: n } }, o.updateStatus = function (e, t) { if (void 0 === e && (e = !1), null !== t) if (this.cancelNextCallback(), t === Ot) { if (this.props.unmountOnExit || this.props.mountOnEnter) { var n = this.props.nodeRef ? this.props.nodeRef.current : He.findDOMNode(this); n && function (e) { e.scrollTop }(n) } this.performEnter(e) } else this.performExit(); else this.props.unmountOnExit && this.state.status === Mt && this.setState({ status: Et }) }, o.performEnter = function (e) { var t = this, n = this.props.enter, r = this.context ? this.context.isMounting : e, i = this.props.nodeRef ? [r] : [He.findDOMNode(this), r], o = i[0], a = i[1], s = this.getTimeouts(), l = r ? s.appear : s.enter; !e && !n || St ? this.safeSetState({ status: Pt }, (function () { t.props.onEntered(o) })) : (this.props.onEnter(o, a), this.safeSetState({ status: Ot }, (function () { t.props.onEntering(o, a), t.onTransitionEnd(l, (function () { t.safeSetState({ status: Pt }, (function () { t.props.onEntered(o, a) })) })) }))) }, o.performExit = function () { var e = this, t = this.props.exit, n = this.getTimeouts(), r = this.props.nodeRef ? void 0 : He.findDOMNode(this); t && !St ? (this.props.onExit(r), this.safeSetState({ status: Nt }, (function () { e.props.onExiting(r), e.onTransitionEnd(n.exit, (function () { e.safeSetState({ status: Mt }, (function () { e.props.onExited(r) })) })) }))) : this.safeSetState({ status: Mt }, (function () { e.props.onExited(r) })) }, o.cancelNextCallback = function () { null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null) }, o.safeSetState = function (e, t) { t = this.setNextCallback(t), this.setState(e, t) }, o.setNextCallback = function (e) { var t = this, n = !0; return this.nextCallback = function (r) { n && (n = !1, t.nextCallback = null, e(r)) }, this.nextCallback.cancel = function () { n = !1 }, this.nextCallback }, o.onTransitionEnd = function (e, t) { this.setNextCallback(t); var n = this.props.nodeRef ? this.props.nodeRef.current : He.findDOMNode(this), r = null == e && !this.props.addEndListener; if (n && !r) { if (this.props.addEndListener) { var i = this.props.nodeRef ? [this.nextCallback] : [n, this.nextCallback], o = i[0], a = i[1]; this.props.addEndListener(o, a) } null != e && setTimeout(this.nextCallback, e) } else setTimeout(this.nextCallback, 0) }, o.render = function () { var t = this.state.status; if (t === Et) return null; var n = this.props, r = n.children, i = (n.in, n.mountOnEnter, n.unmountOnExit, n.appear, n.enter, n.exit, n.timeout, n.addEndListener, n.onEnter, n.onEntering, n.onEntered, n.onExit, n.onExiting, n.onExited, n.nodeRef, _t(n, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"])); return e.createElement(Ct.Provider, { value: null }, "function" === typeof r ? r(t, i) : e.cloneElement(e.Children.only(r), i)) }, i }(e.Component); function jt() { } Tt.contextType = Ct, Tt.propTypes = {}, Tt.defaultProps = { in: !1, mountOnEnter: !1, unmountOnExit: !1, appear: !1, enter: !0, exit: !0, onEnter: jt, onEntering: jt, onEntered: jt, onExit: jt, onExiting: jt, onExited: jt }, Tt.UNMOUNTED = Et, Tt.EXITED = Mt, Tt.ENTERING = Ot, Tt.ENTERED = Pt, Tt.EXITING = Nt; const Dt = Tt; function Rt(e, t) { const n = ze(e, t) || "", r = -1 === n.indexOf("ms") ? 1e3 : 1; return parseFloat(n) * r } function Lt(e, t) { const n = Rt(e, "transitionDuration"), r = Rt(e, "transitionDelay"), i = Be(e, (n => { n.target === e && (i(), t(n)) }), n + r) } function At(e) { e.offsetHeight } function zt(e) { return e && "setState" in e ? He.findDOMNode(e) : null != e ? e : null } const It = e.forwardRef(((t, n) => { let { onEnter: r, onEntering: i, onEntered: o, onExit: s, onExiting: l, onExited: c, addEndListener: u, children: d, childRef: h, ...f } = t; const p = (0, e.useRef)(null), g = Ne(p, h), m = e => { g(zt(e)) }, b = e => t => { e && p.current && e(p.current, t) }, v = (0, e.useCallback)(b(r), [r]), y = (0, e.useCallback)(b(i), [i]), x = (0, e.useCallback)(b(o), [o]), w = (0, e.useCallback)(b(s), [s]), _ = (0, e.useCallback)(b(l), [l]), k = (0, e.useCallback)(b(c), [c]), S = (0, e.useCallback)(b(u), [u]); return (0, a.jsx)(Dt, { ref: n, ...f, onEnter: v, onEntered: x, onEntering: y, onExit: w, onExited: k, onExiting: _, addEndListener: S, nodeRef: p, children: "function" === typeof d ? (e, t) => d(e, { ...t, ref: m }) : e.cloneElement(d, { ref: m }) }) })), Ft = It, Bt = { [Ot]: "show", [Pt]: "show" }, Wt = e.forwardRef(((t, n) => { let { className: r, children: i, transitionClasses: s = {}, onEnter: l, ...c } = t; const u = { in: !1, timeout: 300, mountOnEnter: !1, unmountOnExit: !1, appear: !1, ...c }, d = (0, e.useCallback)(((e, t) => { At(e), null == l || l(e, t) }), [l]); return (0, a.jsx)(Ft, { ref: n, addEndListener: Lt, ...u, onEnter: d, childRef: i.ref, children: (t, n) => e.cloneElement(i, { ...n, className: o()("fade", r, i.props.className, Bt[t], s[t]) }) }) })); Wt.displayName = "Fade"; const Vt = Wt, Ht = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = h(r, "modal-body"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); Ht.displayName = "ModalBody"; const Ut = Ht, $t = e.createContext({ onHide() { } }), Yt = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, contentClassName: i, centered: s, size: l, fullscreen: c, children: u, scrollable: d, ...f } = e; n = h(n, "modal"); const p = "".concat(n, "-dialog"), g = "string" === typeof c ? "".concat(n, "-fullscreen-").concat(c) : "".concat(n, "-fullscreen"); return (0, a.jsx)("div", { ...f, ref: t, className: o()(p, r, l && "".concat(n, "-").concat(l), s && "".concat(p, "-centered"), d && "".concat(p, "-scrollable"), c && g), children: (0, a.jsx)("div", { className: o()("".concat(n, "-content"), i), children: u }) }) })); Yt.displayName = "ModalDialog"; const qt = Yt, Kt = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = h(r, "modal-footer"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); Kt.displayName = "ModalFooter"; const Qt = Kt, Xt = { "aria-label": y().string, onClick: y().func, variant: y().oneOf(["white"]) }, Gt = e.forwardRef(((e, t) => { let { className: n, variant: r, "aria-label": i = "Close", ...s } = e; return (0, a.jsx)("button", { ref: t, type: "button", className: o()("btn-close", r && "btn-close-".concat(r), n), "aria-label": i, ...s }) })); Gt.displayName = "CloseButton", Gt.propTypes = Xt; const Jt = Gt, Zt = e.forwardRef(((t, n) => { let { closeLabel: r = "Close", closeVariant: i, closeButton: o = !1, onHide: s, children: l, ...c } = t; const u = (0, e.useContext)($t), d = Oe((() => { null == u || u.onHide(), null == s || s() })); return (0, a.jsxs)("div", { ref: n, ...c, children: [l, o && (0, a.jsx)(Jt, { "aria-label": r, variant: i, onClick: d })] }) })), en = Zt, tn = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, closeLabel: i = "Close", closeButton: s = !1, ...l } = e; return n = h(n, "modal-header"), (0, a.jsx)(en, { ref: t, ...l, className: o()(r, n), closeLabel: i, closeButton: s }) })); tn.displayName = "ModalHeader"; const nn = tn, rn = t => e.forwardRef(((e, n) => (0, a.jsx)("div", { ...e, ref: n, className: o()(e.className, t) }))), on = rn("h4"), an = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = on, ...s } = e; return r = h(r, "modal-title"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); an.displayName = "ModalTitle"; const sn = an; function ln(e) { return (0, a.jsx)(Vt, { ...e, timeout: null }) } function cn(e) { return (0, a.jsx)(Vt, { ...e, timeout: null }) } const un = e.forwardRef(((t, n) => { let { bsPrefix: r, className: i, style: s, dialogClassName: l, contentClassName: c, children: u, dialogAs: d = qt, "aria-labelledby": f, "aria-describedby": p, "aria-label": m, show: b = !1, animation: v = !0, backdrop: y = !0, keyboard: x = !0, onEscapeKeyDown: w, onShow: _, onHide: k, container: S, autoFocus: C = !0, enforceFocus: E = !0, restoreFocus: M = !0, restoreFocusOptions: O, onEntered: P, onExit: N, onExiting: T, onEnter: j, onEntering: D, onExited: R, backdropClassName: L, manager: A, ...z } = t; const [I, F] = (0, e.useState)({}), [B, W] = (0, e.useState)(!1), V = (0, e.useRef)(!1), H = (0, e.useRef)(!1), U = (0, e.useRef)(null), [$, Y] = Ee(), q = Ne(n, Y), K = Oe(k), Q = g(); r = h(r, "modal"); const X = (0, e.useMemo)((() => ({ onHide: K })), [K]); function G() { return A || xt({ isRTL: Q }) } function J(e) { if (!be) return; const t = G().getScrollbarWidth() > 0, n = e.scrollHeight > _e(e).documentElement.clientHeight; F({ paddingRight: t && !n ? Ce() : void 0, paddingLeft: !t && n ? Ce() : void 0 }) } const Z = Oe((() => { $ && J($.dialog) })); Te((() => { ke(window, "resize", Z), null == U.current || U.current() })); const ee = () => { V.current = !0 }, te = e => { V.current && $ && e.target === $.dialog && (H.current = !0), V.current = !1 }, ne = () => { W(!0), U.current = Be($.dialog, (() => { W(!1) })) }, re = e => { "static" !== y ? H.current || e.target !== e.currentTarget ? H.current = !1 : null == k || k() : (e => { e.target === e.currentTarget && ne() })(e) }, ie = (0, e.useCallback)((e => (0, a.jsx)("div", { ...e, className: o()("".concat(r, "-backdrop"), L, !v && "show") })), [v, L, r]), oe = { ...s, ...I }; oe.display = "block"; return (0, a.jsx)($t.Provider, { value: X, children: (0, a.jsx)(ut, { show: b, ref: q, backdrop: y, container: S, keyboard: !0, autoFocus: C, enforceFocus: E, restoreFocus: M, restoreFocusOptions: O, onEscapeKeyDown: e => { x ? null == w || w(e) : (e.preventDefault(), "static" === y && ne()) }, onShow: _, onHide: k, onEnter: (e, t) => { e && J(e), null == j || j(e, t) }, onEntering: (e, t) => { null == D || D(e, t), we(window, "resize", Z) }, onEntered: P, onExit: e => { null == U.current || U.current(), null == N || N(e) }, onExiting: T, onExited: e => { e && (e.style.display = ""), null == R || R(e), ke(window, "resize", Z) }, manager: G(), transition: v ? ln : void 0, backdropTransition: v ? cn : void 0, renderBackdrop: ie, renderDialog: e => (0, a.jsx)("div", { role: "dialog", ...e, style: oe, className: o()(i, r, B && "".concat(r, "-static"), !v && "show"), onClick: y ? re : void 0, onMouseUp: te, "aria-label": m, "aria-labelledby": f, "aria-describedby": p, children: (0, a.jsx)(d, { ...z, onMouseDown: ee, className: l, contentClassName: c, children: u }) }) }) }) })); un.displayName = "Modal"; const dn = Object.assign(un, { Body: Ut, Header: nn, Title: sn, Footer: Qt, Dialog: qt, TRANSITION_DURATION: 300, BACKDROP_TRANSITION_DURATION: 150 }), hn = 2 ** 31 - 1; function fn(e, t, n) { const r = n - Date.now(); e.current = r <= hn ? setTimeout(t, r) : setTimeout((() => fn(e, t, n)), hn) } function pn() { const t = $e(), n = (0, e.useRef)(); return Te((() => clearTimeout(n.current))), (0, e.useMemo)((() => { const e = () => clearTimeout(n.current); return { set: function (r) { let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; t() && (e(), i <= hn ? n.current = setTimeout(r, i) : fn(n, r, Date.now() + i)) }, clear: e, handleRef: n } }), []) } function gn() { return gn = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, gn.apply(this, arguments) } n(176); function mn(e) { return "default" + e.charAt(0).toUpperCase() + e.substr(1) } function bn(e) { var t = function (e, t) { if ("object" !== typeof e || null === e) return e; var n = e[Symbol.toPrimitive]; if (void 0 !== n) { var r = n.call(e, t || "default"); if ("object" !== typeof r) return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(e, "string"); return "symbol" === typeof t ? t : String(t) } function vn(t, n, r) { var i = (0, e.useRef)(void 0 !== t), o = (0, e.useState)(n), a = o[0], s = o[1], l = void 0 !== t, c = i.current; return i.current = l, !l && c && a !== n && s(n), [l ? t : a, (0, e.useCallback)((function (e) { for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)n[i - 1] = arguments[i]; r && r.apply(void 0, [e].concat(n)), s(e) }), [r])] } function yn(e, t) { return Object.keys(t).reduce((function (n, r) { var i, o = n, a = o[mn(r)], s = o[r], l = _t(o, [mn(r), r].map(bn)), c = t[r], u = vn(s, a, e[c]), d = u[0], h = u[1]; return gn({}, l, ((i = {})[r] = d, i[c] = h, i)) }), e) } function xn() { var e = this.constructor.getDerivedStateFromProps(this.props, this.state); null !== e && void 0 !== e && this.setState(e) } function wn(e) { this.setState(function (t) { var n = this.constructor.getDerivedStateFromProps(e, t); return null !== n && void 0 !== n ? n : null }.bind(this)) } function _n(e, t) { try { var n = this.props, r = this.state; this.props = e, this.state = t, this.__reactInternalSnapshotFlag = !0, this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(n, r) } finally { this.props = n, this.state = r } } xn.__suppressDeprecationWarning = !0, wn.__suppressDeprecationWarning = !0, _n.__suppressDeprecationWarning = !0; var kn = Object.prototype.hasOwnProperty; function Sn(e, t, n) { for (n of e.keys()) if (Cn(n, t)) return n } function Cn(e, t) { var n, r, i; if (e === t) return !0; if (e && t && (n = e.constructor) === t.constructor) { if (n === Date) return e.getTime() === t.getTime(); if (n === RegExp) return e.toString() === t.toString(); if (n === Array) { if ((r = e.length) === t.length) for (; r-- && Cn(e[r], t[r]);); return -1 === r } if (n === Set) { if (e.size !== t.size) return !1; for (r of e) { if ((i = r) && "object" === typeof i && !(i = Sn(t, i))) return !1; if (!t.has(i)) return !1 } return !0 } if (n === Map) { if (e.size !== t.size) return !1; for (r of e) { if ((i = r[0]) && "object" === typeof i && !(i = Sn(t, i))) return !1; if (!Cn(r[1], t.get(i))) return !1 } return !0 } if (n === ArrayBuffer) e = new Uint8Array(e), t = new Uint8Array(t); else if (n === DataView) { if ((r = e.byteLength) === t.byteLength) for (; r-- && e.getInt8(r) === t.getInt8(r);); return -1 === r } if (ArrayBuffer.isView(e)) { if ((r = e.byteLength) === t.byteLength) for (; r-- && e[r] === t[r];); return -1 === r } if (!n || "object" === typeof e) { for (n in r = 0, e) { if (kn.call(e, n) && ++r && !kn.call(t, n)) return !1; if (!(n in t) || !Cn(e[n], t[n])) return !1 } return Object.keys(t).length === r } } return e !== e && t !== t } const En = function (t) { const n = $e(); return [t[0], (0, e.useCallback)((e => { if (n()) return t[1](e) }), [n, t[1]])] }; function Mn(e) { return e.split("-")[0] } function On(e) { if (null == e) return window; if ("[object Window]" !== e.toString()) { var t = e.ownerDocument; return t && t.defaultView || window } return e } function Pn(e) { return e instanceof On(e).Element || e instanceof Element } function Nn(e) { return e instanceof On(e).HTMLElement || e instanceof HTMLElement } function Tn(e) { return "undefined" !== typeof ShadowRoot && (e instanceof On(e).ShadowRoot || e instanceof ShadowRoot) } var jn = Math.max, Dn = Math.min, Rn = Math.round; function Ln() { var e = navigator.userAgentData; return null != e && e.brands && Array.isArray(e.brands) ? e.brands.map((function (e) { return e.brand + "/" + e.version })).join(" ") : navigator.userAgent } function An() { return !/^((?!chrome|android).)*safari/i.test(Ln()) } function zn(e, t, n) { void 0 === t && (t = !1), void 0 === n && (n = !1); var r = e.getBoundingClientRect(), i = 1, o = 1; t && Nn(e) && (i = e.offsetWidth > 0 && Rn(r.width) / e.offsetWidth || 1, o = e.offsetHeight > 0 && Rn(r.height) / e.offsetHeight || 1); var a = (Pn(e) ? On(e) : window).visualViewport, s = !An() && n, l = (r.left + (s && a ? a.offsetLeft : 0)) / i, c = (r.top + (s && a ? a.offsetTop : 0)) / o, u = r.width / i, d = r.height / o; return { width: u, height: d, top: c, right: l + u, bottom: c + d, left: l, x: l, y: c } } function In(e) { var t = zn(e), n = e.offsetWidth, r = e.offsetHeight; return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: r } } function Fn(e, t) { var n = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (n && Tn(n)) { var r = t; do { if (r && e.isSameNode(r)) return !0; r = r.parentNode || r.host } while (r) } return !1 } function Bn(e) { return e ? (e.nodeName || "").toLowerCase() : null } function Wn(e) { return On(e).getComputedStyle(e) } function Vn(e) { return ["table", "td", "th"].indexOf(Bn(e)) >= 0 } function Hn(e) { return ((Pn(e) ? e.ownerDocument : e.document) || window.document).documentElement } function Un(e) { return "html" === Bn(e) ? e : e.assignedSlot || e.parentNode || (Tn(e) ? e.host : null) || Hn(e) } function $n(e) { return Nn(e) && "fixed" !== Wn(e).position ? e.offsetParent : null } function Yn(e) { for (var t = On(e), n = $n(e); n && Vn(n) && "static" === Wn(n).position;)n = $n(n); return n && ("html" === Bn(n) || "body" === Bn(n) && "static" === Wn(n).position) ? t : n || function (e) { var t = /firefox/i.test(Ln()); if (/Trident/i.test(Ln()) && Nn(e) && "fixed" === Wn(e).position) return null; var n = Un(e); for (Tn(n) && (n = n.host); Nn(n) && ["html", "body"].indexOf(Bn(n)) < 0;) { var r = Wn(n); if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || t && "filter" === r.willChange || t && r.filter && "none" !== r.filter) return n; n = n.parentNode } return null }(e) || t } function qn(e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y" } function Kn(e, t, n) { return jn(e, Dn(t, n)) } function Qn(e) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e) } function Xn(e, t) { return t.reduce((function (t, n) { return t[n] = e, t }), {}) } var Gn = "top", Jn = "bottom", Zn = "right", er = "left", tr = "auto", nr = [Gn, Jn, Zn, er], rr = "start", ir = "end", or = "clippingParents", ar = "viewport", sr = "popper", lr = "reference", cr = nr.reduce((function (e, t) { return e.concat([t + "-" + rr, t + "-" + ir]) }), []), ur = [].concat(nr, [tr]).reduce((function (e, t) { return e.concat([t, t + "-" + rr, t + "-" + ir]) }), []), dr = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]; const hr = { name: "arrow", enabled: !0, phase: "main", fn: function (e) { var t, n = e.state, r = e.name, i = e.options, o = n.elements.arrow, a = n.modifiersData.popperOffsets, s = Mn(n.placement), l = qn(s), c = [er, Zn].indexOf(s) >= 0 ? "height" : "width"; if (o && a) { var u = function (e, t) { return Qn("number" !== typeof (e = "function" === typeof e ? e(Object.assign({}, t.rects, { placement: t.placement })) : e) ? e : Xn(e, nr)) }(i.padding, n), d = In(o), h = "y" === l ? Gn : er, f = "y" === l ? Jn : Zn, p = n.rects.reference[c] + n.rects.reference[l] - a[l] - n.rects.popper[c], g = a[l] - n.rects.reference[l], m = Yn(o), b = m ? "y" === l ? m.clientHeight || 0 : m.clientWidth || 0 : 0, v = p / 2 - g / 2, y = u[h], x = b - d[c] - u[f], w = b / 2 - d[c] / 2 + v, _ = Kn(y, w, x), k = l; n.modifiersData[r] = ((t = {})[k] = _, t.centerOffset = _ - w, t) } }, effect: function (e) { var t = e.state, n = e.options.element, r = void 0 === n ? "[data-popper-arrow]" : n; null != r && ("string" !== typeof r || (r = t.elements.popper.querySelector(r))) && Fn(t.elements.popper, r) && (t.elements.arrow = r) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function fr(e) { return e.split("-")[1] } var pr = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function gr(e) { var t, n = e.popper, r = e.popperRect, i = e.placement, o = e.variation, a = e.offsets, s = e.position, l = e.gpuAcceleration, c = e.adaptive, u = e.roundOffsets, d = e.isFixed, h = a.x, f = void 0 === h ? 0 : h, p = a.y, g = void 0 === p ? 0 : p, m = "function" === typeof u ? u({ x: f, y: g }) : { x: f, y: g }; f = m.x, g = m.y; var b = a.hasOwnProperty("x"), v = a.hasOwnProperty("y"), y = er, x = Gn, w = window; if (c) { var _ = Yn(n), k = "clientHeight", S = "clientWidth"; if (_ === On(n) && "static" !== Wn(_ = Hn(n)).position && "absolute" === s && (k = "scrollHeight", S = "scrollWidth"), i === Gn || (i === er || i === Zn) && o === ir) x = Jn, g -= (d && _ === w && w.visualViewport ? w.visualViewport.height : _[k]) - r.height, g *= l ? 1 : -1; if (i === er || (i === Gn || i === Jn) && o === ir) y = Zn, f -= (d && _ === w && w.visualViewport ? w.visualViewport.width : _[S]) - r.width, f *= l ? 1 : -1 } var C, E = Object.assign({ position: s }, c && pr), M = !0 === u ? function (e, t) { var n = e.x, r = e.y, i = t.devicePixelRatio || 1; return { x: Rn(n * i) / i || 0, y: Rn(r * i) / i || 0 } }({ x: f, y: g }, On(n)) : { x: f, y: g }; return f = M.x, g = M.y, l ? Object.assign({}, E, ((C = {})[x] = v ? "0" : "", C[y] = b ? "0" : "", C.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + g + "px)" : "translate3d(" + f + "px, " + g + "px, 0)", C)) : Object.assign({}, E, ((t = {})[x] = v ? g + "px" : "", t[y] = b ? f + "px" : "", t.transform = "", t)) } const mr = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) { var t = e.state, n = e.options, r = n.gpuAcceleration, i = void 0 === r || r, o = n.adaptive, a = void 0 === o || o, s = n.roundOffsets, l = void 0 === s || s, c = { placement: Mn(t.placement), variation: fr(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: i, isFixed: "fixed" === t.options.strategy }; null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, gr(Object.assign({}, c, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: a, roundOffsets: l })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, gr(Object.assign({}, c, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) }, data: {} }; var br = { passive: !0 }; const vr = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (e) { var t = e.state, n = e.instance, r = e.options, i = r.scroll, o = void 0 === i || i, a = r.resize, s = void 0 === a || a, l = On(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper); return o && c.forEach((function (e) { e.addEventListener("scroll", n.update, br) })), s && l.addEventListener("resize", n.update, br), function () { o && c.forEach((function (e) { e.removeEventListener("scroll", n.update, br) })), s && l.removeEventListener("resize", n.update, br) } }, data: {} }; var yr = { left: "right", right: "left", bottom: "top", top: "bottom" }; function xr(e) { return e.replace(/left|right|bottom|top/g, (function (e) { return yr[e] })) } var wr = { start: "end", end: "start" }; function _r(e) { return e.replace(/start|end/g, (function (e) { return wr[e] })) } function kr(e) { var t = On(e); return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset } } function Sr(e) { return zn(Hn(e)).left + kr(e).scrollLeft } function Cr(e) { var t = Wn(e), n = t.overflow, r = t.overflowX, i = t.overflowY; return /auto|scroll|overlay|hidden/.test(n + i + r) } function Er(e) { return ["html", "body", "#document"].indexOf(Bn(e)) >= 0 ? e.ownerDocument.body : Nn(e) && Cr(e) ? e : Er(Un(e)) } function Mr(e, t) { var n; void 0 === t && (t = []); var r = Er(e), i = r === (null == (n = e.ownerDocument) ? void 0 : n.body), o = On(r), a = i ? [o].concat(o.visualViewport || [], Cr(r) ? r : []) : r, s = t.concat(a); return i ? s : s.concat(Mr(Un(a))) } function Or(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function Pr(e, t, n) { return t === ar ? Or(function (e, t) { var n = On(e), r = Hn(e), i = n.visualViewport, o = r.clientWidth, a = r.clientHeight, s = 0, l = 0; if (i) { o = i.width, a = i.height; var c = An(); (c || !c && "fixed" === t) && (s = i.offsetLeft, l = i.offsetTop) } return { width: o, height: a, x: s + Sr(e), y: l } }(e, n)) : Pn(t) ? function (e, t) { var n = zn(e, !1, "fixed" === t); return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n }(t, n) : Or(function (e) { var t, n = Hn(e), r = kr(e), i = null == (t = e.ownerDocument) ? void 0 : t.body, o = jn(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = jn(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), s = -r.scrollLeft + Sr(e), l = -r.scrollTop; return "rtl" === Wn(i || n).direction && (s += jn(n.clientWidth, i ? i.clientWidth : 0) - o), { width: o, height: a, x: s, y: l } }(Hn(e))) } function Nr(e, t, n, r) { var i = "clippingParents" === t ? function (e) { var t = Mr(Un(e)), n = ["absolute", "fixed"].indexOf(Wn(e).position) >= 0 && Nn(e) ? Yn(e) : e; return Pn(n) ? t.filter((function (e) { return Pn(e) && Fn(e, n) && "body" !== Bn(e) })) : [] }(e) : [].concat(t), o = [].concat(i, [n]), a = o[0], s = o.reduce((function (t, n) { var i = Pr(e, n, r); return t.top = jn(i.top, t.top), t.right = Dn(i.right, t.right), t.bottom = Dn(i.bottom, t.bottom), t.left = jn(i.left, t.left), t }), Pr(e, a, r)); return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s } function Tr(e) { var t, n = e.reference, r = e.element, i = e.placement, o = i ? Mn(i) : null, a = i ? fr(i) : null, s = n.x + n.width / 2 - r.width / 2, l = n.y + n.height / 2 - r.height / 2; switch (o) { case Gn: t = { x: s, y: n.y - r.height }; break; case Jn: t = { x: s, y: n.y + n.height }; break; case Zn: t = { x: n.x + n.width, y: l }; break; case er: t = { x: n.x - r.width, y: l }; break; default: t = { x: n.x, y: n.y } }var c = o ? qn(o) : null; if (null != c) { var u = "y" === c ? "height" : "width"; switch (a) { case rr: t[c] = t[c] - (n[u] / 2 - r[u] / 2); break; case ir: t[c] = t[c] + (n[u] / 2 - r[u] / 2) } } return t } function jr(e, t) { void 0 === t && (t = {}); var n = t, r = n.placement, i = void 0 === r ? e.placement : r, o = n.strategy, a = void 0 === o ? e.strategy : o, s = n.boundary, l = void 0 === s ? or : s, c = n.rootBoundary, u = void 0 === c ? ar : c, d = n.elementContext, h = void 0 === d ? sr : d, f = n.altBoundary, p = void 0 !== f && f, g = n.padding, m = void 0 === g ? 0 : g, b = Qn("number" !== typeof m ? m : Xn(m, nr)), v = h === sr ? lr : sr, y = e.rects.popper, x = e.elements[p ? v : h], w = Nr(Pn(x) ? x : x.contextElement || Hn(e.elements.popper), l, u, a), _ = zn(e.elements.reference), k = Tr({ reference: _, element: y, strategy: "absolute", placement: i }), S = Or(Object.assign({}, y, k)), C = h === sr ? S : _, E = { top: w.top - C.top + b.top, bottom: C.bottom - w.bottom + b.bottom, left: w.left - C.left + b.left, right: C.right - w.right + b.right }, M = e.modifiersData.offset; if (h === sr && M) { var O = M[i]; Object.keys(E).forEach((function (e) { var t = [Zn, Jn].indexOf(e) >= 0 ? 1 : -1, n = [Gn, Jn].indexOf(e) >= 0 ? "y" : "x"; E[e] += O[n] * t })) } return E } const Dr = { name: "flip", enabled: !0, phase: "main", fn: function (e) { var t = e.state, n = e.options, r = e.name; if (!t.modifiersData[r]._skip) { for (var i = n.mainAxis, o = void 0 === i || i, a = n.altAxis, s = void 0 === a || a, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, h = n.altBoundary, f = n.flipVariations, p = void 0 === f || f, g = n.allowedAutoPlacements, m = t.options.placement, b = Mn(m), v = l || (b === m || !p ? [xr(m)] : function (e) { if (Mn(e) === tr) return []; var t = xr(e); return [_r(e), t, _r(t)] }(m)), y = [m].concat(v).reduce((function (e, n) { return e.concat(Mn(n) === tr ? function (e, t) { void 0 === t && (t = {}); var n = t, r = n.placement, i = n.boundary, o = n.rootBoundary, a = n.padding, s = n.flipVariations, l = n.allowedAutoPlacements, c = void 0 === l ? ur : l, u = fr(r), d = u ? s ? cr : cr.filter((function (e) { return fr(e) === u })) : nr, h = d.filter((function (e) { return c.indexOf(e) >= 0 })); 0 === h.length && (h = d); var f = h.reduce((function (t, n) { return t[n] = jr(e, { placement: n, boundary: i, rootBoundary: o, padding: a })[Mn(n)], t }), {}); return Object.keys(f).sort((function (e, t) { return f[e] - f[t] })) }(t, { placement: n, boundary: u, rootBoundary: d, padding: c, flipVariations: p, allowedAutoPlacements: g }) : n) }), []), x = t.rects.reference, w = t.rects.popper, _ = new Map, k = !0, S = y[0], C = 0; C < y.length; C++) { var E = y[C], M = Mn(E), O = fr(E) === rr, P = [Gn, Jn].indexOf(M) >= 0, N = P ? "width" : "height", T = jr(t, { placement: E, boundary: u, rootBoundary: d, altBoundary: h, padding: c }), j = P ? O ? Zn : er : O ? Jn : Gn; x[N] > w[N] && (j = xr(j)); var D = xr(j), R = []; if (o && R.push(T[M] <= 0), s && R.push(T[j] <= 0, T[D] <= 0), R.every((function (e) { return e }))) { S = E, k = !1; break } _.set(E, R) } if (k) for (var L = function (e) { var t = y.find((function (t) { var n = _.get(t); if (n) return n.slice(0, e).every((function (e) { return e })) })); if (t) return S = t, "break" }, A = p ? 3 : 1; A > 0; A--) { if ("break" === L(A)) break } t.placement !== S && (t.modifiersData[r]._skip = !0, t.placement = S, t.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function Rr(e, t, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x } } function Lr(e) { return [Gn, Zn, Jn, er].some((function (t) { return e[t] >= 0 })) } const Ar = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) { var t = e.state, n = e.options, r = e.name, i = n.offset, o = void 0 === i ? [0, 0] : i, a = ur.reduce((function (e, n) { return e[n] = function (e, t, n) { var r = Mn(e), i = [er, Gn].indexOf(r) >= 0 ? -1 : 1, o = "function" === typeof n ? n(Object.assign({}, t, { placement: e })) : n, a = o[0], s = o[1]; return a = a || 0, s = (s || 0) * i, [er, Zn].indexOf(r) >= 0 ? { x: s, y: a } : { x: a, y: s } }(n, t.rects, o), e }), {}), s = a[t.placement], l = s.x, c = s.y; null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = a } }; const zr = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) { var t = e.state, n = e.options, r = e.name, i = n.mainAxis, o = void 0 === i || i, a = n.altAxis, s = void 0 !== a && a, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, h = n.tether, f = void 0 === h || h, p = n.tetherOffset, g = void 0 === p ? 0 : p, m = jr(t, { boundary: l, rootBoundary: c, padding: d, altBoundary: u }), b = Mn(t.placement), v = fr(t.placement), y = !v, x = qn(b), w = "x" === x ? "y" : "x", _ = t.modifiersData.popperOffsets, k = t.rects.reference, S = t.rects.popper, C = "function" === typeof g ? g(Object.assign({}, t.rects, { placement: t.placement })) : g, E = "number" === typeof C ? { mainAxis: C, altAxis: C } : Object.assign({ mainAxis: 0, altAxis: 0 }, C), M = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, O = { x: 0, y: 0 }; if (_) { if (o) { var P, N = "y" === x ? Gn : er, T = "y" === x ? Jn : Zn, j = "y" === x ? "height" : "width", D = _[x], R = D + m[N], L = D - m[T], A = f ? -S[j] / 2 : 0, z = v === rr ? k[j] : S[j], I = v === rr ? -S[j] : -k[j], F = t.elements.arrow, B = f && F ? In(F) : { width: 0, height: 0 }, W = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, V = W[N], H = W[T], U = Kn(0, k[j], B[j]), $ = y ? k[j] / 2 - A - U - V - E.mainAxis : z - U - V - E.mainAxis, Y = y ? -k[j] / 2 + A + U + H + E.mainAxis : I + U + H + E.mainAxis, q = t.elements.arrow && Yn(t.elements.arrow), K = q ? "y" === x ? q.clientTop || 0 : q.clientLeft || 0 : 0, Q = null != (P = null == M ? void 0 : M[x]) ? P : 0, X = D + Y - Q, G = Kn(f ? Dn(R, D + $ - Q - K) : R, D, f ? jn(L, X) : L); _[x] = G, O[x] = G - D } if (s) { var J, Z = "x" === x ? Gn : er, ee = "x" === x ? Jn : Zn, te = _[w], ne = "y" === w ? "height" : "width", re = te + m[Z], ie = te - m[ee], oe = -1 !== [Gn, er].indexOf(b), ae = null != (J = null == M ? void 0 : M[w]) ? J : 0, se = oe ? re : te - k[ne] - S[ne] - ae + E.altAxis, le = oe ? te + k[ne] + S[ne] - ae - E.altAxis : ie, ce = f && oe ? function (e, t, n) { var r = Kn(e, t, n); return r > n ? n : r }(se, te, le) : Kn(f ? se : re, te, f ? le : ie); _[w] = ce, O[w] = ce - te } t.modifiersData[r] = O } }, requiresIfExists: ["offset"] }; function Ir(e, t, n) { void 0 === n && (n = !1); var r = Nn(t), i = Nn(t) && function (e) { var t = e.getBoundingClientRect(), n = Rn(t.width) / e.offsetWidth || 1, r = Rn(t.height) / e.offsetHeight || 1; return 1 !== n || 1 !== r }(t), o = Hn(t), a = zn(e, i, n), s = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 }; return (r || !r && !n) && (("body" !== Bn(t) || Cr(o)) && (s = function (e) { return e !== On(e) && Nn(e) ? { scrollLeft: (t = e).scrollLeft, scrollTop: t.scrollTop } : kr(e); var t }(t)), Nn(t) ? ((l = zn(t, !0)).x += t.clientLeft, l.y += t.clientTop) : o && (l.x = Sr(o))), { x: a.left + s.scrollLeft - l.x, y: a.top + s.scrollTop - l.y, width: a.width, height: a.height } } function Fr(e) { var t = new Map, n = new Set, r = []; function i(e) { n.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach((function (e) { if (!n.has(e)) { var r = t.get(e); r && i(r) } })), r.push(e) } return e.forEach((function (e) { t.set(e.name, e) })), e.forEach((function (e) { n.has(e.name) || i(e) })), r } function Br(e) { var t; return function () { return t || (t = new Promise((function (n) { Promise.resolve().then((function () { t = void 0, n(e()) })) }))), t } } var Wr = { placement: "bottom", modifiers: [], strategy: "absolute" }; function Vr() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return !t.some((function (e) { return !(e && "function" === typeof e.getBoundingClientRect) })) } function Hr(e) { void 0 === e && (e = {}); var t = e, n = t.defaultModifiers, r = void 0 === n ? [] : n, i = t.defaultOptions, o = void 0 === i ? Wr : i; return function (e, t, n) { void 0 === n && (n = o); var i = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Wr, o), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }, a = [], s = !1, l = { state: i, setOptions: function (n) { var s = "function" === typeof n ? n(i.options) : n; c(), i.options = Object.assign({}, o, i.options, s), i.scrollParents = { reference: Pn(e) ? Mr(e) : e.contextElement ? Mr(e.contextElement) : [], popper: Mr(t) }; var u = function (e) { var t = Fr(e); return dr.reduce((function (e, n) { return e.concat(t.filter((function (e) { return e.phase === n }))) }), []) }(function (e) { var t = e.reduce((function (e, t) { var n = e[t.name]; return e[t.name] = n ? Object.assign({}, n, t, { options: Object.assign({}, n.options, t.options), data: Object.assign({}, n.data, t.data) }) : t, e }), {}); return Object.keys(t).map((function (e) { return t[e] })) }([].concat(r, i.options.modifiers))); return i.orderedModifiers = u.filter((function (e) { return e.enabled })), i.orderedModifiers.forEach((function (e) { var t = e.name, n = e.options, r = void 0 === n ? {} : n, o = e.effect; if ("function" === typeof o) { var s = o({ state: i, name: t, instance: l, options: r }), c = function () { }; a.push(s || c) } })), l.update() }, forceUpdate: function () { if (!s) { var e = i.elements, t = e.reference, n = e.popper; if (Vr(t, n)) { i.rects = { reference: Ir(t, Yn(n), "fixed" === i.options.strategy), popper: In(n) }, i.reset = !1, i.placement = i.options.placement, i.orderedModifiers.forEach((function (e) { return i.modifiersData[e.name] = Object.assign({}, e.data) })); for (var r = 0; r < i.orderedModifiers.length; r++)if (!0 !== i.reset) { var o = i.orderedModifiers[r], a = o.fn, c = o.options, u = void 0 === c ? {} : c, d = o.name; "function" === typeof a && (i = a({ state: i, options: u, name: d, instance: l }) || i) } else i.reset = !1, r = -1 } } }, update: Br((function () { return new Promise((function (e) { l.forceUpdate(), e(i) })) })), destroy: function () { c(), s = !0 } }; if (!Vr(e, t)) return l; function c() { a.forEach((function (e) { return e() })), a = [] } return l.setOptions(n).then((function (e) { !s && n.onFirstUpdate && n.onFirstUpdate(e) })), l } } const Ur = Hr({ defaultModifiers: [{ name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) { var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, o = t.modifiersData.preventOverflow, a = jr(t, { elementContext: "reference" }), s = jr(t, { altBoundary: !0 }), l = Rr(a, r), c = Rr(s, i, o), u = Lr(l), d = Lr(c); t.modifiersData[n] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: d }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": d }) } }, { name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) { var t = e.state, n = e.name; t.modifiersData[n] = Tr({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) }, data: {} }, mr, vr, Ar, Dr, zr, hr] }), $r = ["enabled", "placement", "strategy", "modifiers"]; const Yr = { name: "applyStyles", enabled: !1, phase: "afterWrite", fn: () => { } }, qr = { name: "ariaDescribedBy", enabled: !0, phase: "afterWrite", effect: e => { let { state: t } = e; return () => { const { reference: e, popper: n } = t.elements; if ("removeAttribute" in e) { const t = (e.getAttribute("aria-describedby") || "").split(",").filter((e => e.trim() !== n.id)); t.length ? e.setAttribute("aria-describedby", t.join(",")) : e.removeAttribute("aria-describedby") } } }, fn: e => { let { state: t } = e; var n; const { popper: r, reference: i } = t.elements, o = null == (n = r.getAttribute("role")) ? void 0 : n.toLowerCase(); if (r.id && "tooltip" === o && "setAttribute" in i) { const e = i.getAttribute("aria-describedby"); if (e && -1 !== e.split(",").indexOf(r.id)) return; i.setAttribute("aria-describedby", e ? "".concat(e, ",").concat(r.id) : r.id) } } }, Kr = []; const Qr = function (t, n) { let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, { enabled: i = !0, placement: o = "bottom", strategy: a = "absolute", modifiers: s = Kr } = r, l = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(r, $r); const c = (0, e.useRef)(s), u = (0, e.useRef)(), d = (0, e.useCallback)((() => { var e; null == (e = u.current) || e.update() }), []), h = (0, e.useCallback)((() => { var e; null == (e = u.current) || e.forceUpdate() }), []), [f, p] = En((0, e.useState)({ placement: o, update: d, forceUpdate: h, attributes: {}, styles: { popper: {}, arrow: {} } })), g = (0, e.useMemo)((() => ({ name: "updateStateModifier", enabled: !0, phase: "write", requires: ["computeStyles"], fn: e => { let { state: t } = e; const n = {}, r = {}; Object.keys(t.elements).forEach((e => { n[e] = t.styles[e], r[e] = t.attributes[e] })), p({ state: t, styles: n, attributes: r, update: d, forceUpdate: h, placement: t.placement }) } })), [d, h, p]), m = (0, e.useMemo)((() => (Cn(c.current, s) || (c.current = s), c.current)), [s]); return (0, e.useEffect)((() => { u.current && i && u.current.setOptions({ placement: o, strategy: a, modifiers: [...m, g, Yr] }) }), [a, o, g, i, m]), (0, e.useEffect)((() => { if (i && null != t && null != n) return u.current = Ur(t, n, Object.assign({}, l, { placement: o, strategy: a, modifiers: [...m, qr, g] })), () => { null != u.current && (u.current.destroy(), u.current = void 0, p((e => Object.assign({}, e, { attributes: {}, styles: { popper: {} } })))) } }), [i, t, n]), f }, Xr = () => { }; const Gr = e => e && ("current" in e ? e.current : e), Jr = { click: "mousedown", mouseup: "mousedown", pointerup: "pointerdown" }; const Zr = function (t) { let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Xr, { disabled: r, clickTrigger: i = "click" } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const o = (0, e.useRef)(!1), a = (0, e.useRef)(!1), s = (0, e.useCallback)((e => { const n = Gr(t); var r; T()(!!n, "ClickOutside captured a close event but does not have a ref to compare it to. useClickOutside(), should be passed a ref that resolves to a DOM node"), o.current = !n || !!((r = e).metaKey || r.altKey || r.ctrlKey || r.shiftKey) || !function (e) { return 0 === e.button }(e) || !!Ve(n, e.target) || a.current, a.current = !1 }), [t]), l = Oe((e => { const n = Gr(t); n && Ve(n, e.target) && (a.current = !0) })), c = Oe((e => { o.current || n(e) })); (0, e.useEffect)((() => { var e, n; if (r || null == t) return; const o = _e(Gr(t)), a = o.defaultView || window; let u = null != (e = a.event) ? e : null == (n = a.parent) ? void 0 : n.event, d = null; Jr[i] && (d = Ie(o, Jr[i], l, !0)); const h = Ie(o, i, s, !0), f = Ie(o, i, (e => { e !== u ? c(e) : u = void 0 })); let p = []; return "ontouchstart" in o.documentElement && (p = [].slice.call(o.body.children).map((e => Ie(e, "mousemove", Xr)))), () => { null == d || d(), h(), f(), p.forEach((e => e())) } }), [t, r, i, s, l, c]) }, ei = () => { }; const ti = function (t, n) { let { disabled: r, clickTrigger: i } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const o = n || ei; Zr(t, o, { disabled: r, clickTrigger: i }); const a = Oe((e => { ot(e) && o(e) })); (0, e.useEffect)((() => { if (r || null == t) return; const e = _e(Gr(t)); let n = (e.defaultView || window).event; const i = Ie(e, "keyup", (e => { e !== n ? a(e) : n = void 0 })); return () => { i() } }), [t, r, a]) }; function ni() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return Array.isArray(e) ? e : Object.keys(e).map((t => (e[t].name = t, e[t]))) } function ri(e) { let { enabled: t, enableEvents: n, placement: r, flip: i, offset: o, fixed: a, containerPadding: s, arrowElement: l, popperConfig: c = {} } = e; var u, d, h, f, p; const g = function (e) { const t = {}; return Array.isArray(e) ? (null == e || e.forEach((e => { t[e.name] = e })), t) : e || t }(c.modifiers); return Object.assign({}, c, { placement: r, enabled: t, strategy: a ? "fixed" : c.strategy, modifiers: ni(Object.assign({}, g, { eventListeners: { enabled: n, options: null == (u = g.eventListeners) ? void 0 : u.options }, preventOverflow: Object.assign({}, g.preventOverflow, { options: s ? Object.assign({ padding: s }, null == (d = g.preventOverflow) ? void 0 : d.options) : null == (h = g.preventOverflow) ? void 0 : h.options }), offset: { options: Object.assign({ offset: o }, null == (f = g.offset) ? void 0 : f.options) }, arrow: Object.assign({}, g.arrow, { enabled: !!l, options: Object.assign({}, null == (p = g.arrow) ? void 0 : p.options, { element: l }) }), flip: Object.assign({ enabled: !!i }, g.flip) })) }) } const ii = e.forwardRef(((t, n) => { const { flip: r, offset: i, placement: o, containerPadding: a, popperConfig: s = {}, transition: l, runTransition: c } = t, [u, d] = Ee(), [h, f] = Ee(), p = Ne(d, n), g = Ze(t.container), m = Ze(t.target), [b, v] = (0, e.useState)(!t.show), y = Qr(m, u, ri({ placement: o, enableEvents: !!t.show, containerPadding: a || 5, flip: r, offset: i, arrowElement: h, popperConfig: s })); t.show && b && v(!1); const x = t.show || !b; if (ti(u, t.onHide, { disabled: !t.rootClose || t.rootCloseDisabled, clickTrigger: t.rootCloseEvent }), !x) return null; const { onExit: w, onExiting: _, onEnter: k, onEntering: S, onEntered: C } = t; let E = t.children(Object.assign({}, y.attributes.popper, { style: y.styles.popper, ref: p }), { popper: y, placement: o, show: !!t.show, arrowProps: Object.assign({}, y.attributes.arrow, { style: y.styles.arrow, ref: f }) }); return E = it(l, c, { in: !!t.show, appear: !0, mountOnEnter: !0, unmountOnExit: !0, children: E, onExit: w, onExiting: _, onExited: function () { v(!0), t.onExited && t.onExited(...arguments) }, onEnter: k, onEntering: S, onEntered: C }), g ? He.createPortal(E, g) : null })); ii.displayName = "Overlay"; const oi = ii, ai = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = h(r, "popover-header"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); ai.displayName = "PopoverHeader"; const si = ai, li = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = h(r, "popover-body"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); li.displayName = "PopoverBody"; const ci = li; e.Component; function ui(e, t) { let n = e; return "left" === e ? n = t ? "end" : "start" : "right" === e && (n = t ? "start" : "end"), n } function di() { return { position: arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "absolute", top: "0", left: "0", opacity: "0", pointerEvents: "none" } } const hi = e.forwardRef(((e, t) => { let { bsPrefix: n, placement: r = "right", className: i, style: s, children: l, body: c, arrowProps: u, hasDoneInitialMeasure: d, popper: f, show: p, ...m } = e; const b = h(n, "popover"), v = g(), [y] = (null == r ? void 0 : r.split("-")) || [], x = ui(y, v); let w = s; return p && !d && (w = { ...s, ...di(null == f ? void 0 : f.strategy) }), (0, a.jsxs)("div", { ref: t, role: "tooltip", style: w, "x-placement": y, className: o()(i, b, y && "bs-popover-".concat(x)), ...m, children: [(0, a.jsx)("div", { className: "popover-arrow", ...u }), c ? (0, a.jsx)(ci, { children: l }) : l] }) })), fi = Object.assign(hi, { Header: si, Body: ci, POPPER_OFFSET: [0, 8] }), pi = e.forwardRef(((e, t) => { let { bsPrefix: n, placement: r = "right", className: i, style: s, children: l, arrowProps: c, hasDoneInitialMeasure: u, popper: d, show: f, ...p } = e; n = h(n, "tooltip"); const m = g(), [b] = (null == r ? void 0 : r.split("-")) || [], v = ui(b, m); let y = s; return f && !u && (y = { ...s, ...di(null == d ? void 0 : d.strategy) }), (0, a.jsxs)("div", { ref: t, style: y, role: "tooltip", "x-placement": b, className: o()(i, n, "bs-tooltip-".concat(v)), ...p, children: [(0, a.jsx)("div", { className: "tooltip-arrow", ...c }), (0, a.jsx)("div", { className: "".concat(n, "-inner"), children: l })] }) })); pi.displayName = "Tooltip"; const gi = Object.assign(pi, { TOOLTIP_OFFSET: [0, 6] }); const mi = e.forwardRef(((t, n) => { let { children: r, transition: i = Vt, popperConfig: s = {}, rootClose: l = !1, placement: c = "top", show: u = !1, ...d } = t; const f = (0, e.useRef)({}), [p, g] = (0, e.useState)(null), [m, b] = function (t) { const n = (0, e.useRef)(null), r = h(void 0, "popover"), i = h(void 0, "tooltip"), o = (0, e.useMemo)((() => ({ name: "offset", options: { offset: () => { if (t) return t; if (n.current) { if (dt(n.current, r)) return fi.POPPER_OFFSET; if (dt(n.current, i)) return gi.TOOLTIP_OFFSET } return [0, 0] } } })), [t, r, i]); return [n, [o]] }(d.offset), v = Ne(n, m), y = !0 === i ? Vt : i || void 0, x = Oe((e => { g(e), null == s || null == s.onFirstUpdate || s.onFirstUpdate(e) })); return tt((() => { p && d.target && (null == f.current.scheduleUpdate || f.current.scheduleUpdate()) }), [p, d.target]), (0, e.useEffect)((() => { u || g(null) }), [u]), (0, a.jsx)(oi, { ...d, ref: v, popperConfig: { ...s, modifiers: b.concat(s.modifiers || []), onFirstUpdate: x }, transition: y, rootClose: l, placement: c, show: u, children: (t, n) => { let { arrowProps: a, popper: l, show: c } = n; var u, d; !function (e, t) { const { ref: n } = e, { ref: r } = t; e.ref = n.__wrapped || (n.__wrapped = e => n(zt(e))), t.ref = r.__wrapped || (r.__wrapped = e => r(zt(e))) }(t, a); const h = null == l ? void 0 : l.placement, g = Object.assign(f.current, { state: null == l ? void 0 : l.state, scheduleUpdate: null == l ? void 0 : l.update, placement: h, outOfBoundaries: (null == l || null == (u = l.state) || null == (d = u.modifiersData.hide) ? void 0 : d.isReferenceHidden) || !1, strategy: s.strategy }), m = !!p; return "function" === typeof r ? r({ ...t, placement: h, show: c, ...!i && c && { className: "show" }, popper: g, arrowProps: a, hasDoneInitialMeasure: m }) : e.cloneElement(r, { ...t, placement: h, arrowProps: a, popper: g, hasDoneInitialMeasure: m, className: o()(r.props.className, !i && c && "show"), style: { ...r.props.style, ...t.style } }) } }) })); mi.displayName = "Overlay"; const bi = mi; function vi(e, t, n) { const [r] = t, i = r.currentTarget, o = r.relatedTarget || r.nativeEvent[n]; o && o === i || Ve(i, o) || e(...t) } y().oneOf(["click", "hover", "focus"]); const yi = t => { let { trigger: n = ["hover", "focus"], overlay: r, children: i, popperConfig: o = {}, show: s, defaultShow: l = !1, onToggle: c, delay: u, placement: d, flip: h = d && -1 !== d.indexOf("auto"), ...f } = t; const p = (0, e.useRef)(null), g = Ne(p, i.ref), m = pn(), b = (0, e.useRef)(""), [v, y] = vn(s, l, c), x = function (e) { return e && "object" === typeof e ? e : { show: e, hide: e } }(u), { onFocus: w, onBlur: _, onClick: k } = "function" !== typeof i ? e.Children.only(i).props : {}, S = (0, e.useCallback)((() => { m.clear(), b.current = "show", x.show ? m.set((() => { "show" === b.current && y(!0) }), x.show) : y(!0) }), [x.show, y, m]), C = (0, e.useCallback)((() => { m.clear(), b.current = "hide", x.hide ? m.set((() => { "hide" === b.current && y(!1) }), x.hide) : y(!1) }), [x.hide, y, m]), E = (0, e.useCallback)((function () { S(), null == w || w(...arguments) }), [S, w]), M = (0, e.useCallback)((function () { C(), null == _ || _(...arguments) }), [C, _]), O = (0, e.useCallback)((function () { y(!v), null == k || k(...arguments) }), [k, y, v]), P = (0, e.useCallback)((function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; vi(S, t, "fromElement") }), [S]), N = (0, e.useCallback)((function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; vi(C, t, "toElement") }), [C]), T = null == n ? [] : [].concat(n), j = { ref: e => { g(zt(e)) } }; return -1 !== T.indexOf("click") && (j.onClick = O), -1 !== T.indexOf("focus") && (j.onFocus = E, j.onBlur = M), -1 !== T.indexOf("hover") && (j.onMouseOver = P, j.onMouseOut = N), (0, a.jsxs)(a.Fragment, { children: ["function" === typeof i ? i(j) : (0, e.cloneElement)(i, j), (0, a.jsx)(bi, { ...f, show: v, onHide: C, flip: h, placement: d, popperConfig: o, target: p.current, children: r })] }) }, xi = e => { let { value: t, children: n, href: r } = e; return (0, a.jsx)("a", { href: r, target: "_blank", rel: "noopener noreferrer", style: { textDecoration: "none" }, children: n }) }, wi = e => (0, a.jsxs)("p", { className: "m-0", children: [(0, a.jsxs)("ul", { className: "dashed ps-3", children: [(0, a.jsx)("li", { children: (0, a.jsx)(yi, { placement: "right", overlay: (0, a.jsx)(gi, { style: { fontFamily: "Josefin Slab", lineHeight: "120%" }, children: (0, a.jsx)("div", { className: "p-2", children: "Enter dept names without spaces. e.g. Input 'CS' instead of 'C S'." }) }), children: (0, a.jsxs)("span", { children: [(0, a.jsx)("u", { children: "A Department" }), ": ", (0, a.jsx)("b", { children: "ECE" })] }) }, "right") }), (0, a.jsxs)("li", { children: ["A Course: ", (0, a.jsx)("b", { children: "ECE 360C" })] }), (0, a.jsxs)("li", { children: ["A Professor: ", (0, a.jsx)("b", { children: "David Soloveichik" })] }), (0, a.jsxs)("li", { children: ["A Professor's Course: ", (0, a.jsx)("b", { children: "ECE 360C Soloveichik" })] }), (0, a.jsxs)("li", { children: ["A Specific Semester: ", (0, a.jsx)("b", { children: "ECE 360C Fall 2022" })] }), (0, a.jsxs)("li", { children: ["Everything: ", (0, a.jsx)("b", { children: "ECE 360C Soloveichik Fall 2022" })] })] }), e && (0, a.jsxs)(a.Fragment, { children: [(0, a.jsx)("br", {}), 'Click the "Info" on the top right for more about this site.'] })] }), _i = e => (0, a.jsx)(dn, { ...e, size: "md", "aria-labelledby": "contained-modal-title-vcenter", centered: !0, children: (0, a.jsxs)("div", { className: "px-2 pb-1 pt-2", children: [(0, a.jsx)(dn.Header, { closeButton: !0, children: (0, a.jsx)(dn.Title, { id: "contained-modal-title-vcenter", children: "UT Grades+" }) }), (0, a.jsxs)(dn.Body, { children: [(0, a.jsx)("h5", { children: "Acknowledgements" }), (0, a.jsxs)("p", { className: "m-0", children: [(0, a.jsxs)("ul", { className: "dashed ps-3", children: [(0, a.jsxs)("li", { children: ["Built by ", (0, a.jsx)(xi, { href: "https://jeffersonyu1.github.io/", children: "Jefferson Yu" })] }), (0, a.jsxs)("li", { children: ["Designed by ", (0, a.jsx)(xi, { href: "https://www.linkedin.com/in/stephaniewangyh/", children: "Stephanie Wang" })] }), (0, a.jsxs)("li", { children: ["Inspired by ", (0, a.jsx)(xi, { href: "https://utcatalyst.org/grade-distributions", children: "Catalyst" }), ", ", (0, a.jsx)(xi, { href: "https://derec4.github.io/ut-grade-distribution-viewer/", children: "Distribution Viewer" }), ", and ", (0, a.jsx)(xi, { href: "https://utdgrades.com/", children: "UTD Grades" })] }), (0, a.jsxs)("li", { children: ["Favicon from ", (0, a.jsx)(xi, { href: "https://commons.wikimedia.org/wiki/File:Hookem_hand.svg", children: "Wikimedia Commons" })] }), (0, a.jsx)("li", { children: (0, a.jsx)("b", { children: (0, a.jsx)(xi, { href: "https://docs.google.com/forms/d/e/1FAIpQLServLSVFod4e3yzx7m4KBwZrdEed1lawHgK39p4qyLn6ttcRQ/viewform?usp=sf_link", children: "Send your feedback and report bugs here." }) }) }), (0, a.jsx)("li", { children: (0, a.jsxs)("b", { children: ["Enjoying the site? ", (0, a.jsx)(xi, { href: "https://www.paypal.com/donate/?business=W8XQ2L48JH4PC&no_recurring=0&item_name=Help+us+keep+UT+Grades%2B+alive%21&currency_code=USD", children: "Please help us keep it running!" })] }) })] }), (0, a.jsx)("br", {})] }), (0, a.jsx)("h5", { children: "What Can I Search?" }), wi(!1)] })] }) }), ki = e => (0, a.jsx)(dn, { ...e, size: "md", "aria-labelledby": "contained-modal-title-vcenter", centered: !0, children: (0, a.jsxs)("div", { className: "px-2 pb-1 pt-2", children: [(0, a.jsx)(dn.Header, { closeButton: !0, children: (0, a.jsx)(dn.Title, { id: "contained-modal-title-vcenter", children: "What Can I Search?" }) }), (0, a.jsx)(dn.Body, { children: wi(!0) })] }) }), Si = ["ECE 312 Gligoric Spring 2022", "ECE 360C Fall 2022 Soloveichik", "PSY 420M Alexander Fall 2022"], Ci = t => { let { hasResults: n, onSearch: r, searchQuery: i, setSearchQuery: o } = t; const s = () => Si[Math.floor(99 * Math.random()) % Si.length], l = (0, e.useRef)(null), [c, u] = (0, e.useState)(""), [d, h] = (0, e.useState)("Search; e.g. ".concat(s())), [f, p] = (0, e.useState)(!1); return (0, e.useEffect)((() => { u(i || "") }), [i]), (0, a.jsxs)(ee, { onSubmit: e => { e.preventDefault(), h("Search; e.g. ".concat(s())), o(c), l.current && l.current.blur() }, className: "d-flex justify-content-center", children: [(0, a.jsx)(D, { type: "search", placeholder: d, className: "me-2 minimal-search-bar ".concat(n ? "searchbar-full" : "searchbar-cover"), "aria-label": "Search", value: c, onChange: e => u(e.target.value), ref: l }), (0, a.jsx)(ae, { variant: "outline-success", type: "submit", className: "me-2", children: (0, a.jsx)(de, {}) }), (0, a.jsx)(ae, { variant: "outline-primary", onClick: () => p(!0), children: (0, a.jsx)(me, {}) }), (0, a.jsx)(ki, { show: f, onHide: () => p(!1) })] }) }, Ei = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; return null != e ? String(e) : t || null }, Mi = e.createContext(null), Oi = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, as: i, ...s } = e; n = h(n, "navbar-brand"); const l = i || (s.href ? "a" : "span"); return (0, a.jsx)(l, { ...s, ref: t, className: o()(r, n) }) })); Oi.displayName = "NavbarBrand"; const Pi = Oi; const Ni = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return t.filter((e => null != e)).reduce(((e, t) => { if ("function" !== typeof t) throw new Error("Invalid Argument Type, must only provide functions, undefined, or null."); return null === e ? t : function () { for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i]; e.apply(this, r), t.apply(this, r) } }), null) }, Ti = { height: ["marginTop", "marginBottom"], width: ["marginLeft", "marginRight"] }; function ji(e, t) { const n = t["offset".concat(e[0].toUpperCase()).concat(e.slice(1))], r = Ti[e]; return n + parseInt(ze(t, r[0]), 10) + parseInt(ze(t, r[1]), 10) } const Di = { [Mt]: "collapse", [Nt]: "collapsing", [Ot]: "collapsing", [Pt]: "collapse show" }, Ri = e.forwardRef(((t, n) => { let { onEnter: r, onEntering: i, onEntered: s, onExit: l, onExiting: c, className: u, children: d, dimension: h = "height", in: f = !1, timeout: p = 300, mountOnEnter: g = !1, unmountOnExit: m = !1, appear: b = !1, getDimensionValue: v = ji, ...y } = t; const x = "function" === typeof h ? h() : h, w = (0, e.useMemo)((() => Ni((e => { e.style[x] = "0" }), r)), [x, r]), _ = (0, e.useMemo)((() => Ni((e => { const t = "scroll".concat(x[0].toUpperCase()).concat(x.slice(1)); e.style[x] = "".concat(e[t], "px") }), i)), [x, i]), k = (0, e.useMemo)((() => Ni((e => { e.style[x] = null }), s)), [x, s]), S = (0, e.useMemo)((() => Ni((e => { e.style[x] = "".concat(v(x, e), "px"), At(e) }), l)), [l, v, x]), C = (0, e.useMemo)((() => Ni((e => { e.style[x] = null }), c)), [x, c]); return (0, a.jsx)(Ft, { ref: n, addEndListener: Lt, ...y, "aria-expanded": y.role ? f : null, onEnter: w, onEntering: _, onEntered: k, onExit: S, onExiting: C, childRef: d.ref, in: f, timeout: p, mountOnEnter: g, unmountOnExit: m, appear: b, children: (t, n) => e.cloneElement(d, { ...n, className: o()(u, d.props.className, Di[t], "width" === x && "collapse-horizontal") }) }) })), Li = e.createContext(null); Li.displayName = "NavbarContext"; const Ai = Li, zi = e.forwardRef(((t, n) => { let { children: r, bsPrefix: i, ...o } = t; i = h(i, "navbar-collapse"); const s = (0, e.useContext)(Ai); return (0, a.jsx)(Ri, { in: !(!s || !s.expanded), ...o, children: (0, a.jsx)("div", { ref: n, className: i, children: r }) }) })); zi.displayName = "NavbarCollapse"; const Ii = zi, Fi = e.forwardRef(((t, n) => { let { bsPrefix: r, className: i, children: s, label: l = "Toggle navigation", as: c = "button", onClick: u, ...d } = t; r = h(r, "navbar-toggler"); const { onToggle: f, expanded: p } = (0, e.useContext)(Ai) || {}, g = Oe((e => { u && u(e), f && f() })); return "button" === c && (d.type = "button"), (0, a.jsx)(c, { ...d, ref: n, onClick: g, "aria-label": l, className: o()(i, r, !p && "collapsed"), children: s || (0, a.jsx)("span", { className: "".concat(r, "-icon") }) }) })); Fi.displayName = "NavbarToggle"; const Bi = Fi, Wi = new WeakMap, Vi = (e, t) => { if (!e || !t) return; const n = Wi.get(t) || new Map; Wi.set(t, n); let r = n.get(e); return r || (r = t.matchMedia(e), r.refCount = 0, n.set(r.media, r)), r }; function Hi(t) { let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "undefined" === typeof window ? void 0 : window; const r = Vi(t, n), [i, o] = (0, e.useState)((() => !!r && r.matches)); return tt((() => { let e = Vi(t, n); if (!e) return o(!1); let r = Wi.get(n); const i = () => { o(e.matches) }; return e.refCount++, e.addListener(i), i(), () => { e.removeListener(i), e.refCount--, e.refCount <= 0 && (null == r || r.delete(e.media)), e = void 0 } }), [t]), i } const Ui = function (t) { const n = Object.keys(t); function r(e, t) { return e === t ? t : e ? "".concat(e, " and ").concat(t) : t } function i(e) { const r = function (e) { return n[Math.min(n.indexOf(e) + 1, n.length - 1)] }(e); let i = t[r]; return i = "number" === typeof i ? "".concat(i - .2, "px") : "calc(".concat(i, " - 0.2px)"), "(max-width: ".concat(i, ")") } return function (n, o, a) { let s; return "object" === typeof n ? (s = n, a = o, o = !0) : s = { [n]: o = o || !0 }, Hi((0, e.useMemo)((() => Object.entries(s).reduce(((e, n) => { let [o, a] = n; return "up" !== a && !0 !== a || (e = r(e, function (e) { let n = t[e]; return "number" === typeof n && (n = "".concat(n, "px")), "(min-width: ".concat(n, ")") }(o))), "down" !== a && !0 !== a || (e = r(e, i(o))), e }), "")), [JSON.stringify(s)]), a) } }({ xs: 0, sm: 576, md: 768, lg: 992, xl: 1200, xxl: 1400 }), $i = Ui, Yi = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = h(r, "offcanvas-body"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); Yi.displayName = "OffcanvasBody"; const qi = Yi, Ki = { [Ot]: "show", [Pt]: "show" }, Qi = e.forwardRef(((t, n) => { let { bsPrefix: r, className: i, children: s, in: l = !1, mountOnEnter: c = !1, unmountOnExit: u = !1, appear: d = !1, ...f } = t; return r = h(r, "offcanvas"), (0, a.jsx)(Ft, { ref: n, addEndListener: Lt, in: l, mountOnEnter: c, unmountOnExit: u, appear: d, ...f, childRef: s.ref, children: (t, n) => e.cloneElement(s, { ...n, className: o()(i, s.props.className, (t === Ot || t === Nt) && "".concat(r, "-toggling"), Ki[t]) }) }) })); Qi.displayName = "OffcanvasToggling"; const Xi = Qi, Gi = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, closeLabel: i = "Close", closeButton: s = !1, ...l } = e; return n = h(n, "offcanvas-header"), (0, a.jsx)(en, { ref: t, ...l, className: o()(r, n), closeLabel: i, closeButton: s }) })); Gi.displayName = "OffcanvasHeader"; const Ji = Gi, Zi = rn("h5"), eo = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = Zi, ...s } = e; return r = h(r, "offcanvas-title"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); eo.displayName = "OffcanvasTitle"; const to = eo; function no(e) { return (0, a.jsx)(Xi, { ...e }) } function ro(e) { return (0, a.jsx)(Vt, { ...e }) } const io = e.forwardRef(((t, n) => { let { bsPrefix: r, className: i, children: s, "aria-labelledby": l, placement: c = "start", responsive: u, show: d = !1, backdrop: f = !0, keyboard: p = !0, scroll: g = !1, onEscapeKeyDown: m, onShow: b, onHide: v, container: y, autoFocus: x = !0, enforceFocus: w = !0, restoreFocus: _ = !0, restoreFocusOptions: k, onEntered: S, onExit: C, onExiting: E, onEnter: M, onEntering: O, onExited: P, backdropClassName: N, manager: T, renderStaticNode: j = !1, ...D } = t; const R = (0, e.useRef)(); r = h(r, "offcanvas"); const { onToggle: L } = (0, e.useContext)(Ai) || {}, [A, z] = (0, e.useState)(!1), I = $i(u || "xs", "up"); (0, e.useEffect)((() => { z(u ? d && !I : d) }), [d, u, I]); const F = Oe((() => { null == L || L(), null == v || v() })), B = (0, e.useMemo)((() => ({ onHide: F })), [F]); const W = (0, e.useCallback)((e => (0, a.jsx)("div", { ...e, className: o()("".concat(r, "-backdrop"), N) })), [N, r]), V = e => (0, a.jsx)("div", { ...e, ...D, className: o()(i, u ? "".concat(r, "-").concat(u) : r, "".concat(r, "-").concat(c)), "aria-labelledby": l, children: s }); return (0, a.jsxs)(a.Fragment, { children: [!A && (u || j) && V({}), (0, a.jsx)($t.Provider, { value: B, children: (0, a.jsx)(ut, { show: A, ref: n, backdrop: f, container: y, keyboard: p, autoFocus: x, enforceFocus: w && !g, restoreFocus: _, restoreFocusOptions: k, onEscapeKeyDown: m, onShow: b, onHide: F, onEnter: function (e) { e && (e.style.visibility = "visible"); for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; null == M || M(e, ...n) }, onEntering: O, onEntered: S, onExit: C, onExiting: E, onExited: function (e) { e && (e.style.visibility = ""); for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; null == P || P(...n) }, manager: T || (g ? (R.current || (R.current = new wt({ handleContainerOverflow: !1 })), R.current) : xt()), transition: no, backdropTransition: ro, renderBackdrop: W, renderDialog: V }) })] }) })); io.displayName = "Offcanvas"; const oo = Object.assign(io, { Body: qi, Header: Ji, Title: to }), ao = e.forwardRef(((t, n) => { const r = (0, e.useContext)(Ai); return (0, a.jsx)(oo, { ref: n, show: !(null == r || !r.expanded), ...t, renderStaticNode: !0 }) })); ao.displayName = "NavbarOffcanvas"; const so = ao, lo = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "span", ...s } = e; return r = h(r, "navbar-text"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); lo.displayName = "NavbarText"; const co = lo, uo = e.forwardRef(((t, n) => { const { bsPrefix: r, expand: i = !0, variant: s = "light", bg: l, fixed: c, sticky: u, className: d, as: f = "nav", expanded: p, onToggle: g, onSelect: m, collapseOnSelect: b = !1, ...v } = yn(t, { expanded: "onToggle" }), y = h(r, "navbar"), x = (0, e.useCallback)((function () { null == m || m(...arguments), b && p && (null == g || g(!1)) }), [m, b, p, g]); void 0 === v.role && "nav" !== f && (v.role = "navigation"); let w = "".concat(y, "-expand"); "string" === typeof i && (w = "".concat(w, "-").concat(i)); const _ = (0, e.useMemo)((() => ({ onToggle: () => null == g ? void 0 : g(!p), bsPrefix: y, expanded: !!p, expand: i })), [y, p, i, g]); return (0, a.jsx)(Ai.Provider, { value: _, children: (0, a.jsx)(Mi.Provider, { value: x, children: (0, a.jsx)(f, { ref: n, ...v, className: o()(d, y, i && w, s && "".concat(y, "-").concat(s), l && "bg-".concat(l), u && "sticky-".concat(u), c && "fixed-".concat(c)) }) }) }) })); uo.displayName = "Navbar"; const ho = Object.assign(uo, { Brand: Pi, Collapse: Ii, Offcanvas: so, Text: co, Toggle: Bi }); n(573); const fo = e.createContext(null); fo.displayName = "NavContext"; const po = fo, go = e.createContext(null), mo = ["as", "active", "eventKey"]; function bo(t) { let { key: n, onClick: r, active: i, id: o, role: a, disabled: s } = t; const l = (0, e.useContext)(Mi), c = (0, e.useContext)(po), u = (0, e.useContext)(go); let d = i; const h = { role: a }; if (c) { a || "tablist" !== c.role || (h.role = "tab"); const e = c.getControllerId(null != n ? n : null), t = c.getControlledId(null != n ? n : null); h[qe("event-key")] = n, h.id = e || o, d = null == i && null != n ? c.activeKey === n : i, !d && (null != u && u.unmountOnExit || null != u && u.mountOnEnter) || (h["aria-controls"] = t) } return "tab" === h.role && (h["aria-selected"] = d, d || (h.tabIndex = -1), s && (h.tabIndex = -1, h["aria-disabled"] = !0)), h.onClick = Oe((e => { s || (null == r || r(e), null != n && l && !e.isPropagationStopped() && l(n, e)) })), [h, { isActive: d }] } const vo = e.forwardRef(((e, t) => { let { as: n = ie, active: r, eventKey: i } = e, o = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, mo); const [s, l] = bo(Object.assign({ key: Ei(i, o.href), active: r }, o)); return s[qe("active")] = l.isActive, (0, a.jsx)(n, Object.assign({}, o, s, { ref: t })) })); vo.displayName = "NavItem"; const yo = vo, xo = ["as", "onSelect", "activeKey", "role", "onKeyDown"]; const wo = () => { }, _o = qe("event-key"), ko = e.forwardRef(((t, n) => { let { as: r = "div", onSelect: i, activeKey: o, role: s, onKeyDown: l } = t, c = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(t, xo); const u = function () { const [, t] = (0, e.useReducer)((e => !e), !1); return t }(), d = (0, e.useRef)(!1), h = (0, e.useContext)(Mi), f = (0, e.useContext)(go); let p, g; f && (s = s || "tablist", o = f.activeKey, p = f.getControlledId, g = f.getControllerId); const m = (0, e.useRef)(null), b = e => { const t = m.current; if (!t) return null; const n = ft(t, "[".concat(_o, "]:not([aria-disabled=true])")), r = t.querySelector("[aria-selected=true]"); if (!r || r !== document.activeElement) return null; const i = n.indexOf(r); if (-1 === i) return null; let o = i + e; return o >= n.length && (o = 0), o < 0 && (o = n.length - 1), n[o] }, v = (e, t) => { null != e && (null == i || i(e, t), null == h || h(e, t)) }; (0, e.useEffect)((() => { if (m.current && d.current) { const e = m.current.querySelector("[".concat(_o, "][aria-selected=true]")); null == e || e.focus() } d.current = !1 })); const y = Ne(n, m); return (0, a.jsx)(Mi.Provider, { value: v, children: (0, a.jsx)(po.Provider, { value: { role: s, activeKey: Ei(o), getControlledId: p || wo, getControllerId: g || wo }, children: (0, a.jsx)(r, Object.assign({}, c, { onKeyDown: e => { if (null == l || l(e), !f) return; let t; switch (e.key) { case "ArrowLeft": case "ArrowUp": t = b(-1); break; case "ArrowRight": case "ArrowDown": t = b(1); break; default: return }var n; t && (e.preventDefault(), v(t.dataset[(n = "EventKey", "".concat("rrUi").concat(n))] || null, e), d.current = !0, u()) }, ref: y, role: s })) }) }) })); ko.displayName = "Nav"; const So = Object.assign(ko, { Item: yo }), Co = e.createContext(null); Co.displayName = "CardHeaderContext"; const Eo = Co, Mo = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = h(r, "nav-item"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); Mo.displayName = "NavItem"; const Oo = Mo; new WeakMap; const Po = ["onKeyDown"]; const No = e.forwardRef(((e, t) => { let { onKeyDown: n } = e, r = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, Po); const [i] = ne(Object.assign({ tagName: "a" }, r)), o = Oe((e => { i.onKeyDown(e), null == n || n(e) })); return (s = r.href) && "#" !== s.trim() && "button" !== r.role ? (0, a.jsx)("a", Object.assign({ ref: t }, r, { onKeyDown: n })) : (0, a.jsx)("a", Object.assign({ ref: t }, r, i, { onKeyDown: o })); var s })); No.displayName = "Anchor"; const To = No, jo = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, as: i = To, active: s, eventKey: l, disabled: c = !1, ...u } = e; n = h(n, "nav-link"); const [d, f] = bo({ key: Ei(l, u.href), active: s, disabled: c, ...u }); return (0, a.jsx)(i, { ...u, ...d, ref: t, disabled: c, className: o()(r, n, c && "disabled", f.isActive && "active") }) })); jo.displayName = "NavLink"; const Do = jo, Ro = e.forwardRef(((t, n) => { const { as: r = "div", bsPrefix: i, variant: s, fill: l = !1, justify: c = !1, navbar: u, navbarScroll: d, className: f, activeKey: p, ...g } = yn(t, { activeKey: "onSelect" }), m = h(i, "nav"); let b, v, y = !1; const x = (0, e.useContext)(Ai), w = (0, e.useContext)(Eo); return x ? (b = x.bsPrefix, y = null == u || u) : w && ({ cardHeaderBsPrefix: v } = w), (0, a.jsx)(So, { as: r, ref: n, activeKey: p, className: o()(f, { [m]: !y, ["".concat(b, "-nav")]: y, ["".concat(b, "-nav-scroll")]: y && d, ["".concat(v, "-").concat(s)]: !!v, ["".concat(m, "-").concat(s)]: !!s, ["".concat(m, "-fill")]: l, ["".concat(m, "-justified")]: c }), ...g }) })); Ro.displayName = "Nav"; const Lo = Object.assign(Ro, { Item: Oo, Link: Do }); var Ao = ["color", "size", "title"]; function zo() { return zo = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, zo.apply(this, arguments) } function Io(e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } var Fo = (0, e.forwardRef)((function (t, n) { var r = t.color, i = t.size, o = t.title, a = Io(t, Ao); return e.createElement("svg", zo({ ref: n, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16", width: i, height: i, fill: r }, a), o ? e.createElement("title", null, o) : null, e.createElement("path", { d: "M8.707 1.5a1 1 0 0 0-1.414 0L.646 8.146a.5.5 0 0 0 .708.708L2 8.207V13.5A1.5 1.5 0 0 0 3.5 15h9a1.5 1.5 0 0 0 1.5-1.5V8.207l.646.647a.5.5 0 0 0 .708-.708L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.707 1.5ZM13 7.207V13.5a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5V7.207l5-5 5 5Z" })) })); Fo.propTypes = { color: y().string, size: y().oneOfType([y().string, y().number]), title: y().string }, Fo.defaultProps = { color: "currentColor", size: "1em", title: null }; const Bo = Fo; var Wo = ["color", "size", "title"]; function Vo() { return Vo = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Vo.apply(this, arguments) } function Ho(e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } var Uo = (0, e.forwardRef)((function (t, n) { var r = t.color, i = t.size, o = t.title, a = Ho(t, Wo); return e.createElement("svg", Vo({ ref: n, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16", width: i, height: i, fill: r }, a), o ? e.createElement("title", null, o) : null, e.createElement("path", { d: "M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z" }), e.createElement("path", { d: "m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z" })) })); Uo.propTypes = { color: y().string, size: y().oneOfType([y().string, y().number]), title: y().string }, Uo.defaultProps = { color: "currentColor", size: "1em", title: null }; const $o = Uo; var Yo = ["color", "size", "title"]; function qo() { return qo = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, qo.apply(this, arguments) } function Ko(e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } var Qo = (0, e.forwardRef)((function (t, n) { var r = t.color, i = t.size, o = t.title, a = Ko(t, Yo); return e.createElement("svg", qo({ ref: n, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16", width: i, height: i, fill: r }, a), o ? e.createElement("title", null, o) : null, e.createElement("path", { d: "M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278zM4.858 1.311A7.269 7.269 0 0 0 1.025 7.71c0 4.02 3.279 7.276 7.319 7.276a7.316 7.316 0 0 0 5.205-2.162c-.337.042-.68.063-1.029.063-4.61 0-8.343-3.714-8.343-8.29 0-1.167.242-2.278.681-3.286z" })) })); Qo.propTypes = { color: y().string, size: y().oneOfType([y().string, y().number]), title: y().string }, Qo.defaultProps = { color: "currentColor", size: "1em", title: null }; const Xo = Qo; var Go = ["color", "size", "title"]; function Jo() { return Jo = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Jo.apply(this, arguments) } function Zo(e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } var ea = (0, e.forwardRef)((function (t, n) { var r = t.color, i = t.size, o = t.title, a = Zo(t, Go); return e.createElement("svg", Jo({ ref: n, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16", width: i, height: i, fill: r }, a), o ? e.createElement("title", null, o) : null, e.createElement("path", { d: "M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z" })) })); ea.propTypes = { color: y().string, size: y().oneOfType([y().string, y().number]), title: y().string }, ea.defaultProps = { color: "currentColor", size: "1em", title: null }; const ta = ea, na = t => { let { hasSearchResults: n, theme: r, toggleTheme: i } = t; const [o, s] = (0, e.useState)(!1); return (0, a.jsxs)(a.Fragment, { children: [(0, a.jsx)(ho, { variant: "light", children: (0, a.jsxs)(b, { fluid: !0, children: [(0, a.jsx)(Lo, { className: "me-auto", children: (0, a.jsxs)(Lo.Link, { href: "/", className: "burnt-orange-hover", children: [(0, a.jsx)(Bo, { className: "".concat(n && "me-2") }), n && (0, a.jsx)("span", { className: "", style: { verticalAlign: "-0.19em", fontWeight: "bold", textTransform: "uppercase" }, children: "UT Grades+" })] }) }), (0, a.jsxs)(Lo, { children: [(0, a.jsx)(Lo.Link, { href: "#", onClick: () => s(!0), className: "blue-icon burnt-orange-hover", children: (0, a.jsx)($o, {}) }), (0, a.jsx)(Lo.Link, { href: "#", onClick: i, className: "burnt-orange-hover", children: "light" === r ? (0, a.jsx)(Xo, {}) : (0, a.jsx)(ta, {}) })] })] }) }), (0, a.jsx)(_i, { show: o, onHide: () => s(!1) })] }) }, ra = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, as: i = "div", ...s } = e; const l = h(n, "row"), c = f(), u = p(), d = "".concat(l, "-cols"), g = []; return c.forEach((e => { const t = s[e]; let n; delete s[e], null != t && "object" === typeof t ? ({ cols: n } = t) : n = t; const r = e !== u ? "-".concat(e) : ""; null != n && g.push("".concat(d).concat(r, "-").concat(n)) })), (0, a.jsx)(i, { ref: t, ...s, className: o()(r, l, ...g) }) })); ra.displayName = "Row"; const ia = ra, oa = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = h(r, "card-body"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); oa.displayName = "CardBody"; const aa = oa, sa = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = h(r, "card-footer"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); sa.displayName = "CardFooter"; const la = sa, ca = e.forwardRef(((t, n) => { let { bsPrefix: r, className: i, as: s = "div", ...l } = t; const c = h(r, "card-header"), u = (0, e.useMemo)((() => ({ cardHeaderBsPrefix: c })), [c]); return (0, a.jsx)(Eo.Provider, { value: u, children: (0, a.jsx)(s, { ref: n, ...l, className: o()(i, c) }) }) })); ca.displayName = "CardHeader"; const ua = ca, da = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, variant: i, as: s = "img", ...l } = e; const c = h(n, "card-img"); return (0, a.jsx)(s, { ref: t, className: o()(i ? "".concat(c, "-").concat(i) : c, r), ...l }) })); da.displayName = "CardImg"; const ha = da, fa = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "div", ...s } = e; return r = h(r, "card-img-overlay"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); fa.displayName = "CardImgOverlay"; const pa = fa, ga = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "a", ...s } = e; return r = h(r, "card-link"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); ga.displayName = "CardLink"; const ma = ga, ba = rn("h6"), va = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = ba, ...s } = e; return r = h(r, "card-subtitle"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); va.displayName = "CardSubtitle"; const ya = va, xa = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = "p", ...s } = e; return r = h(r, "card-text"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); xa.displayName = "CardText"; const wa = xa, _a = rn("h5"), ka = e.forwardRef(((e, t) => { let { className: n, bsPrefix: r, as: i = _a, ...s } = e; return r = h(r, "card-title"), (0, a.jsx)(i, { ref: t, className: o()(n, r), ...s }) })); ka.displayName = "CardTitle"; const Sa = ka, Ca = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, bg: i, text: s, border: l, body: c = !1, children: u, as: d = "div", ...f } = e; const p = h(n, "card"); return (0, a.jsx)(d, { ref: t, ...f, className: o()(r, p, i && "bg-".concat(i), s && "text-".concat(s), l && "border-".concat(l)), children: c ? (0, a.jsx)(aa, { children: u }) : u }) })); Ca.displayName = "Card"; const Ea = Object.assign(Ca, { Img: ha, Title: Sa, Subtitle: ya, Body: aa, Link: ma, Text: wa, Header: ua, Footer: la, ImgOverlay: pa }), Ma = e.forwardRef(((e, t) => { let { bsPrefix: n, className: r, striped: i, bordered: s, borderless: l, hover: c, size: u, variant: d, responsive: f, ...p } = e; const g = h(n, "table"), m = o()(r, g, d && "".concat(g, "-").concat(d), u && "".concat(g, "-").concat(u), i && "".concat(g, "-").concat("string" === typeof i ? "striped-".concat(i) : "striped"), s && "".concat(g, "-bordered"), l && "".concat(g, "-borderless"), c && "".concat(g, "-hover")), b = (0, a.jsx)("table", { ...p, className: m, ref: t }); if (f) { let e = "".concat(g, "-responsive"); return "string" === typeof f && (e = "".concat(e, "-").concat(f)), (0, a.jsx)("div", { className: e, children: b }) } return b })), Oa = Ma; function Pa() { return Pa = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Pa.apply(this, arguments) } var Na = e.createElement("svg", { viewBox: "-2 -5 14 20", height: "100%", width: "100%", style: { position: "absolute", top: 0 } }, e.createElement("path", { d: "M9.9 2.12L7.78 0 4.95 2.828 2.12 0 0 2.12l2.83 2.83L0 7.776 2.123 9.9 4.95 7.07 7.78 9.9 9.9 7.776 7.072 4.95 9.9 2.12", fill: "#fff", fillRule: "evenodd" })), Ta = e.createElement("svg", { height: "100%", width: "100%", viewBox: "-2 -5 17 21", style: { position: "absolute", top: 0 } }, e.createElement("path", { d: "M11.264 0L5.26 6.004 2.103 2.847 0 4.95l5.26 5.26 8.108-8.107L11.264 0", fill: "#fff", fillRule: "evenodd" })); function ja(e) { if (7 === e.length) return e; for (var t = "#", n = 1; n < 4; n += 1)t += e[n] + e[n]; return t } function Da(e, t, n, r, i) { return function (e, t, n, r, i) { var o = (e - n) / (t - n); if (0 === o) return r; if (1 === o) return i; for (var a = "#", s = 1; s < 6; s += 2) { var l = parseInt(r.substr(s, 2), 16), c = parseInt(i.substr(s, 2), 16), u = Math.round((1 - o) * l + o * c).toString(16); 1 === u.length && (u = "0" + u), a += u } return a }(e, t, n, ja(r), ja(i)) } var Ra = function (t) { function n(e) { t.call(this, e); var n = e.height, r = e.width, i = e.checked; this.t = e.handleDiameter || n - 2, this.i = Math.max(r - n, r - (n + this.t) / 2), this.o = Math.max(0, (n - this.t) / 2), this.state = { h: i ? this.i : this.o }, this.l = 0, this.u = 0, this.p = this.p.bind(this), this.v = this.v.bind(this), this.g = this.g.bind(this), this.k = this.k.bind(this), this.m = this.m.bind(this), this.M = this.M.bind(this), this.T = this.T.bind(this), this.$ = this.$.bind(this), this.C = this.C.bind(this), this.D = this.D.bind(this), this.O = this.O.bind(this), this.S = this.S.bind(this) } return t && (n.__proto__ = t), (n.prototype = Object.create(t && t.prototype)).constructor = n, n.prototype.componentDidMount = function () { this.W = !0 }, n.prototype.componentDidUpdate = function (e) { e.checked !== this.props.checked && this.setState({ h: this.props.checked ? this.i : this.o }) }, n.prototype.componentWillUnmount = function () { this.W = !1 }, n.prototype.I = function (e) { this.H.focus(), this.setState({ R: e, j: !0, B: Date.now() }) }, n.prototype.L = function (e) { var t = this.state, n = t.R, r = t.h, i = (this.props.checked ? this.i : this.o) + e - n; t.N || e === n || this.setState({ N: !0 }); var o = Math.min(this.i, Math.max(this.o, i)); o !== r && this.setState({ h: o }) }, n.prototype.U = function (e) { var t = this.state, n = t.h, r = t.N, i = t.B, o = this.props.checked, a = (this.i + this.o) / 2; this.setState({ h: this.props.checked ? this.i : this.o }); var s = Date.now() - i; (!r || s < 250 || o && n <= a || !o && n >= a) && this.A(e), this.W && this.setState({ N: !1, j: !1 }), this.l = Date.now() }, n.prototype.p = function (e) { e.preventDefault(), "number" == typeof e.button && 0 !== e.button || (this.I(e.clientX), window.addEventListener("mousemove", this.v), window.addEventListener("mouseup", this.g)) }, n.prototype.v = function (e) { e.preventDefault(), this.L(e.clientX) }, n.prototype.g = function (e) { this.U(e), window.removeEventListener("mousemove", this.v), window.removeEventListener("mouseup", this.g) }, n.prototype.k = function (e) { this.X = null, this.I(e.touches[0].clientX) }, n.prototype.m = function (e) { this.L(e.touches[0].clientX) }, n.prototype.M = function (e) { e.preventDefault(), this.U(e) }, n.prototype.$ = function (e) { Date.now() - this.l > 50 && (this.A(e), Date.now() - this.u > 50 && this.W && this.setState({ j: !1 })) }, n.prototype.C = function () { this.u = Date.now() }, n.prototype.D = function () { this.setState({ j: !0 }) }, n.prototype.O = function () { this.setState({ j: !1 }) }, n.prototype.S = function (e) { this.H = e }, n.prototype.T = function (e) { e.preventDefault(), this.H.focus(), this.A(e), this.W && this.setState({ j: !1 }) }, n.prototype.A = function (e) { var t = this.props; (0, t.onChange)(!t.checked, e, t.id) }, n.prototype.render = function () { var t = this.props, n = t.checked, r = t.disabled, i = t.className, o = t.offColor, a = t.onColor, s = t.offHandleColor, l = t.onHandleColor, c = t.checkedIcon, u = t.uncheckedIcon, d = t.checkedHandleIcon, h = t.uncheckedHandleIcon, f = t.boxShadow, p = t.activeBoxShadow, g = t.height, m = t.width, b = t.borderRadius, v = function (e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && -1 === t.indexOf(r) && (n[r] = e[r]); return n }(t, ["checked", "disabled", "className", "offColor", "onColor", "offHandleColor", "onHandleColor", "checkedIcon", "uncheckedIcon", "checkedHandleIcon", "uncheckedHandleIcon", "boxShadow", "activeBoxShadow", "height", "width", "borderRadius", "handleDiameter"]), y = this.state, x = y.h, w = y.N, _ = y.j, k = { position: "relative", display: "inline-block", textAlign: "left", opacity: r ? .5 : 1, direction: "ltr", borderRadius: g / 2, WebkitTransition: "opacity 0.25s", MozTransition: "opacity 0.25s", transition: "opacity 0.25s", touchAction: "none", WebkitTapHighlightColor: "rgba(0, 0, 0, 0)", WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" }, S = { height: g, width: m, margin: Math.max(0, (this.t - g) / 2), position: "relative", background: Da(x, this.i, this.o, o, a), borderRadius: "number" == typeof b ? b : g / 2, cursor: r ? "default" : "pointer", WebkitTransition: w ? null : "background 0.25s", MozTransition: w ? null : "background 0.25s", transition: w ? null : "background 0.25s" }, C = { height: g, width: Math.min(1.5 * g, m - (this.t + g) / 2 + 1), position: "relative", opacity: (x - this.o) / (this.i - this.o), pointerEvents: "none", WebkitTransition: w ? null : "opacity 0.25s", MozTransition: w ? null : "opacity 0.25s", transition: w ? null : "opacity 0.25s" }, E = { height: g, width: Math.min(1.5 * g, m - (this.t + g) / 2 + 1), position: "absolute", opacity: 1 - (x - this.o) / (this.i - this.o), right: 0, top: 0, pointerEvents: "none", WebkitTransition: w ? null : "opacity 0.25s", MozTransition: w ? null : "opacity 0.25s", transition: w ? null : "opacity 0.25s" }, M = { height: this.t, width: this.t, background: Da(x, this.i, this.o, s, l), display: "inline-block", cursor: r ? "default" : "pointer", borderRadius: "number" == typeof b ? b - 1 : "50%", position: "absolute", transform: "translateX(" + x + "px)", top: Math.max(0, (g - this.t) / 2), outline: 0, boxShadow: _ ? p : f, border: 0, WebkitTransition: w ? null : "background-color 0.25s, transform 0.25s, box-shadow 0.15s", MozTransition: w ? null : "background-color 0.25s, transform 0.25s, box-shadow 0.15s", transition: w ? null : "background-color 0.25s, transform 0.25s, box-shadow 0.15s" }, O = { height: this.t, width: this.t, opacity: Math.max(2 * (1 - (x - this.o) / (this.i - this.o) - .5), 0), position: "absolute", left: 0, top: 0, pointerEvents: "none", WebkitTransition: w ? null : "opacity 0.25s", MozTransition: w ? null : "opacity 0.25s", transition: w ? null : "opacity 0.25s" }, P = { height: this.t, width: this.t, opacity: Math.max(2 * ((x - this.o) / (this.i - this.o) - .5), 0), position: "absolute", left: 0, top: 0, pointerEvents: "none", WebkitTransition: w ? null : "opacity 0.25s", MozTransition: w ? null : "opacity 0.25s", transition: w ? null : "opacity 0.25s" }; return e.createElement("div", { className: i, style: k }, e.createElement("div", { className: "react-switch-bg", style: S, onClick: r ? null : this.T, onMouseDown: function (e) { return e.preventDefault() } }, c && e.createElement("div", { style: C }, c), u && e.createElement("div", { style: E }, u)), e.createElement("div", { className: "react-switch-handle", style: M, onClick: function (e) { return e.preventDefault() }, onMouseDown: r ? null : this.p, onTouchStart: r ? null : this.k, onTouchMove: r ? null : this.m, onTouchEnd: r ? null : this.M, onTouchCancel: r ? null : this.O }, h && e.createElement("div", { style: O }, h), d && e.createElement("div", { style: P }, d)), e.createElement("input", Pa({}, { type: "checkbox", role: "switch", "aria-checked": n, checked: n, disabled: r, style: { border: 0, clip: "rect(0 0 0 0)", height: 1, margin: -1, overflow: "hidden", padding: 0, position: "absolute", width: 1 } }, v, { ref: this.S, onFocus: this.D, onBlur: this.O, onKeyUp: this.C, onChange: this.$ }))) }, n }(e.Component); Ra.defaultProps = { disabled: !1, offColor: "#888", onColor: "#080", offHandleColor: "#fff", onHandleColor: "#fff", uncheckedIcon: Na, checkedIcon: Ta, boxShadow: null, activeBoxShadow: "0 0 2px 3px #3bf", height: 28, width: 56 }; var La = ["color", "size", "title"]; function Aa() { return Aa = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Aa.apply(this, arguments) } function za(e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } var Ia = (0, e.forwardRef)((function (t, n) { var r = t.color, i = t.size, o = t.title, a = za(t, La); return e.createElement("svg", Aa({ ref: n, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16", width: i, height: i, fill: r }, a), o ? e.createElement("title", null, o) : null, e.createElement("path", { d: "M8 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6Zm2-3a2 2 0 1 1-4 0 2 2 0 0 1 4 0Zm4 8c0 1-1 1-1 1H3s-1 0-1-1 1-4 6-4 6 3 6 4Zm-1-.004c-.001-.246-.154-.986-.832-1.664C11.516 10.68 10.289 10 8 10c-2.29 0-3.516.68-4.168 1.332-.678.678-.83 1.418-.832 1.664h10Z" })) })); Ia.propTypes = { color: y().string, size: y().oneOfType([y().string, y().number]), title: y().string }, Ia.defaultProps = { color: "currentColor", size: "1em", title: null }; const Fa = Ia; function Ba() { return Ba = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Ba.apply(this, arguments) } var Wa; !function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" }(Wa || (Wa = {})); const Va = "popstate"; function Ha(e, t) { if (!1 === e || null === e || "undefined" === typeof e) throw new Error(t) } function Ua(e, t) { if (!e) { "undefined" !== typeof console && console.warn(t); try { throw new Error(t) } catch (Da) { } } } function $a(e, t) { return { usr: e.state, key: e.key, idx: t } } function Ya(e, t, n, r) { return void 0 === n && (n = null), Ba({ pathname: "string" === typeof e ? e : e.pathname, search: "", hash: "" }, "string" === typeof t ? Ka(t) : t, { state: n, key: t && t.key || r || Math.random().toString(36).substr(2, 8) }) } function qa(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t } function Ka(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } function Qa(e, t, n, r) { void 0 === r && (r = {}); let { window: i = document.defaultView, v5Compat: o = !1 } = r, a = i.history, s = Wa.Pop, l = null, c = u(); function u() { return (a.state || { idx: null }).idx } function d() { s = Wa.Pop; let e = u(), t = null == e ? null : e - c; c = e, l && l({ action: s, location: f.location, delta: t }) } function h(e) { let t = "null" !== i.location.origin ? i.location.origin : i.location.href, n = "string" === typeof e ? e : qa(e); return Ha(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t) } null == c && (c = 0, a.replaceState(Ba({}, a.state, { idx: c }), "")); let f = { get action() { return s }, get location() { return e(i, a) }, listen(e) { if (l) throw new Error("A history only accepts one active listener"); return i.addEventListener(Va, d), l = e, () => { i.removeEventListener(Va, d), l = null } }, createHref: e => t(i, e), createURL: h, encodeLocation(e) { let t = h(e); return { pathname: t.pathname, search: t.search, hash: t.hash } }, push: function (e, t) { s = Wa.Push; let r = Ya(f.location, e, t); n && n(r, e), c = u() + 1; let d = $a(r, c), h = f.createHref(r); try { a.pushState(d, "", h) } catch (p) { if (p instanceof DOMException && "DataCloneError" === p.name) throw p; i.location.assign(h) } o && l && l({ action: s, location: f.location, delta: 1 }) }, replace: function (e, t) { s = Wa.Replace; let r = Ya(f.location, e, t); n && n(r, e), c = u(); let i = $a(r, c), d = f.createHref(r); a.replaceState(i, "", d), o && l && l({ action: s, location: f.location, delta: 0 }) }, go: e => a.go(e) }; return f } var Xa; !function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" }(Xa || (Xa = {})); new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]); function Ga(e, t, n) { void 0 === n && (n = "/"); let r = ds(("string" === typeof t ? Ka(t) : t).pathname || "/", n); if (null == r) return null; let i = Ja(e); !function (e) { e.sort(((e, t) => e.score !== t.score ? t.score - e.score : function (e, t) { let n = e.length === t.length && e.slice(0, -1).every(((e, n) => e === t[n])); return n ? e[e.length - 1] - t[t.length - 1] : 0 }(e.routesMeta.map((e => e.childrenIndex)), t.routesMeta.map((e => e.childrenIndex))))) }(i); let o = null; for (let a = 0; null == o && a < i.length; ++a)o = ls(i[a], us(r)); return o } function Ja(e, t, n, r) { void 0 === t && (t = []), void 0 === n && (n = []), void 0 === r && (r = ""); let i = (e, i, o) => { let a = { relativePath: void 0 === o ? e.path || "" : o, caseSensitive: !0 === e.caseSensitive, childrenIndex: i, route: e }; a.relativePath.startsWith("/") && (Ha(a.relativePath.startsWith(r), 'Absolute route path "' + a.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), a.relativePath = a.relativePath.slice(r.length)); let s = ms([r, a.relativePath]), l = n.concat(a); e.children && e.children.length > 0 && (Ha(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + s + '".'), Ja(e.children, t, l, s)), (null != e.path || e.index) && t.push({ path: s, score: ss(s, e.index), routesMeta: l }) }; return e.forEach(((e, t) => { var n; if ("" !== e.path && null != (n = e.path) && n.includes("?")) for (let r of Za(e.path)) i(e, t, r); else i(e, t) })), t } function Za(e) { let t = e.split("/"); if (0 === t.length) return []; let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, ""); if (0 === r.length) return i ? [o, ""] : [o]; let a = Za(r.join("/")), s = []; return s.push(...a.map((e => "" === e ? o : [o, e].join("/")))), i && s.push(...a), s.map((t => e.startsWith("/") && "" === t ? "/" : t)) } const es = /^:\w+$/, ts = 3, ns = 2, rs = 1, is = 10, os = -2, as = e => "*" === e; function ss(e, t) { let n = e.split("/"), r = n.length; return n.some(as) && (r += os), t && (r += ns), n.filter((e => !as(e))).reduce(((e, t) => e + (es.test(t) ? ts : "" === t ? rs : is)), r) } function ls(e, t) { let { routesMeta: n } = e, r = {}, i = "/", o = []; for (let a = 0; a < n.length; ++a) { let e = n[a], s = a === n.length - 1, l = "/" === i ? t : t.slice(i.length) || "/", c = cs({ path: e.relativePath, caseSensitive: e.caseSensitive, end: s }, l); if (!c) return null; Object.assign(r, c.params); let u = e.route; o.push({ params: r, pathname: ms([i, c.pathname]), pathnameBase: bs(ms([i, c.pathnameBase])), route: u }), "/" !== c.pathnameBase && (i = ms([i, c.pathnameBase])) } return o } function cs(e, t) { "string" === typeof e && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = function (e, t, n) { void 0 === t && (t = !1); void 0 === n && (n = !0); Ua("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".'); let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:(\w+)(\?)?/g, ((e, t, n) => (r.push({ paramName: t, isOptional: null != n }), n ? "/?([^\\/]+)?" : "/([^\\/]+)"))); e.endsWith("*") ? (r.push({ paramName: "*" }), i += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : "" !== e && "/" !== e && (i += "(?:(?=\\/|$))"); let o = new RegExp(i, t ? void 0 : "i"); return [o, r] }(e.path, e.caseSensitive, e.end), i = t.match(n); if (!i) return null; let o = i[0], a = o.replace(/(.)\/+$/, "$1"), s = i.slice(1), l = r.reduce(((e, t, n) => { let { paramName: r, isOptional: i } = t; if ("*" === r) { let e = s[n] || ""; a = o.slice(0, o.length - e.length).replace(/(.)\/+$/, "$1") } const l = s[n]; return e[r] = i && !l ? void 0 : function (e, t) { try { return decodeURIComponent(e) } catch (n) { return Ua(!1, 'The value for the URL param "' + t + '" will not be decoded because the string "' + e + '" is a malformed URL segment. This is probably due to a bad percent encoding (' + n + ")."), e } }(l || "", r), e }), {}); return { params: l, pathname: o, pathnameBase: a, pattern: e } } function us(e) { try { return decodeURI(e) } catch (t) { return Ua(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + ")."), e } } function ds(e, t) { if ("/" === t) return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && "/" !== r ? null : e.slice(n) || "/" } function hs(e, t, n, r) { return "Cannot include a '" + e + "' character in a manually specified `to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the `to." + n + '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.' } function fs(e) { return e.filter(((e, t) => 0 === t || e.route.path && e.route.path.length > 0)) } function ps(e, t) { let n = fs(e); return t ? n.map(((t, n) => n === e.length - 1 ? t.pathname : t.pathnameBase)) : n.map((e => e.pathnameBase)) } function gs(e, t, n, r) { let i; void 0 === r && (r = !1), "string" === typeof e ? i = Ka(e) : (i = Ba({}, e), Ha(!i.pathname || !i.pathname.includes("?"), hs("?", "pathname", "search", i)), Ha(!i.pathname || !i.pathname.includes("#"), hs("#", "pathname", "hash", i)), Ha(!i.search || !i.search.includes("#"), hs("#", "search", "hash", i))); let o, a = "" === e || "" === i.pathname, s = a ? "/" : i.pathname; if (null == s) o = n; else { let e = t.length - 1; if (!r && s.startsWith("..")) { let t = s.split("/"); for (; ".." === t[0];)t.shift(), e -= 1; i.pathname = t.join("/") } o = e >= 0 ? t[e] : "/" } let l = function (e, t) { void 0 === t && (t = "/"); let { pathname: n, search: r = "", hash: i = "" } = "string" === typeof e ? Ka(e) : e, o = n ? n.startsWith("/") ? n : function (e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach((e => { ".." === e ? n.length > 1 && n.pop() : "." !== e && n.push(e) })), n.length > 1 ? n.join("/") : "/" }(n, t) : t; return { pathname: o, search: vs(r), hash: ys(i) } }(i, o), c = s && "/" !== s && s.endsWith("/"), u = (a || "." === s) && n.endsWith("/"); return l.pathname.endsWith("/") || !c && !u || (l.pathname += "/"), l } const ms = e => e.join("/").replace(/\/\/+/g, "/"), bs = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), vs = e => e && "?" !== e ? e.startsWith("?") ? e : "?" + e : "", ys = e => e && "#" !== e ? e.startsWith("#") ? e : "#" + e : ""; Error; function xs(e) { return null != e && "number" === typeof e.status && "string" === typeof e.statusText && "boolean" === typeof e.internal && "data" in e } const ws = ["post", "put", "patch", "delete"], _s = (new Set(ws), ["get", ...ws]); new Set(_s), new Set([301, 302, 303, 307, 308]), new Set([307, 308]); Symbol("deferred"); function ks() { return ks = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, ks.apply(this, arguments) } const Ss = e.createContext(null); const Cs = e.createContext(null); const Es = e.createContext(null); const Ms = e.createContext(null); const Os = e.createContext({ outlet: null, matches: [], isDataRoute: !1 }); const Ps = e.createContext(null); function Ns() { return null != e.useContext(Ms) } function Ts() { return Ns() || Ha(!1), e.useContext(Ms).location } function js(t) { e.useContext(Es).static || e.useLayoutEffect(t) } function Ds() { let { isDataRoute: t } = e.useContext(Os); return t ? function () { let { router: t } = Vs(Bs.UseNavigateStable), n = Us(Ws.UseNavigateStable), r = e.useRef(!1); js((() => { r.current = !0 })); let i = e.useCallback((function (e, i) { void 0 === i && (i = {}), r.current && ("number" === typeof e ? t.navigate(e) : t.navigate(e, ks({ fromRouteId: n }, i))) }), [t, n]); return i }() : function () { Ns() || Ha(!1); let t = e.useContext(Ss), { basename: n, future: r, navigator: i } = e.useContext(Es), { matches: o } = e.useContext(Os), { pathname: a } = Ts(), s = JSON.stringify(ps(o, r.v7_relativeSplatPath)), l = e.useRef(!1); js((() => { l.current = !0 })); let c = e.useCallback((function (e, r) { if (void 0 === r && (r = {}), !l.current) return; if ("number" === typeof e) return void i.go(e); let o = gs(e, JSON.parse(s), a, "path" === r.relative); null == t && "/" !== n && (o.pathname = "/" === o.pathname ? n : ms([n, o.pathname])), (r.replace ? i.replace : i.push)(o, r.state, r) }), [n, i, s, a, t]); return c }() } function Rs(t, n, r, i) { Ns() || Ha(!1); let { navigator: o } = e.useContext(Es), { matches: a } = e.useContext(Os), s = a[a.length - 1], l = s ? s.params : {}, c = (s && s.pathname, s ? s.pathnameBase : "/"); s && s.route; let u, d = Ts(); if (n) { var h; let e = "string" === typeof n ? Ka(n) : n; "/" === c || (null == (h = e.pathname) ? void 0 : h.startsWith(c)) || Ha(!1), u = e } else u = d; let f = u.pathname || "/", p = Ga(t, { pathname: "/" === c ? f : f.slice(c.length) || "/" }); let g = Fs(p && p.map((e => Object.assign({}, e, { params: Object.assign({}, l, e.params), pathname: ms([c, o.encodeLocation ? o.encodeLocation(e.pathname).pathname : e.pathname]), pathnameBase: "/" === e.pathnameBase ? c : ms([c, o.encodeLocation ? o.encodeLocation(e.pathnameBase).pathname : e.pathnameBase]) }))), a, r, i); return n && g ? e.createElement(Ms.Provider, { value: { location: ks({ pathname: "/", search: "", hash: "", state: null, key: "default" }, u), navigationType: Wa.Pop } }, g) : g } function Ls() { let t = function () { var t; let n = e.useContext(Ps), r = Hs(Ws.UseRouteError), i = Us(Ws.UseRouteError); if (void 0 !== n) return n; return null == (t = r.errors) ? void 0 : t[i] }(), n = xs(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t), r = t instanceof Error ? t.stack : null, i = "rgba(200,200,200, 0.5)", o = { padding: "0.5rem", backgroundColor: i }; return e.createElement(e.Fragment, null, e.createElement("h2", null, "Unexpected Application Error!"), e.createElement("h3", { style: { fontStyle: "italic" } }, n), r ? e.createElement("pre", { style: o }, r) : null, null) } const As = e.createElement(Ls, null); class zs extends e.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: void 0 !== e.error ? e.error : t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { console.error("React Router caught the following error during render", e, t) } render() { return void 0 !== this.state.error ? e.createElement(Os.Provider, { value: this.props.routeContext }, e.createElement(Ps.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function Is(t) { let { routeContext: n, match: r, children: i } = t, o = e.useContext(Ss); return o && o.static && o.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = r.route.id), e.createElement(Os.Provider, { value: n }, i) } function Fs(t, n, r, i) { var o; if (void 0 === n && (n = []), void 0 === r && (r = null), void 0 === i && (i = null), null == t) { var a; if (null == (a = r) || !a.errors) return null; t = r.matches } let s = t, l = null == (o = r) ? void 0 : o.errors; if (null != l) { let e = s.findIndex((e => e.route.id && (null == l ? void 0 : l[e.route.id]))); e >= 0 || Ha(!1), s = s.slice(0, Math.min(s.length, e + 1)) } let c = !1, u = -1; if (r && i && i.v7_partialHydration) for (let e = 0; e < s.length; e++) { let t = s[e]; if ((t.route.HydrateFallback || t.route.hydrateFallbackElement) && (u = e), t.route.id) { let { loaderData: e, errors: n } = r, i = t.route.loader && void 0 === e[t.route.id] && (!n || void 0 === n[t.route.id]); if (t.route.lazy || i) { c = !0, s = u >= 0 ? s.slice(0, u + 1) : [s[0]]; break } } } return s.reduceRight(((t, i, o) => { let a, d = !1, h = null, f = null; var p; r && (a = l && i.route.id ? l[i.route.id] : void 0, h = i.route.errorElement || As, c && (u < 0 && 0 === o ? (p = "route-fallback", !1 || $s[p] || ($s[p] = !0), d = !0, f = null) : u === o && (d = !0, f = i.route.hydrateFallbackElement || null))); let g = n.concat(s.slice(0, o + 1)), m = () => { let n; return n = a ? h : d ? f : i.route.Component ? e.createElement(i.route.Component, null) : i.route.element ? i.route.element : t, e.createElement(Is, { match: i, routeContext: { outlet: t, matches: g, isDataRoute: null != r }, children: n }) }; return r && (i.route.ErrorBoundary || i.route.errorElement || 0 === o) ? e.createElement(zs, { location: r.location, revalidation: r.revalidation, component: h, error: a, children: m(), routeContext: { outlet: null, matches: g, isDataRoute: !0 } }) : m() }), null) } var Bs = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(Bs || {}), Ws = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(Ws || {}); function Vs(t) { let n = e.useContext(Ss); return n || Ha(!1), n } function Hs(t) { let n = e.useContext(Cs); return n || Ha(!1), n } function Us(t) { let n = function (t) { let n = e.useContext(Os); return n || Ha(!1), n }(), r = n.matches[n.matches.length - 1]; return r.route.id || Ha(!1), r.route.id } const $s = {}; t.startTransition; function Ys(t) { let { to: n, replace: r, state: i, relative: o } = t; Ns() || Ha(!1); let { future: a, static: s } = e.useContext(Es), { matches: l } = e.useContext(Os), { pathname: c } = Ts(), u = Ds(), d = gs(n, ps(l, a.v7_relativeSplatPath), c, "path" === o), h = JSON.stringify(d); return e.useEffect((() => u(JSON.parse(h), { replace: r, state: i, relative: o })), [u, h, o, r, i]), null } function qs(e) { Ha(!1) } function Ks(t) { let { basename: n = "/", children: r = null, location: i, navigationType: o = Wa.Pop, navigator: a, static: s = !1, future: l } = t; Ns() && Ha(!1); let c = n.replace(/^\/*/, "/"), u = e.useMemo((() => ({ basename: c, navigator: a, static: s, future: ks({ v7_relativeSplatPath: !1 }, l) })), [c, l, a, s]); "string" === typeof i && (i = Ka(i)); let { pathname: d = "/", search: h = "", hash: f = "", state: p = null, key: g = "default" } = i, m = e.useMemo((() => { let e = ds(d, c); return null == e ? null : { location: { pathname: e, search: h, hash: f, state: p, key: g }, navigationType: o } }), [c, d, h, f, p, g, o]); return null == m ? null : e.createElement(Es.Provider, { value: u }, e.createElement(Ms.Provider, { children: r, value: m })) } function Qs(e) { let { children: t, location: n } = e; return Rs(Xs(t), n) } new Promise((() => { })); e.Component; function Xs(t, n) { void 0 === n && (n = []); let r = []; return e.Children.forEach(t, ((t, i) => { if (!e.isValidElement(t)) return; let o = [...n, i]; if (t.type === e.Fragment) return void r.push.apply(r, Xs(t.props.children, o)); t.type !== qs && Ha(!1), t.props.index && t.props.children && Ha(!1); let a = { id: t.props.id || o.join("-"), caseSensitive: t.props.caseSensitive, element: t.props.element, Component: t.props.Component, index: t.props.index, path: t.props.path, loader: t.props.loader, action: t.props.action, errorElement: t.props.errorElement, ErrorBoundary: t.props.ErrorBoundary, hasErrorBoundary: null != t.props.ErrorBoundary || null != t.props.errorElement, shouldRevalidate: t.props.shouldRevalidate, handle: t.props.handle, lazy: t.props.lazy }; t.props.children && (a.children = Xs(t.props.children, o)), r.push(a) })), r } function Gs(e) { return void 0 === e && (e = ""), new URLSearchParams("string" === typeof e || Array.isArray(e) || e instanceof URLSearchParams ? e : Object.keys(e).reduce(((t, n) => { let r = e[n]; return t.concat(Array.isArray(r) ? r.map((e => [n, e])) : [[n, r]]) }), [])) } new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); new Map; const Js = t.startTransition; Ue.flushSync; function Zs(t) { let { basename: n, children: r, future: i, window: o } = t, a = e.useRef(); null == a.current && (a.current = function (e) { return void 0 === e && (e = {}), Qa((function (e, t) { let { pathname: n, search: r, hash: i } = e.location; return Ya("", { pathname: n, search: r, hash: i }, t.state && t.state.usr || null, t.state && t.state.key || "default") }), (function (e, t) { return "string" === typeof t ? t : qa(t) }), null, e) }({ window: o, v5Compat: !0 })); let s = a.current, [l, c] = e.useState({ action: s.action, location: s.location }), { v7_startTransition: u } = i || {}, d = e.useCallback((e => { u && Js ? Js((() => c(e))) : c(e) }), [c, u]); return e.useLayoutEffect((() => s.listen(d)), [s, d]), e.createElement(Ks, { basename: n, children: r, location: l.location, navigationType: l.action, navigator: s, future: i }) } "undefined" !== typeof window && "undefined" !== typeof window.document && window.document.createElement; var el, tl; function nl(t) { let n = e.useRef(Gs(t)), r = e.useRef(!1), i = Ts(), o = e.useMemo((() => function (e, t) { let n = Gs(e); return t && t.forEach(((e, r) => { n.has(r) || t.getAll(r).forEach((e => { n.append(r, e) })) })), n }(i.search, r.current ? null : n.current)), [i.search]), a = Ds(), s = e.useCallback(((e, t) => { const n = Gs("function" === typeof e ? e(o) : e); r.current = !0, a("?" + n, t) }), [a, o]); return [o, s] } (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState" })(el || (el = {})), function (e) { e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" }(tl || (tl = {})); const rl = e => e.replace(/\w\S*/g, (function (e) { return e.charAt(0).toUpperCase() + e.substr(1).toLowerCase() })), il = e => { const t = e.split(" "); return "Fall" === t[0] ? t[0] = "Fall" : "Spring" === t[0] ? t[0] = "Spr" : "Summer" === t[0] && (t[0] = "Sum"), t.join(" ") }, ol = e => rl(e.split(",")[0]), al = (e, t) => t.every((t => e.hasOwnProperty(t))), sl = {}; let ll; function cl(t, n, r, i) { const [o, a] = nl(), s = o.get(n), [l, c] = (0, e.useState)(s ? i(s) : t); return (0, e.useEffect)((() => { s && i(s) !== l && c(i(s)), s && (sl[n] = s), s || c(t) }), [s]), (0, e.useEffect)((() => { if (null === l || null !== l && Array.isArray(l) && 0 === l.length ? sl.hasOwnProperty(n) && delete sl[n] : sl[n] = r(l), (!s || s !== r(l)) && al(sl, ["query", "disp", "agg", "multi"])) return ll && clearTimeout(ll), ll = setTimeout((() => { const e = new URLSearchParams; Object.keys(sl).forEach((t => { e.set(t, sl[t]) })), a(e) }), 250), () => clearTimeout(ll) }), [l]), [l, c] } const ul = e => { let { data: t, selectedCourses: n, toggleCourseSelection: r, addCourse: i, removeCourse: o, saveMode: s, setSaveMode: l } = e; const c = e => ["A", "A_minus", "A_plus", "B", "B_minus", "B_plus", "C", "C_minus", "C_plus", "D", "D_minus", "D_plus", "F", "Other"].reduce(((t, n) => t + e[n]), 0), u = () => { }; return (0, a.jsx)(Ea, { className: "shadow mb-2 the-table-card", children: (0, a.jsxs)(Ea.Body, { className: "pb-2", children: [(0, a.jsxs)("label", { className: "mx-2 ".concat(s ? "" : "mb-2"), children: [(0, a.jsx)("div", { style: { verticalAlign: "-0.1em", display: "inline" }, children: (0, a.jsx)(Ra, { onChange: () => { l(!s), n.forEach((e => o(e))); const e = t.find((e => n.includes(e.internal_id))); e && r(e.internal_id) }, checked: s, height: 12, width: 30, handleDiameter: 8, uncheckedIcon: !1, checkedIcon: !1 }) }), (0, a.jsx)("span", { className: "ms-2", children: "Multi-Select" })] }), s && (0, a.jsxs)("div", { className: "mb-1", children: [(0, a.jsx)("span", { className: "mx-2 emph-on-hover", onClick: () => t.forEach((e => { i(e.internal_id) })), children: (0, a.jsx)("u", { children: "Select All" }) }), (0, a.jsx)("span", { className: "mx-2 emph-on-hover", onClick: () => t.forEach((e => { o(e.internal_id) })), children: (0, a.jsx)("u", { children: "Deselect All" }) })] }), (0, a.jsx)(b, { fluid: !0, style: { overflowY: "auto" }, className: "gx-0 tablecard-table", children: (0, a.jsx)(Oa, { striped: !0, bordered: !0, hover: !0, className: "mb-0", children: (0, a.jsx)("tbody", { children: t.map(((e, t) => (0, a.jsxs)("tr", { style: { cursor: "pointer" }, onClick: () => r(e.internal_id), children: [(0, a.jsxs)("td", { style: { borderRight: "none", verticalAlign: "middle", textAlign: "left", padding: "0.6rem 0.75rem 0.5rem", lineHeight: "100%" }, children: [s && (0, a.jsx)(a.Fragment, { children: (0, a.jsx)(yi, { placement: "top", overlay: (0, a.jsx)(gi, { children: (0, a.jsx)("span", { style: { fontVariant: "small-caps" }, children: rl(e.course_name) }) }), children: (0, a.jsxs)("span", { children: [(0, a.jsxs)("span", { className: "fw-bold", style: { textDecoration: "underline" }, children: [e.dept, "\xa0", e.course_nbr] }), (0, a.jsxs)("span", { children: [" w/\xa0", (0, a.jsx)("span", { className: "text-capitalize", children: ol(e.prof) })] })] }) }, "top") }), !s && (0, a.jsxs)(a.Fragment, { children: [(0, a.jsxs)("span", { className: "fw-bold", children: [e.dept, "\xa0", e.course_nbr] }), (0, a.jsxs)("span", { children: [" w/\xa0", (0, a.jsx)("span", { className: "text-capitalize", children: ol(e.prof) })] })] }), (0, a.jsx)("br", {}), (0, a.jsxs)("span", { children: [il(e.sem).replace(/ /g, "\xa0"), " - ", c(e), "\xa0", (0, a.jsx)(Fa, { style: { verticalAlign: "-0.186em" } })] })] }), (0, a.jsx)("td", { style: { width: "1%", borderLeft: "none", verticalAlign: "middle", textAlign: "center", paddingRight: "0.75rem" }, children: (0, a.jsx)("input", { type: "".concat(!0 === s ? "checkbox" : "radio"), checked: n.includes(e.internal_id), onChange: u }) })] }, t))) }) }) }), (0, a.jsx)("div", { style: { lineHeight: "1em" }, className: "mb-2 mt-3", children: t.length < 100 ? "".concat(0 === t.length ? "No" : t.length, " result").concat(1 === t.length ? "" : "s", " found.") : "First 100 results shown. Try a more specific query?" })] }) }) }; function dl(e) { return dl = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, dl(e) } function hl(e) { var t = function (e, t) { if ("object" !== dl(e) || null === e) return e; var n = e[Symbol.toPrimitive]; if (void 0 !== n) { var r = n.call(e, t || "default"); if ("object" !== dl(r)) return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(e, "string"); return "symbol" === dl(t) ? t : String(t) } function fl(e, t, n) { return (t = hl(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function pl(e) { return e + .5 | 0 } const gl = (e, t, n) => Math.max(Math.min(e, n), t); function ml(e) { return gl(pl(2.55 * e), 0, 255) } function bl(e) { return gl(pl(255 * e), 0, 255) } function vl(e) { return gl(pl(e / 2.55) / 100, 0, 1) } function yl(e) { return gl(pl(100 * e), 0, 100) } const xl = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, wl = [..."0123456789ABCDEF"], _l = e => wl[15 & e], kl = e => wl[(240 & e) >> 4] + wl[15 & e], Sl = e => (240 & e) >> 4 === (15 & e); function Cl(e) { var t = (e => Sl(e.r) && Sl(e.g) && Sl(e.b) && Sl(e.a))(e) ? _l : kl; return e ? "#" + t(e.r) + t(e.g) + t(e.b) + ((e, t) => e < 255 ? t(e) : "")(e.a, t) : void 0 } const El = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function Ml(e, t, n) { const r = t * Math.min(n, 1 - n), i = function (t) { let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (t + e / 30) % 12; return n - r * Math.max(Math.min(i - 3, 9 - i, 1), -1) }; return [i(0), i(8), i(4)] } function Ol(e, t, n) { const r = function (r) { let i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : (r + e / 60) % 6; return n - n * t * Math.max(Math.min(i, 4 - i, 1), 0) }; return [r(5), r(3), r(1)] } function Pl(e, t, n) { const r = Ml(e, 1, .5); let i; for (t + n > 1 && (i = 1 / (t + n), t *= i, n *= i), i = 0; i < 3; i++)r[i] *= 1 - t - n, r[i] += t; return r } function Nl(e) { const t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.max(t, n, r), o = Math.min(t, n, r), a = (i + o) / 2; let s, l, c; return i !== o && (c = i - o, l = a > .5 ? c / (2 - i - o) : c / (i + o), s = function (e, t, n, r, i) { return e === i ? (t - n) / r + (t < n ? 6 : 0) : t === i ? (n - e) / r + 2 : (e - t) / r + 4 }(t, n, r, c, i), s = 60 * s + .5), [0 | s, l || 0, a] } function Tl(e, t, n, r) { return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, r)).map(bl) } function jl(e, t, n) { return Tl(Ml, e, t, n) } function Dl(e) { return (e % 360 + 360) % 360 } function Rl(e) { const t = El.exec(e); let n, r = 255; if (!t) return; t[5] !== n && (r = t[6] ? ml(+t[5]) : bl(+t[5])); const i = Dl(+t[2]), o = +t[3] / 100, a = +t[4] / 100; return n = "hwb" === t[1] ? function (e, t, n) { return Tl(Pl, e, t, n) }(i, o, a) : "hsv" === t[1] ? function (e, t, n) { return Tl(Ol, e, t, n) }(i, o, a) : jl(i, o, a), { r: n[0], g: n[1], b: n[2], a: r } } const Ll = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, Al = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; let zl; function Il(e) { zl || (zl = function () { const e = {}, t = Object.keys(Al), n = Object.keys(Ll); let r, i, o, a, s; for (r = 0; r < t.length; r++) { for (a = s = t[r], i = 0; i < n.length; i++)o = n[i], s = s.replace(o, Ll[o]); o = parseInt(Al[a], 16), e[s] = [o >> 16 & 255, o >> 8 & 255, 255 & o] } return e }(), zl.transparent = [0, 0, 0, 0]); const t = zl[e.toLowerCase()]; return t && { r: t[0], g: t[1], b: t[2], a: 4 === t.length ? t[3] : 255 } } const Fl = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; const Bl = e => e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055, Wl = e => e <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4); function Vl(e, t, n) { if (e) { let r = Nl(e); r[t] = Math.max(0, Math.min(r[t] + r[t] * n, 0 === t ? 360 : 1)), r = jl(r), e.r = r[0], e.g = r[1], e.b = r[2] } } function Hl(e, t) { return e ? Object.assign(t || {}, e) : e } function Ul(e) { var t = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = bl(e[3]))) : (t = Hl(e, { r: 0, g: 0, b: 0, a: 1 })).a = bl(t.a), t } function $l(e) { return "r" === e.charAt(0) ? function (e) { const t = Fl.exec(e); let n, r, i, o = 255; if (t) { if (t[7] !== n) { const e = +t[7]; o = t[8] ? ml(e) : gl(255 * e, 0, 255) } return n = +t[1], r = +t[3], i = +t[5], n = 255 & (t[2] ? ml(n) : gl(n, 0, 255)), r = 255 & (t[4] ? ml(r) : gl(r, 0, 255)), i = 255 & (t[6] ? ml(i) : gl(i, 0, 255)), { r: n, g: r, b: i, a: o } } }(e) : Rl(e) } class Yl { constructor(e) { if (e instanceof Yl) return e; const t = typeof e; let n; "object" === t ? n = Ul(e) : "string" === t && (n = function (e) { var t, n = e.length; return "#" === e[0] && (4 === n || 5 === n ? t = { r: 255 & 17 * xl[e[1]], g: 255 & 17 * xl[e[2]], b: 255 & 17 * xl[e[3]], a: 5 === n ? 17 * xl[e[4]] : 255 } : 7 !== n && 9 !== n || (t = { r: xl[e[1]] << 4 | xl[e[2]], g: xl[e[3]] << 4 | xl[e[4]], b: xl[e[5]] << 4 | xl[e[6]], a: 9 === n ? xl[e[7]] << 4 | xl[e[8]] : 255 })), t }(e) || Il(e) || $l(e)), this._rgb = n, this._valid = !!n } get valid() { return this._valid } get rgb() { var e = Hl(this._rgb); return e && (e.a = vl(e.a)), e } set rgb(e) { this._rgb = Ul(e) } rgbString() { return this._valid ? (e = this._rgb) && (e.a < 255 ? "rgba(".concat(e.r, ", ").concat(e.g, ", ").concat(e.b, ", ").concat(vl(e.a), ")") : "rgb(".concat(e.r, ", ").concat(e.g, ", ").concat(e.b, ")")) : void 0; var e } hexString() { return this._valid ? Cl(this._rgb) : void 0 } hslString() { return this._valid ? function (e) { if (!e) return; const t = Nl(e), n = t[0], r = yl(t[1]), i = yl(t[2]); return e.a < 255 ? "hsla(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(vl(e.a), ")") : "hsl(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") }(this._rgb) : void 0 } mix(e, t) { if (e) { const n = this.rgb, r = e.rgb; let i; const o = t === i ? .5 : t, a = 2 * o - 1, s = n.a - r.a, l = ((a * s === -1 ? a : (a + s) / (1 + a * s)) + 1) / 2; i = 1 - l, n.r = 255 & l * n.r + i * r.r + .5, n.g = 255 & l * n.g + i * r.g + .5, n.b = 255 & l * n.b + i * r.b + .5, n.a = o * n.a + (1 - o) * r.a, this.rgb = n } return this } interpolate(e, t) { return e && (this._rgb = function (e, t, n) { const r = Wl(vl(e.r)), i = Wl(vl(e.g)), o = Wl(vl(e.b)); return { r: bl(Bl(r + n * (Wl(vl(t.r)) - r))), g: bl(Bl(i + n * (Wl(vl(t.g)) - i))), b: bl(Bl(o + n * (Wl(vl(t.b)) - o))), a: e.a + n * (t.a - e.a) } }(this._rgb, e._rgb, t)), this } clone() { return new Yl(this.rgb) } alpha(e) { return this._rgb.a = bl(e), this } clearer(e) { return this._rgb.a *= 1 - e, this } greyscale() { const e = this._rgb, t = pl(.3 * e.r + .59 * e.g + .11 * e.b); return e.r = e.g = e.b = t, this } opaquer(e) { return this._rgb.a *= 1 + e, this } negate() { const e = this._rgb; return e.r = 255 - e.r, e.g = 255 - e.g, e.b = 255 - e.b, this } lighten(e) { return Vl(this._rgb, 2, e), this } darken(e) { return Vl(this._rgb, 2, -e), this } saturate(e) { return Vl(this._rgb, 1, e), this } desaturate(e) { return Vl(this._rgb, 1, -e), this } rotate(e) { return function (e, t) { var n = Nl(e); n[0] = Dl(n[0] + t), n = jl(n), e.r = n[0], e.g = n[1], e.b = n[2] }(this._rgb, e), this } } function ql() { } const Kl = (() => { let e = 0; return () => e++ })(); function Ql(e) { return null === e || "undefined" === typeof e } function Xl(e) { if (Array.isArray && Array.isArray(e)) return !0; const t = Object.prototype.toString.call(e); return "[object" === t.slice(0, 7) && "Array]" === t.slice(-6) } function Gl(e) { return null !== e && "[object Object]" === Object.prototype.toString.call(e) } function Jl(e) { return ("number" === typeof e || e instanceof Number) && isFinite(+e) } function Zl(e, t) { return Jl(e) ? e : t } function ec(e, t) { return "undefined" === typeof e ? t : e } const tc = (e, t) => "string" === typeof e && e.endsWith("%") ? parseFloat(e) / 100 * t : +e; function nc(e, t, n) { if (e && "function" === typeof e.call) return e.apply(n, t) } function rc(e, t, n, r) { let i, o, a; if (Xl(e)) if (o = e.length, r) for (i = o - 1; i >= 0; i--)t.call(n, e[i], i); else for (i = 0; i < o; i++)t.call(n, e[i], i); else if (Gl(e)) for (a = Object.keys(e), o = a.length, i = 0; i < o; i++)t.call(n, e[a[i]], a[i]) } function ic(e, t) { let n, r, i, o; if (!e || !t || e.length !== t.length) return !1; for (n = 0, r = e.length; n < r; ++n)if (i = e[n], o = t[n], i.datasetIndex !== o.datasetIndex || i.index !== o.index) return !1; return !0 } function oc(e) { if (Xl(e)) return e.map(oc); if (Gl(e)) { const t = Object.create(null), n = Object.keys(e), r = n.length; let i = 0; for (; i < r; ++i)t[n[i]] = oc(e[n[i]]); return t } return e } function ac(e) { return -1 === ["__proto__", "prototype", "constructor"].indexOf(e) } function sc(e, t, n, r) { if (!ac(e)) return; const i = t[e], o = n[e]; Gl(i) && Gl(o) ? lc(i, o, r) : t[e] = oc(o) } function lc(e, t, n) { const r = Xl(t) ? t : [t], i = r.length; if (!Gl(e)) return e; const o = (n = n || {}).merger || sc; let a; for (let s = 0; s < i; ++s) { if (a = r[s], !Gl(a)) continue; const t = Object.keys(a); for (let r = 0, i = t.length; r < i; ++r)o(t[r], e, a, n) } return e } function cc(e, t) { return lc(e, t, { merger: uc }) } function uc(e, t, n) { if (!ac(e)) return; const r = t[e], i = n[e]; Gl(r) && Gl(i) ? cc(r, i) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = oc(i)) } const dc = { "": e => e, x: e => e.x, y: e => e.y }; function hc(e, t) { const n = dc[t] || (dc[t] = function (e) { const t = function (e) { const t = e.split("."), n = []; let r = ""; for (const i of t) r += i, r.endsWith("\\") ? r = r.slice(0, -1) + "." : (n.push(r), r = ""); return n }(e); return e => { for (const n of t) { if ("" === n) break; e = e && e[n] } return e } }(t)); return n(e) } function fc(e) { return e.charAt(0).toUpperCase() + e.slice(1) } const pc = e => "undefined" !== typeof e, gc = e => "function" === typeof e, mc = (e, t) => { if (e.size !== t.size) return !1; for (const n of e) if (!t.has(n)) return !1; return !0 }; const bc = Math.PI, vc = 2 * bc, yc = vc + bc, xc = Number.POSITIVE_INFINITY, wc = bc / 180, _c = bc / 2, kc = bc / 4, Sc = 2 * bc / 3, Cc = Math.log10, Ec = Math.sign; function Mc(e, t, n) { return Math.abs(e - t) < n } function Oc(e) { const t = Math.round(e); e = Mc(e, t, e / 1e3) ? t : e; const n = Math.pow(10, Math.floor(Cc(e))), r = e / n; return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n } function Pc(e) { return !isNaN(parseFloat(e)) && isFinite(e) } function Nc(e, t, n) { let r, i, o; for (r = 0, i = e.length; r < i; r++)o = e[r][n], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o)) } function Tc(e) { return e * (bc / 180) } function jc(e) { return e * (180 / bc) } function Dc(e) { if (!Jl(e)) return; let t = 1, n = 0; for (; Math.round(e * t) / t !== e;)t *= 10, n++; return n } function Rc(e, t) { const n = t.x - e.x, r = t.y - e.y, i = Math.sqrt(n * n + r * r); let o = Math.atan2(r, n); return o < -.5 * bc && (o += vc), { angle: o, distance: i } } function Lc(e, t) { return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)) } function Ac(e, t) { return (e - t + yc) % vc - bc } function zc(e) { return (e % vc + vc) % vc } function Ic(e, t, n, r) { const i = zc(e), o = zc(t), a = zc(n), s = zc(o - i), l = zc(a - i), c = zc(i - o), u = zc(i - a); return i === o || i === a || r && o === a || s > l && c < u } function Fc(e, t, n) { return Math.max(t, Math.min(n, e)) } function Bc(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e-6; return e >= Math.min(t, n) - r && e <= Math.max(t, n) + r } function Wc(e, t, n) { n = n || (n => e[n] < t); let r, i = e.length - 1, o = 0; for (; i - o > 1;)r = o + i >> 1, n(r) ? o = r : i = r; return { lo: o, hi: i } } const Vc = (e, t, n, r) => Wc(e, n, r ? r => { const i = e[r][t]; return i < n || i === n && e[r + 1][t] === n } : r => e[r][t] < n), Hc = (e, t, n) => Wc(e, n, (r => e[r][t] >= n)); const Uc = ["push", "pop", "shift", "splice", "unshift"]; function $c(e, t) { const n = e._chartjs; if (!n) return; const r = n.listeners, i = r.indexOf(t); -1 !== i && r.splice(i, 1), r.length > 0 || (Uc.forEach((t => { delete e[t] })), delete e._chartjs) } function Yc(e) { const t = new Set(e); return t.size === e.length ? e : Array.from(t) } const qc = "undefined" === typeof window ? function (e) { return e() } : window.requestAnimationFrame; function Kc(e, t) { let n = [], r = !1; return function () { for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)o[a] = arguments[a]; n = o, r || (r = !0, qc.call(window, (() => { r = !1, e.apply(t, n) }))) } } const Qc = e => "start" === e ? "left" : "end" === e ? "right" : "center", Xc = (e, t, n) => "start" === e ? t : "end" === e ? n : (t + n) / 2; function Gc(e, t, n) { const r = t.length; let i = 0, o = r; if (e._sorted) { const { iScale: a, _parsed: s } = e, l = a.axis, { min: c, max: u, minDefined: d, maxDefined: h } = a.getUserBounds(); d && (i = Fc(Math.min(Vc(s, l, c).lo, n ? r : Vc(t, l, a.getPixelForValue(c)).lo), 0, r - 1)), o = h ? Fc(Math.max(Vc(s, a.axis, u, !0).hi + 1, n ? 0 : Vc(t, l, a.getPixelForValue(u), !0).hi + 1), i, r) - i : r - i } return { start: i, count: o } } function Jc(e) { const { xScale: t, yScale: n, _scaleRanges: r } = e, i = { xmin: t.min, xmax: t.max, ymin: n.min, ymax: n.max }; if (!r) return e._scaleRanges = i, !0; const o = r.xmin !== t.min || r.xmax !== t.max || r.ymin !== n.min || r.ymax !== n.max; return Object.assign(r, i), o } const Zc = e => 0 === e || 1 === e, eu = (e, t, n) => -Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * vc / n), tu = (e, t, n) => Math.pow(2, -10 * e) * Math.sin((e - t) * vc / n) + 1, nu = { linear: e => e, easeInQuad: e => e * e, easeOutQuad: e => -e * (e - 2), easeInOutQuad: e => (e /= .5) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1), easeInCubic: e => e * e * e, easeOutCubic: e => (e -= 1) * e * e + 1, easeInOutCubic: e => (e /= .5) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2), easeInQuart: e => e * e * e * e, easeOutQuart: e => -((e -= 1) * e * e * e - 1), easeInOutQuart: e => (e /= .5) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2), easeInQuint: e => e * e * e * e * e, easeOutQuint: e => (e -= 1) * e * e * e * e + 1, easeInOutQuint: e => (e /= .5) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2), easeInSine: e => 1 - Math.cos(e * _c), easeOutSine: e => Math.sin(e * _c), easeInOutSine: e => -.5 * (Math.cos(bc * e) - 1), easeInExpo: e => 0 === e ? 0 : Math.pow(2, 10 * (e - 1)), easeOutExpo: e => 1 === e ? 1 : 1 - Math.pow(2, -10 * e), easeInOutExpo: e => Zc(e) ? e : e < .5 ? .5 * Math.pow(2, 10 * (2 * e - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * e - 1))), easeInCirc: e => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1), easeOutCirc: e => Math.sqrt(1 - (e -= 1) * e), easeInOutCirc: e => (e /= .5) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1), easeInElastic: e => Zc(e) ? e : eu(e, .075, .3), easeOutElastic: e => Zc(e) ? e : tu(e, .075, .3), easeInOutElastic(e) { const t = .1125; return Zc(e) ? e : e < .5 ? .5 * eu(2 * e, t, .45) : .5 + .5 * tu(2 * e - 1, t, .45) }, easeInBack(e) { const t = 1.70158; return e * e * ((t + 1) * e - t) }, easeOutBack(e) { const t = 1.70158; return (e -= 1) * e * ((t + 1) * e + t) + 1 }, easeInOutBack(e) { let t = 1.70158; return (e /= .5) < 1 ? e * e * ((1 + (t *= 1.525)) * e - t) * .5 : .5 * ((e -= 2) * e * ((1 + (t *= 1.525)) * e + t) + 2) }, easeInBounce: e => 1 - nu.easeOutBounce(1 - e), easeOutBounce(e) { const t = 7.5625, n = 2.75; return e < 1 / n ? t * e * e : e < 2 / n ? t * (e -= 1.5 / n) * e + .75 : e < 2.5 / n ? t * (e -= 2.25 / n) * e + .9375 : t * (e -= 2.625 / n) * e + .984375 }, easeInOutBounce: e => e < .5 ? .5 * nu.easeInBounce(2 * e) : .5 * nu.easeOutBounce(2 * e - 1) + .5 }; function ru(e) { if (e && "object" === typeof e) { const t = e.toString(); return "[object CanvasPattern]" === t || "[object CanvasGradient]" === t } return !1 } function iu(e) { return ru(e) ? e : new Yl(e) } function ou(e) { return ru(e) ? e : new Yl(e).saturate(.5).darken(.1).hexString() } const au = ["x", "y", "borderWidth", "radius", "tension"], su = ["color", "borderColor", "backgroundColor"]; const lu = new Map; function cu(e, t, n) { return function (e, t) { t = t || {}; const n = e + JSON.stringify(t); let r = lu.get(n); return r || (r = new Intl.NumberFormat(e, t), lu.set(n, r)), r }(t, n).format(e) } const uu = { values: e => Xl(e) ? e : "" + e, numeric(e, t, n) { if (0 === e) return "0"; const r = this.chart.options.locale; let i, o = e; if (n.length > 1) { const t = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value)); (t < 1e-4 || t > 1e15) && (i = "scientific"), o = function (e, t) { let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value; Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)); return n }(e, n) } const a = Cc(Math.abs(o)), s = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0), l = { notation: i, minimumFractionDigits: s, maximumFractionDigits: s }; return Object.assign(l, this.options.ticks.format), cu(e, r, l) }, logarithmic(e, t, n) { if (0 === e) return "0"; const r = n[t].significand || e / Math.pow(10, Math.floor(Cc(e))); return [1, 2, 3, 5, 10, 15].includes(r) || t > .8 * n.length ? uu.numeric.call(this, e, t, n) : "" } }; var du = { formatters: uu }; const hu = Object.create(null), fu = Object.create(null); function pu(e, t) { if (!t) return e; const n = t.split("."); for (let r = 0, i = n.length; r < i; ++r) { const t = n[r]; e = e[t] || (e[t] = Object.create(null)) } return e } function gu(e, t, n) { return "string" === typeof t ? lc(pu(e, t), n) : lc(pu(e, ""), t) } class mu { constructor(e, t) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = e => e.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (e, t) => ou(t.backgroundColor), this.hoverBorderColor = (e, t) => ou(t.borderColor), this.hoverColor = (e, t) => ou(t.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(e), this.apply(t) } set(e, t) { return gu(this, e, t) } get(e) { return pu(this, e) } describe(e, t) { return gu(fu, e, t) } override(e, t) { return gu(hu, e, t) } route(e, t, n, r) { const i = pu(this, e), o = pu(this, n), a = "_" + t; Object.defineProperties(i, { [a]: { value: i[t], writable: !0 }, [t]: { enumerable: !0, get() { const e = this[a], t = o[r]; return Gl(e) ? Object.assign({}, t, e) : ec(e, t) }, set(e) { this[a] = e } } }) } apply(e) { e.forEach((e => e(this))) } } var bu = new mu({ _scriptable: e => !e.startsWith("on"), _indexable: e => "events" !== e, hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }, [function (e) { e.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), e.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: e => "onProgress" !== e && "onComplete" !== e && "fn" !== e }), e.set("animations", { colors: { type: "color", properties: su }, numbers: { type: "number", properties: au } }), e.describe("animations", { _fallback: "animation" }), e.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: e => 0 | e } } } }) }, function (e) { e.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }) }, function (e) { e.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", clip: !0, grace: 0, grid: { display: !0, lineWidth: 1, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (e, t) => t.lineWidth, tickColor: (e, t) => t.color, offset: !1 }, border: { display: !0, dash: [], dashOffset: 0, width: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: du.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", { _fallback: !1, _scriptable: e => !e.startsWith("before") && !e.startsWith("after") && "callback" !== e && "parser" !== e, _indexable: e => "borderDash" !== e && "tickBorderDash" !== e && "dash" !== e }), e.describe("scales", { _fallback: "scale" }), e.describe("scale.ticks", { _scriptable: e => "backdropPadding" !== e && "callback" !== e, _indexable: e => "backdropPadding" !== e }) }]); function vu(e, t, n, r, i) { let o = t[i]; return o || (o = t[i] = e.measureText(i).width, n.push(i)), o > r && (r = o), r } function yu(e, t, n, r) { let i = (r = r || {}).data = r.data || {}, o = r.garbageCollect = r.garbageCollect || []; r.font !== t && (i = r.data = {}, o = r.garbageCollect = [], r.font = t), e.save(), e.font = t; let a = 0; const s = n.length; let l, c, u, d, h; for (l = 0; l < s; l++)if (d = n[l], void 0 === d || null === d || Xl(d)) { if (Xl(d)) for (c = 0, u = d.length; c < u; c++)h = d[c], void 0 === h || null === h || Xl(h) || (a = vu(e, i, o, a, h)) } else a = vu(e, i, o, a, d); e.restore(); const f = o.length / 2; if (f > n.length) { for (l = 0; l < f; l++)delete i[o[l]]; o.splice(0, f) } return a } function xu(e, t, n) { const r = e.currentDevicePixelRatio, i = 0 !== n ? Math.max(n / 2, .5) : 0; return Math.round((t - i) * r) / r + i } function wu(e, t) { (t = t || e.getContext("2d")).save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore() } function _u(e, t, n, r) { ku(e, t, n, r, null) } function ku(e, t, n, r, i) { let o, a, s, l, c, u, d, h; const f = t.pointStyle, p = t.rotation, g = t.radius; let m = (p || 0) * wc; if (f && "object" === typeof f && (o = f.toString(), "[object HTMLImageElement]" === o || "[object HTMLCanvasElement]" === o)) return e.save(), e.translate(n, r), e.rotate(m), e.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), void e.restore(); if (!(isNaN(g) || g <= 0)) { switch (e.beginPath(), f) { default: i ? e.ellipse(n, r, i / 2, g, 0, 0, vc) : e.arc(n, r, g, 0, vc), e.closePath(); break; case "triangle": u = i ? i / 2 : g, e.moveTo(n + Math.sin(m) * u, r - Math.cos(m) * g), m += Sc, e.lineTo(n + Math.sin(m) * u, r - Math.cos(m) * g), m += Sc, e.lineTo(n + Math.sin(m) * u, r - Math.cos(m) * g), e.closePath(); break; case "rectRounded": c = .516 * g, l = g - c, a = Math.cos(m + kc) * l, d = Math.cos(m + kc) * (i ? i / 2 - c : l), s = Math.sin(m + kc) * l, h = Math.sin(m + kc) * (i ? i / 2 - c : l), e.arc(n - d, r - s, c, m - bc, m - _c), e.arc(n + h, r - a, c, m - _c, m), e.arc(n + d, r + s, c, m, m + _c), e.arc(n - h, r + a, c, m + _c, m + bc), e.closePath(); break; case "rect": if (!p) { l = Math.SQRT1_2 * g, u = i ? i / 2 : l, e.rect(n - u, r - l, 2 * u, 2 * l); break } m += kc; case "rectRot": d = Math.cos(m) * (i ? i / 2 : g), a = Math.cos(m) * g, s = Math.sin(m) * g, h = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - d, r - s), e.lineTo(n + h, r - a), e.lineTo(n + d, r + s), e.lineTo(n - h, r + a), e.closePath(); break; case "crossRot": m += kc; case "cross": d = Math.cos(m) * (i ? i / 2 : g), a = Math.cos(m) * g, s = Math.sin(m) * g, h = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - d, r - s), e.lineTo(n + d, r + s), e.moveTo(n + h, r - a), e.lineTo(n - h, r + a); break; case "star": d = Math.cos(m) * (i ? i / 2 : g), a = Math.cos(m) * g, s = Math.sin(m) * g, h = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - d, r - s), e.lineTo(n + d, r + s), e.moveTo(n + h, r - a), e.lineTo(n - h, r + a), m += kc, d = Math.cos(m) * (i ? i / 2 : g), a = Math.cos(m) * g, s = Math.sin(m) * g, h = Math.sin(m) * (i ? i / 2 : g), e.moveTo(n - d, r - s), e.lineTo(n + d, r + s), e.moveTo(n + h, r - a), e.lineTo(n - h, r + a); break; case "line": a = i ? i / 2 : Math.cos(m) * g, s = Math.sin(m) * g, e.moveTo(n - a, r - s), e.lineTo(n + a, r + s); break; case "dash": e.moveTo(n, r), e.lineTo(n + Math.cos(m) * (i ? i / 2 : g), r + Math.sin(m) * g); break; case !1: e.closePath() }e.fill(), t.borderWidth > 0 && e.stroke() } } function Su(e, t, n) { return n = n || .5, !t || e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n } function Cu(e, t) { e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip() } function Eu(e) { e.restore() } function Mu(e, t, n, r, i) { if (!t) return e.lineTo(n.x, n.y); if ("middle" === i) { const r = (t.x + n.x) / 2; e.lineTo(r, t.y), e.lineTo(r, n.y) } else "after" === i !== !!r ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y); e.lineTo(n.x, n.y) } function Ou(e, t, n, r) { if (!t) return e.lineTo(n.x, n.y); e.bezierCurveTo(r ? t.cp1x : t.cp2x, r ? t.cp1y : t.cp2y, r ? n.cp2x : n.cp1x, r ? n.cp2y : n.cp1y, n.x, n.y) } function Pu(e, t, n, r, i) { if (i.strikethrough || i.underline) { const o = e.measureText(r), a = t - o.actualBoundingBoxLeft, s = t + o.actualBoundingBoxRight, l = n - o.actualBoundingBoxAscent, c = n + o.actualBoundingBoxDescent, u = i.strikethrough ? (l + c) / 2 : c; e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = i.decorationWidth || 2, e.moveTo(a, u), e.lineTo(s, u), e.stroke() } } function Nu(e, t) { const n = e.fillStyle; e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = n } function Tu(e, t, n, r, i) { let o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {}; const a = Xl(t) ? t : [t], s = o.strokeWidth > 0 && "" !== o.strokeColor; let l, c; for (e.save(), e.font = i.string, function (e, t) { t.translation && e.translate(t.translation[0], t.translation[1]), Ql(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline) }(e, o), l = 0; l < a.length; ++l)c = a[l], o.backdrop && Nu(e, o.backdrop), s && (o.strokeColor && (e.strokeStyle = o.strokeColor), Ql(o.strokeWidth) || (e.lineWidth = o.strokeWidth), e.strokeText(c, n, r, o.maxWidth)), e.fillText(c, n, r, o.maxWidth), Pu(e, n, r, c, o), r += Number(i.lineHeight); e.restore() } function ju(e, t) { const { x: n, y: r, w: i, h: o, radius: a } = t; e.arc(n + a.topLeft, r + a.topLeft, a.topLeft, 1.5 * bc, bc, !0), e.lineTo(n, r + o - a.bottomLeft), e.arc(n + a.bottomLeft, r + o - a.bottomLeft, a.bottomLeft, bc, _c, !0), e.lineTo(n + i - a.bottomRight, r + o), e.arc(n + i - a.bottomRight, r + o - a.bottomRight, a.bottomRight, _c, 0, !0), e.lineTo(n + i, r + a.topRight), e.arc(n + i - a.topRight, r + a.topRight, a.topRight, 0, -_c, !0), e.lineTo(n + a.topLeft, r) } const Du = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, Ru = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/; function Lu(e, t) { const n = ("" + e).match(Du); if (!n || "normal" === n[1]) return 1.2 * t; switch (e = +n[2], n[3]) { case "px": return e; case "%": e /= 100 }return t * e } const Au = e => +e || 0; function zu(e, t) { const n = {}, r = Gl(t), i = r ? Object.keys(t) : t, o = Gl(e) ? r ? n => ec(e[n], e[t[n]]) : t => e[t] : () => e; for (const a of i) n[a] = Au(o(a)); return n } function Iu(e) { return zu(e, { top: "y", right: "x", bottom: "y", left: "x" }) } function Fu(e) { return zu(e, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function Bu(e) { const t = Iu(e); return t.width = t.left + t.right, t.height = t.top + t.bottom, t } function Wu(e, t) { e = e || {}, t = t || bu.font; let n = ec(e.size, t.size); "string" === typeof n && (n = parseInt(n, 10)); let r = ec(e.style, t.style); r && !("" + r).match(Ru) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0); const i = { family: ec(e.family, t.family), lineHeight: Lu(ec(e.lineHeight, t.lineHeight), n), size: n, style: r, weight: ec(e.weight, t.weight), string: "" }; return i.string = function (e) { return !e || Ql(e.size) || Ql(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family }(i), i } function Vu(e, t, n, r) { let i, o, a, s = !0; for (i = 0, o = e.length; i < o; ++i)if (a = e[i], void 0 !== a && (void 0 !== t && "function" === typeof a && (a = a(t), s = !1), void 0 !== n && Xl(a) && (a = a[n % a.length], s = !1), void 0 !== a)) return r && !s && (r.cacheable = !1), a } function Hu(e, t) { return Object.assign(Object.create(e), t) } function Uu(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [""], n = arguments.length > 3 ? arguments[3] : void 0, r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : () => e[0]; const i = (arguments.length > 2 ? arguments[2] : void 0) || e; "undefined" === typeof n && (n = td("_fallback", e)); const o = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: e, _rootScopes: i, _fallback: n, _getTarget: r, override: r => Uu([r, ...e], t, i, n) }; return new Proxy(o, { deleteProperty: (t, n) => (delete t[n], delete t._keys, delete e[0][n], !0), get: (n, r) => Qu(n, r, (() => function (e, t, n, r) { let i; for (const o of t) if (i = td(qu(o, e), n), "undefined" !== typeof i) return Ku(e, i) ? Zu(n, r, e, i) : i }(r, t, e, n))), getOwnPropertyDescriptor: (e, t) => Reflect.getOwnPropertyDescriptor(e._scopes[0], t), getPrototypeOf: () => Reflect.getPrototypeOf(e[0]), has: (e, t) => nd(e).includes(t), ownKeys: e => nd(e), set(e, t, n) { const i = e._storage || (e._storage = r()); return e[t] = i[t] = n, delete e._keys, !0 } }) } function $u(e, t, n, r) { const i = { _cacheable: !1, _proxy: e, _context: t, _subProxy: n, _stack: new Set, _descriptors: Yu(e, r), setContext: t => $u(e, t, n, r), override: i => $u(e.override(i), t, n, r) }; return new Proxy(i, { deleteProperty: (t, n) => (delete t[n], delete e[n], !0), get: (e, t, n) => Qu(e, t, (() => function (e, t, n) { const { _proxy: r, _context: i, _subProxy: o, _descriptors: a } = e; let s = r[t]; gc(s) && a.isScriptable(t) && (s = function (e, t, n, r) { const { _proxy: i, _context: o, _subProxy: a, _stack: s } = n; if (s.has(e)) throw new Error("Recursion detected: " + Array.from(s).join("->") + "->" + e); s.add(e); let l = t(o, a || r); s.delete(e), Ku(e, l) && (l = Zu(i._scopes, i, e, l)); return l }(t, s, e, n)); Xl(s) && s.length && (s = function (e, t, n, r) { const { _proxy: i, _context: o, _subProxy: a, _descriptors: s } = n; if ("undefined" !== typeof o.index && r(e)) return t[o.index % t.length]; if (Gl(t[0])) { const n = t, r = i._scopes.filter((e => e !== n)); t = []; for (const l of n) { const n = Zu(r, i, e, l); t.push($u(n, o, a && a[e], s)) } } return t }(t, s, e, a.isIndexable)); Ku(t, s) && (s = $u(s, i, o && o[t], a)); return s }(e, t, n))), getOwnPropertyDescriptor: (t, n) => t._descriptors.allKeys ? Reflect.has(e, n) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(e, n), getPrototypeOf: () => Reflect.getPrototypeOf(e), has: (t, n) => Reflect.has(e, n), ownKeys: () => Reflect.ownKeys(e), set: (t, n, r) => (e[n] = r, delete t[n], !0) }) } function Yu(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { scriptable: !0, indexable: !0 }; const { _scriptable: n = t.scriptable, _indexable: r = t.indexable, _allKeys: i = t.allKeys } = e; return { allKeys: i, scriptable: n, indexable: r, isScriptable: gc(n) ? n : () => n, isIndexable: gc(r) ? r : () => r } } const qu = (e, t) => e ? e + fc(t) : t, Ku = (e, t) => Gl(t) && "adapters" !== e && (null === Object.getPrototypeOf(t) || t.constructor === Object); function Qu(e, t, n) { if (Object.prototype.hasOwnProperty.call(e, t)) return e[t]; const r = n(); return e[t] = r, r } function Xu(e, t, n) { return gc(e) ? e(t, n) : e } const Gu = (e, t) => !0 === e ? t : "string" === typeof e ? hc(t, e) : void 0; function Ju(e, t, n, r, i) { for (const o of t) { const t = Gu(n, o); if (t) { e.add(t); const o = Xu(t._fallback, n, i); if ("undefined" !== typeof o && o !== n && o !== r) return o } else if (!1 === t && "undefined" !== typeof r && n !== r) return null } return !1 } function Zu(e, t, n, r) { const i = t._rootScopes, o = Xu(t._fallback, n, r), a = [...e, ...i], s = new Set; s.add(r); let l = ed(s, a, n, o || n, r); return null !== l && (("undefined" === typeof o || o === n || (l = ed(s, a, o, l, r), null !== l)) && Uu(Array.from(s), [""], i, o, (() => function (e, t, n) { const r = e._getTarget(); t in r || (r[t] = {}); const i = r[t]; if (Xl(i) && Gl(n)) return n; return i || {} }(t, n, r)))) } function ed(e, t, n, r, i) { for (; n;)n = Ju(e, t, n, r, i); return n } function td(e, t) { for (const n of t) { if (!n) continue; const t = n[e]; if ("undefined" !== typeof t) return t } } function nd(e) { let t = e._keys; return t || (t = e._keys = function (e) { const t = new Set; for (const n of e) for (const e of Object.keys(n).filter((e => !e.startsWith("_")))) t.add(e); return Array.from(t) }(e._scopes)), t } function rd(e, t, n, r) { const { iScale: i } = e, { key: o = "r" } = this._parsing, a = new Array(r); let s, l, c, u; for (s = 0, l = r; s < l; ++s)c = s + n, u = t[c], a[s] = { r: i.parse(hc(u, o), c) }; return a } const id = Number.EPSILON || 1e-14, od = (e, t) => t < e.length && !e[t].skip && e[t], ad = e => "x" === e ? "y" : "x"; function sd(e, t, n, r) { const i = e.skip ? t : e, o = t, a = n.skip ? t : n, s = Lc(o, i), l = Lc(a, o); let c = s / (s + l), u = l / (s + l); c = isNaN(c) ? 0 : c, u = isNaN(u) ? 0 : u; const d = r * c, h = r * u; return { previous: { x: o.x - d * (a.x - i.x), y: o.y - d * (a.y - i.y) }, next: { x: o.x + h * (a.x - i.x), y: o.y + h * (a.y - i.y) } } } function ld(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x"; const n = ad(t), r = e.length, i = Array(r).fill(0), o = Array(r); let a, s, l, c = od(e, 0); for (a = 0; a < r; ++a)if (s = l, l = c, c = od(e, a + 1), l) { if (c) { const e = c[t] - l[t]; i[a] = 0 !== e ? (c[n] - l[n]) / e : 0 } o[a] = s ? c ? Ec(i[a - 1]) !== Ec(i[a]) ? 0 : (i[a - 1] + i[a]) / 2 : i[a - 1] : i[a] } !function (e, t, n) { const r = e.length; let i, o, a, s, l, c = od(e, 0); for (let u = 0; u < r - 1; ++u)l = c, c = od(e, u + 1), l && c && (Mc(t[u], 0, id) ? n[u] = n[u + 1] = 0 : (i = n[u] / t[u], o = n[u + 1] / t[u], s = Math.pow(i, 2) + Math.pow(o, 2), s <= 9 || (a = 3 / Math.sqrt(s), n[u] = i * a * t[u], n[u + 1] = o * a * t[u]))) }(e, i, o), function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "x"; const r = ad(n), i = e.length; let o, a, s, l = od(e, 0); for (let c = 0; c < i; ++c) { if (a = s, s = l, l = od(e, c + 1), !s) continue; const i = s[n], u = s[r]; a && (o = (i - a[n]) / 3, s["cp1".concat(n)] = i - o, s["cp1".concat(r)] = u - o * t[c]), l && (o = (l[n] - i) / 3, s["cp2".concat(n)] = i + o, s["cp2".concat(r)] = u + o * t[c]) } }(e, o, t) } function cd(e, t, n) { return Math.max(Math.min(e, n), t) } function ud(e, t, n, r, i) { let o, a, s, l; if (t.spanGaps && (e = e.filter((e => !e.skip))), "monotone" === t.cubicInterpolationMode) ld(e, i); else { let n = r ? e[e.length - 1] : e[0]; for (o = 0, a = e.length; o < a; ++o)s = e[o], l = sd(n, s, e[Math.min(o + 1, a - (r ? 0 : 1)) % a], t.tension), s.cp1x = l.previous.x, s.cp1y = l.previous.y, s.cp2x = l.next.x, s.cp2y = l.next.y, n = s } t.capBezierPoints && function (e, t) { let n, r, i, o, a, s = Su(e[0], t); for (n = 0, r = e.length; n < r; ++n)a = o, o = s, s = n < r - 1 && Su(e[n + 1], t), o && (i = e[n], a && (i.cp1x = cd(i.cp1x, t.left, t.right), i.cp1y = cd(i.cp1y, t.top, t.bottom)), s && (i.cp2x = cd(i.cp2x, t.left, t.right), i.cp2y = cd(i.cp2y, t.top, t.bottom))) }(e, n) } function dd() { return "undefined" !== typeof window && "undefined" !== typeof document } function hd(e) { let t = e.parentNode; return t && "[object ShadowRoot]" === t.toString() && (t = t.host), t } function fd(e, t, n) { let r; return "string" === typeof e ? (r = parseInt(e, 10), -1 !== e.indexOf("%") && (r = r / 100 * t.parentNode[n])) : r = e, r } const pd = e => e.ownerDocument.defaultView.getComputedStyle(e, null); const gd = ["top", "right", "bottom", "left"]; function md(e, t, n) { const r = {}; n = n ? "-" + n : ""; for (let i = 0; i < 4; i++) { const o = gd[i]; r[o] = parseFloat(e[t + "-" + o + n]) || 0 } return r.width = r.left + r.right, r.height = r.top + r.bottom, r } const bd = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot); function vd(e, t) { if ("native" in e) return e; const { canvas: n, currentDevicePixelRatio: r } = t, i = pd(n), o = "border-box" === i.boxSizing, a = md(i, "padding"), s = md(i, "border", "width"), { x: l, y: c, box: u } = function (e, t) { const n = e.touches, r = n && n.length ? n[0] : e, { offsetX: i, offsetY: o } = r; let a, s, l = !1; if (bd(i, o, e.target)) a = i, s = o; else { const e = t.getBoundingClientRect(); a = r.clientX - e.left, s = r.clientY - e.top, l = !0 } return { x: a, y: s, box: l } }(e, n), d = a.left + (u && s.left), h = a.top + (u && s.top); let { width: f, height: p } = t; return o && (f -= a.width + s.width, p -= a.height + s.height), { x: Math.round((l - d) / f * n.width / r), y: Math.round((c - h) / p * n.height / r) } } const yd = e => Math.round(10 * e) / 10; function xd(e, t, n, r) { const i = pd(e), o = md(i, "margin"), a = fd(i.maxWidth, e, "clientWidth") || xc, s = fd(i.maxHeight, e, "clientHeight") || xc, l = function (e, t, n) { let r, i; if (void 0 === t || void 0 === n) { const o = hd(e); if (o) { const e = o.getBoundingClientRect(), a = pd(o), s = md(a, "border", "width"), l = md(a, "padding"); t = e.width - l.width - s.width, n = e.height - l.height - s.height, r = fd(a.maxWidth, o, "clientWidth"), i = fd(a.maxHeight, o, "clientHeight") } else t = e.clientWidth, n = e.clientHeight } return { width: t, height: n, maxWidth: r || xc, maxHeight: i || xc } }(e, t, n); let { width: c, height: u } = l; if ("content-box" === i.boxSizing) { const e = md(i, "border", "width"), t = md(i, "padding"); c -= t.width + e.width, u -= t.height + e.height } c = Math.max(0, c - o.width), u = Math.max(0, r ? c / r : u - o.height), c = yd(Math.min(c, a, l.maxWidth)), u = yd(Math.min(u, s, l.maxHeight)), c && !u && (u = yd(c / 2)); return (void 0 !== t || void 0 !== n) && r && l.height && u > l.height && (u = l.height, c = yd(Math.floor(u * r))), { width: c, height: u } } function wd(e, t, n) { const r = t || 1, i = Math.floor(e.height * r), o = Math.floor(e.width * r); e.height = Math.floor(e.height), e.width = Math.floor(e.width); const a = e.canvas; return a.style && (n || !a.style.height && !a.style.width) && (a.style.height = "".concat(e.height, "px"), a.style.width = "".concat(e.width, "px")), (e.currentDevicePixelRatio !== r || a.height !== i || a.width !== o) && (e.currentDevicePixelRatio = r, a.height = i, a.width = o, e.ctx.setTransform(r, 0, 0, r, 0, 0), !0) } const _d = function () { let e = !1; try { const t = { get passive() { return e = !0, !1 } }; dd() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t)) } catch (Da) { } return e }(); function kd(e, t) { const n = function (e, t) { return pd(e).getPropertyValue(t) }(e, t), r = n && n.match(/^(\d+)(\.\d+)?px$/); return r ? +r[1] : void 0 } function Sd(e, t, n, r) { return { x: e.x + n * (t.x - e.x), y: e.y + n * (t.y - e.y) } } function Cd(e, t, n, r) { return { x: e.x + n * (t.x - e.x), y: "middle" === r ? n < .5 ? e.y : t.y : "after" === r ? n < 1 ? e.y : t.y : n > 0 ? t.y : e.y } } function Ed(e, t, n, r) { const i = { x: e.cp2x, y: e.cp2y }, o = { x: t.cp1x, y: t.cp1y }, a = Sd(e, i, n), s = Sd(i, o, n), l = Sd(o, t, n), c = Sd(a, s, n), u = Sd(s, l, n); return Sd(c, u, n) } function Md(e, t, n) { return e ? function (e, t) { return { x: n => e + e + t - n, setWidth(e) { t = e }, textAlign: e => "center" === e ? e : "right" === e ? "left" : "right", xPlus: (e, t) => e - t, leftForLtr: (e, t) => e - t } }(t, n) : { x: e => e, setWidth(e) { }, textAlign: e => e, xPlus: (e, t) => e + t, leftForLtr: (e, t) => e } } function Od(e, t) { let n, r; "ltr" !== t && "rtl" !== t || (n = e.canvas.style, r = [n.getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", t, "important"), e.prevTextDirection = r) } function Pd(e, t) { void 0 !== t && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1])) } function Nd(e) { return "angle" === e ? { between: Ic, compare: Ac, normalize: zc } : { between: Bc, compare: (e, t) => e - t, normalize: e => e } } function Td(e) { let { start: t, end: n, count: r, loop: i, style: o } = e; return { start: t % r, end: n % r, loop: i && (n - t + 1) % r === 0, style: o } } function jd(e, t, n) { if (!n) return [e]; const { property: r, start: i, end: o } = n, a = t.length, { compare: s, between: l, normalize: c } = Nd(r), { start: u, end: d, loop: h, style: f } = function (e, t, n) { const { property: r, start: i, end: o } = n, { between: a, normalize: s } = Nd(r), l = t.length; let c, u, { start: d, end: h, loop: f } = e; if (f) { for (d += l, h += l, c = 0, u = l; c < u && a(s(t[d % l][r]), i, o); ++c)d--, h--; d %= l, h %= l } return h < d && (h += l), { start: d, end: h, loop: f, style: e.style } }(e, t, n), p = []; let g, m, b, v = !1, y = null; const x = () => v || l(i, b, g) && 0 !== s(i, b), w = () => !v || 0 === s(o, g) || l(o, b, g); for (let _ = u, k = u; _ <= d; ++_)m = t[_ % a], m.skip || (g = c(m[r]), g !== b && (v = l(g, i, o), null === y && x() && (y = 0 === s(g, i) ? _ : k), null !== y && w() && (p.push(Td({ start: y, end: _, loop: h, count: a, style: f })), y = null), k = _, b = g)); return null !== y && p.push(Td({ start: y, end: d, loop: h, count: a, style: f })), p } function Dd(e, t) { const n = [], r = e.segments; for (let i = 0; i < r.length; i++) { const o = jd(r[i], e.points, t); o.length && n.push(...o) } return n } function Rd(e, t, n, r) { return r && r.setContext && n ? function (e, t, n, r) { const i = e._chart.getContext(), o = Ld(e.options), { _datasetIndex: a, options: { spanGaps: s } } = e, l = n.length, c = []; let u = o, d = t[0].start, h = d; function f(e, t, r, i) { const o = s ? -1 : 1; if (e !== t) { for (e += l; n[e % l].skip;)e -= o; for (; n[t % l].skip;)t += o; e % l !== t % l && (c.push({ start: e % l, end: t % l, loop: r, style: i }), u = i, d = t % l) } } for (const p of t) { d = s ? d : p.start; let e, t = n[d % l]; for (h = d + 1; h <= p.end; h++) { const o = n[h % l]; e = Ld(r.setContext(Hu(i, { type: "segment", p0: t, p1: o, p0DataIndex: (h - 1) % l, p1DataIndex: h % l, datasetIndex: a }))), Ad(e, u) && f(d, h - 1, p.loop, u), t = o, u = e } d < h - 1 && f(d, h - 1, p.loop, u) } return c }(e, t, n, r) : t } function Ld(e) { return { backgroundColor: e.backgroundColor, borderCapStyle: e.borderCapStyle, borderDash: e.borderDash, borderDashOffset: e.borderDashOffset, borderJoinStyle: e.borderJoinStyle, borderWidth: e.borderWidth, borderColor: e.borderColor } } function Ad(e, t) { if (!t) return !1; const n = [], r = function (e, t) { return ru(t) ? (n.includes(t) || n.push(t), n.indexOf(t)) : t }; return JSON.stringify(e, r) !== JSON.stringify(t, r) } class zd { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(e, t, n, r) { const i = t.listeners[r], o = t.duration; i.forEach((r => r({ chart: e, initial: t.initial, numSteps: o, currentStep: Math.min(n - t.start, o) }))) } _refresh() { this._request || (this._running = !0, this._request = qc.call(window, (() => { this._update(), this._request = null, this._running && this._refresh() }))) } _update() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Date.now(), t = 0; this._charts.forEach(((n, r) => { if (!n.running || !n.items.length) return; const i = n.items; let o, a = i.length - 1, s = !1; for (; a >= 0; --a)o = i[a], o._active ? (o._total > n.duration && (n.duration = o._total), o.tick(e), s = !0) : (i[a] = i[i.length - 1], i.pop()); s && (r.draw(), this._notify(r, n, e, "progress")), i.length || (n.running = !1, this._notify(r, n, e, "complete"), n.initial = !1), t += i.length })), this._lastDate = e, 0 === t && (this._running = !1) } _getAnims(e) { const t = this._charts; let n = t.get(e); return n || (n = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, t.set(e, n)), n } listen(e, t, n) { this._getAnims(e).listeners[t].push(n) } add(e, t) { t && t.length && this._getAnims(e).items.push(...t) } has(e) { return this._getAnims(e).items.length > 0 } start(e) { const t = this._charts.get(e); t && (t.running = !0, t.start = Date.now(), t.duration = t.items.reduce(((e, t) => Math.max(e, t._duration)), 0), this._refresh()) } running(e) { if (!this._running) return !1; const t = this._charts.get(e); return !!(t && t.running && t.items.length) } stop(e) { const t = this._charts.get(e); if (!t || !t.items.length) return; const n = t.items; let r = n.length - 1; for (; r >= 0; --r)n[r].cancel(); t.items = [], this._notify(e, t, Date.now(), "complete") } remove(e) { return this._charts.delete(e) } } var Id = new zd; const Fd = "transparent", Bd = { boolean: (e, t, n) => n > .5 ? t : e, color(e, t, n) { const r = iu(e || Fd), i = r.valid && iu(t || Fd); return i && i.valid ? i.mix(r, n).hexString() : t }, number: (e, t, n) => e + (t - e) * n }; class Wd { constructor(e, t, n, r) { const i = t[n]; r = Vu([e.to, r, i, e.from]); const o = Vu([e.from, i, r]); this._active = !0, this._fn = e.fn || Bd[e.type || typeof o], this._easing = nu[e.easing] || nu.linear, this._start = Math.floor(Date.now() + (e.delay || 0)), this._duration = this._total = Math.floor(e.duration), this._loop = !!e.loop, this._target = t, this._prop = n, this._from = o, this._to = r, this._promises = void 0 } active() { return this._active } update(e, t, n) { if (this._active) { this._notify(!1); const r = this._target[this._prop], i = n - this._start, o = this._duration - i; this._start = n, this._duration = Math.floor(Math.max(o, e.duration)), this._total += i, this._loop = !!e.loop, this._to = Vu([e.to, t, r, e.from]), this._from = Vu([e.from, r, t]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(e) { const t = e - this._start, n = this._duration, r = this._prop, i = this._from, o = this._loop, a = this._to; let s; if (this._active = i !== a && (o || t < n), !this._active) return this._target[r] = a, void this._notify(!0); t < 0 ? this._target[r] = i : (s = t / n % 2, s = o && s > 1 ? 2 - s : s, s = this._easing(Math.min(1, Math.max(0, s))), this._target[r] = this._fn(i, a, s)) } wait() { const e = this._promises || (this._promises = []); return new Promise(((t, n) => { e.push({ res: t, rej: n }) })) } _notify(e) { const t = e ? "res" : "rej", n = this._promises || []; for (let r = 0; r < n.length; r++)n[r][t]() } } class Vd { constructor(e, t) { this._chart = e, this._properties = new Map, this.configure(t) } configure(e) { if (!Gl(e)) return; const t = Object.keys(bu.animation), n = this._properties; Object.getOwnPropertyNames(e).forEach((r => { const i = e[r]; if (!Gl(i)) return; const o = {}; for (const e of t) o[e] = i[e]; (Xl(i.properties) && i.properties || [r]).forEach((e => { e !== r && n.has(e) || n.set(e, o) })) })) } _animateOptions(e, t) { const n = t.options, r = function (e, t) { if (!t) return; let n = e.options; if (!n) return void (e.options = t); n.$shared && (e.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })); return n }(e, n); if (!r) return []; const i = this._createAnimations(r, n); return n.$shared && function (e, t) { const n = [], r = Object.keys(t); for (let i = 0; i < r.length; i++) { const t = e[r[i]]; t && t.active() && n.push(t.wait()) } return Promise.all(n) }(e.options.$animations, n).then((() => { e.options = n }), (() => { })), i } _createAnimations(e, t) { const n = this._properties, r = [], i = e.$animations || (e.$animations = {}), o = Object.keys(t), a = Date.now(); let s; for (s = o.length - 1; s >= 0; --s) { const l = o[s]; if ("$" === l.charAt(0)) continue; if ("options" === l) { r.push(...this._animateOptions(e, t)); continue } const c = t[l]; let u = i[l]; const d = n.get(l); if (u) { if (d && u.active()) { u.update(d, c, a); continue } u.cancel() } d && d.duration ? (i[l] = u = new Wd(d, e, l, c), r.push(u)) : e[l] = c } return r } update(e, t) { if (0 === this._properties.size) return void Object.assign(e, t); const n = this._createAnimations(e, t); return n.length ? (Id.add(this._chart, n), !0) : void 0 } } function Hd(e, t) { const n = e && e.options || {}, r = n.reverse, i = void 0 === n.min ? t : 0, o = void 0 === n.max ? t : 0; return { start: r ? o : i, end: r ? i : o } } function Ud(e, t) { const n = [], r = e._getSortedDatasetMetas(t); let i, o; for (i = 0, o = r.length; i < o; ++i)n.push(r[i].index); return n } function $d(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; const i = e.keys, o = "single" === r.mode; let a, s, l, c; if (null !== t) { for (a = 0, s = i.length; a < s; ++a) { if (l = +i[a], l === n) { if (r.all) continue; break } c = e.values[l], Jl(c) && (o || 0 === t || Ec(t) === Ec(c)) && (t += c) } return t } } function Yd(e, t) { const n = e && e.options.stacked; return n || void 0 === n && void 0 !== t.stack } function qd(e, t, n) { const r = e[t] || (e[t] = {}); return r[n] || (r[n] = {}) } function Kd(e, t, n, r) { for (const i of t.getMatchingVisibleMetas(r).reverse()) { const t = e[i.index]; if (n && t > 0 || !n && t < 0) return i.index } return null } function Qd(e, t) { const { chart: n, _cachedMeta: r } = e, i = n._stacks || (n._stacks = {}), { iScale: o, vScale: a, index: s } = r, l = o.axis, c = a.axis, u = function (e, t, n) { return "".concat(e.id, ".").concat(t.id, ".").concat(n.stack || n.type) }(o, a, r), d = t.length; let h; for (let f = 0; f < d; ++f) { const e = t[f], { [l]: n, [c]: o } = e; h = (e._stacks || (e._stacks = {}))[c] = qd(i, u, n), h[s] = o, h._top = Kd(h, a, !0, r.type), h._bottom = Kd(h, a, !1, r.type); (h._visualValues || (h._visualValues = {}))[s] = o } } function Xd(e, t) { const n = e.scales; return Object.keys(n).filter((e => n[e].axis === t)).shift() } function Gd(e, t) { const n = e.controller.index, r = e.vScale && e.vScale.axis; if (r) { t = t || e._parsed; for (const e of t) { const t = e._stacks; if (!t || void 0 === t[r] || void 0 === t[r][n]) return; delete t[r][n], void 0 !== t[r]._visualValues && void 0 !== t[r]._visualValues[n] && delete t[r]._visualValues[n] } } } const Jd = e => "reset" === e || "none" === e, Zd = (e, t) => t ? e : Object.assign({}, e); class eh { constructor(e, t) { this.chart = e, this._ctx = e.ctx, this.index = t, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize() { const e = this._cachedMeta; this.configure(), this.linkScales(), e._stacked = Yd(e.vScale, e), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex(e) { this.index !== e && Gd(this._cachedMeta), this.index = e } linkScales() { const e = this.chart, t = this._cachedMeta, n = this.getDataset(), r = (e, t, n, r) => "x" === e ? t : "r" === e ? r : n, i = t.xAxisID = ec(n.xAxisID, Xd(e, "x")), o = t.yAxisID = ec(n.yAxisID, Xd(e, "y")), a = t.rAxisID = ec(n.rAxisID, Xd(e, "r")), s = t.indexAxis, l = t.iAxisID = r(s, i, o, a), c = t.vAxisID = r(s, o, i, a); t.xScale = this.getScaleForId(i), t.yScale = this.getScaleForId(o), t.rScale = this.getScaleForId(a), t.iScale = this.getScaleForId(l), t.vScale = this.getScaleForId(c) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(e) { return this.chart.scales[e] } _getOtherScale(e) { const t = this._cachedMeta; return e === t.iScale ? t.vScale : t.iScale } reset() { this._update("reset") } _destroy() { const e = this._cachedMeta; this._data && $c(this._data, this), e._stacked && Gd(e) } _dataCheck() { const e = this.getDataset(), t = e.data || (e.data = []), n = this._data; if (Gl(t)) this._data = function (e) { const t = Object.keys(e), n = new Array(t.length); let r, i, o; for (r = 0, i = t.length; r < i; ++r)o = t[r], n[r] = { x: o, y: e[o] }; return n }(t); else if (n !== t) { if (n) { $c(n, this); const e = this._cachedMeta; Gd(e), e._parsed = [] } t && Object.isExtensible(t) && (i = this, (r = t)._chartjs ? r._chartjs.listeners.push(i) : (Object.defineProperty(r, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [i] } }), Uc.forEach((e => { const t = "_onData" + fc(e), n = r[e]; Object.defineProperty(r, e, { configurable: !0, enumerable: !1, value() { for (var e = arguments.length, i = new Array(e), o = 0; o < e; o++)i[o] = arguments[o]; const a = n.apply(this, i); return r._chartjs.listeners.forEach((e => { "function" === typeof e[t] && e[t](...i) })), a } }) })))), this._syncList = [], this._data = t } var r, i } addElements() { const e = this._cachedMeta; this._dataCheck(), this.datasetElementType && (e.dataset = new this.datasetElementType) } buildOrUpdateElements(e) { const t = this._cachedMeta, n = this.getDataset(); let r = !1; this._dataCheck(); const i = t._stacked; t._stacked = Yd(t.vScale, t), t.stack !== n.stack && (r = !0, Gd(t), t.stack = n.stack), this._resyncElements(e), (r || i !== t._stacked) && Qd(this, t._parsed) } configure() { const e = this.chart.config, t = e.datasetScopeKeys(this._type), n = e.getOptionScopes(this.getDataset(), t, !0); this.options = e.createResolver(n, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(e, t) { const { _cachedMeta: n, _data: r } = this, { iScale: i, _stacked: o } = n, a = i.axis; let s, l, c, u = 0 === e && t === r.length || n._sorted, d = e > 0 && n._parsed[e - 1]; if (!1 === this._parsing) n._parsed = r, n._sorted = !0, c = r; else { c = Xl(r[e]) ? this.parseArrayData(n, r, e, t) : Gl(r[e]) ? this.parseObjectData(n, r, e, t) : this.parsePrimitiveData(n, r, e, t); const i = () => null === l[a] || d && l[a] < d[a]; for (s = 0; s < t; ++s)n._parsed[s + e] = l = c[s], u && (i() && (u = !1), d = l); n._sorted = u } o && Qd(this, c) } parsePrimitiveData(e, t, n, r) { const { iScale: i, vScale: o } = e, a = i.axis, s = o.axis, l = i.getLabels(), c = i === o, u = new Array(r); let d, h, f; for (d = 0, h = r; d < h; ++d)f = d + n, u[d] = { [a]: c || i.parse(l[f], f), [s]: o.parse(t[f], f) }; return u } parseArrayData(e, t, n, r) { const { xScale: i, yScale: o } = e, a = new Array(r); let s, l, c, u; for (s = 0, l = r; s < l; ++s)c = s + n, u = t[c], a[s] = { x: i.parse(u[0], c), y: o.parse(u[1], c) }; return a } parseObjectData(e, t, n, r) { const { xScale: i, yScale: o } = e, { xAxisKey: a = "x", yAxisKey: s = "y" } = this._parsing, l = new Array(r); let c, u, d, h; for (c = 0, u = r; c < u; ++c)d = c + n, h = t[d], l[c] = { x: i.parse(hc(h, a), d), y: o.parse(hc(h, s), d) }; return l } getParsed(e) { return this._cachedMeta._parsed[e] } getDataElement(e) { return this._cachedMeta.data[e] } applyStack(e, t, n) { const r = this.chart, i = this._cachedMeta, o = t[e.axis]; return $d({ keys: Ud(r, !0), values: t._stacks[e.axis]._visualValues }, o, i.index, { mode: n }) } updateRangeFromParsed(e, t, n, r) { const i = n[t.axis]; let o = null === i ? NaN : i; const a = r && n._stacks[t.axis]; r && a && (r.values = a, o = $d(r, i, this._cachedMeta.index)), e.min = Math.min(e.min, o), e.max = Math.max(e.max, o) } getMinMax(e, t) { const n = this._cachedMeta, r = n._parsed, i = n._sorted && e === n.iScale, o = r.length, a = this._getOtherScale(e), s = ((e, t, n) => e && !t.hidden && t._stacked && { keys: Ud(n, !0), values: null })(t, n, this.chart), l = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: c, max: u } = function (e) { const { min: t, max: n, minDefined: r, maxDefined: i } = e.getUserBounds(); return { min: r ? t : Number.NEGATIVE_INFINITY, max: i ? n : Number.POSITIVE_INFINITY } }(a); let d, h; function f() { h = r[d]; const t = h[a.axis]; return !Jl(h[e.axis]) || c > t || u < t } for (d = 0; d < o && (f() || (this.updateRangeFromParsed(l, e, h, s), !i)); ++d); if (i) for (d = o - 1; d >= 0; --d)if (!f()) { this.updateRangeFromParsed(l, e, h, s); break } return l } getAllParsedValues(e) { const t = this._cachedMeta._parsed, n = []; let r, i, o; for (r = 0, i = t.length; r < i; ++r)o = t[r][e.axis], Jl(o) && n.push(o); return n } getMaxOverflow() { return !1 } getLabelAndValue(e) { const t = this._cachedMeta, n = t.iScale, r = t.vScale, i = this.getParsed(e); return { label: n ? "" + n.getLabelForValue(i[n.axis]) : "", value: r ? "" + r.getLabelForValue(i[r.axis]) : "" } } _update(e) { const t = this._cachedMeta; this.update(e || "default"), t._clip = function (e) { let t, n, r, i; return Gl(e) ? (t = e.top, n = e.right, r = e.bottom, i = e.left) : t = n = r = i = e, { top: t, right: n, bottom: r, left: i, disabled: !1 === e } }(ec(this.options.clip, function (e, t, n) { if (!1 === n) return !1; const r = Hd(e, n), i = Hd(t, n); return { top: i.end, right: r.end, bottom: i.start, left: r.start } }(t.xScale, t.yScale, this.getMaxOverflow()))) } update(e) { } draw() { const e = this._ctx, t = this.chart, n = this._cachedMeta, r = n.data || [], i = t.chartArea, o = [], a = this._drawStart || 0, s = this._drawCount || r.length - a, l = this.options.drawActiveElementsOnTop; let c; for (n.dataset && n.dataset.draw(e, i, a, s), c = a; c < a + s; ++c) { const t = r[c]; t.hidden || (t.active && l ? o.push(t) : t.draw(e, i)) } for (c = 0; c < o.length; ++c)o[c].draw(e, i) } getStyle(e, t) { const n = t ? "active" : "default"; return void 0 === e && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(e || 0, n) } getContext(e, t, n) { const r = this.getDataset(); let i; if (e >= 0 && e < this._cachedMeta.data.length) { const t = this._cachedMeta.data[e]; i = t.$context || (t.$context = function (e, t, n) { return Hu(e, { active: !1, dataIndex: t, parsed: void 0, raw: void 0, element: n, index: t, mode: "default", type: "data" }) }(this.getContext(), e, t)), i.parsed = this.getParsed(e), i.raw = r.data[e], i.index = i.dataIndex = e } else i = this.$context || (this.$context = function (e, t) { return Hu(e, { active: !1, dataset: void 0, datasetIndex: t, index: t, mode: "default", type: "dataset" }) }(this.chart.getContext(), this.index)), i.dataset = r, i.index = i.datasetIndex = this.index; return i.active = !!t, i.mode = n, i } resolveDatasetElementOptions(e) { return this._resolveElementOptions(this.datasetElementType.id, e) } resolveDataElementOptions(e, t) { return this._resolveElementOptions(this.dataElementType.id, t, e) } _resolveElementOptions(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "default", n = arguments.length > 2 ? arguments[2] : void 0; const r = "active" === t, i = this._cachedDataOpts, o = e + "-" + t, a = i[o], s = this.enableOptionSharing && pc(n); if (a) return Zd(a, s); const l = this.chart.config, c = l.datasetElementScopeKeys(this._type, e), u = r ? ["".concat(e, "Hover"), "hover", e, ""] : [e, ""], d = l.getOptionScopes(this.getDataset(), c), h = Object.keys(bu.elements[e]), f = l.resolveNamedOptions(d, h, (() => this.getContext(n, r, t)), u); return f.$shared && (f.$shared = s, i[o] = Object.freeze(Zd(f, s))), f } _resolveAnimations(e, t, n) { const r = this.chart, i = this._cachedDataOpts, o = "animation-".concat(t), a = i[o]; if (a) return a; let s; if (!1 !== r.options.animation) { const r = this.chart.config, i = r.datasetAnimationScopeKeys(this._type, t), o = r.getOptionScopes(this.getDataset(), i); s = r.createResolver(o, this.getContext(e, n, t)) } const l = new Vd(r, s && s.animations); return s && s._cacheable && (i[o] = Object.freeze(l)), l } getSharedOptions(e) { if (e.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, e)) } includeOptions(e, t) { return !t || Jd(e) || this.chart._animationsDisabled } _getSharedOptions(e, t) { const n = this.resolveDataElementOptions(e, t), r = this._sharedOptions, i = this.getSharedOptions(n), o = this.includeOptions(t, i) || i !== r; return this.updateSharedOptions(i, t, n), { sharedOptions: i, includeOptions: o } } updateElement(e, t, n, r) { Jd(r) ? Object.assign(e, n) : this._resolveAnimations(t, r).update(e, n) } updateSharedOptions(e, t, n) { e && !Jd(t) && this._resolveAnimations(void 0, t).update(e, n) } _setStyle(e, t, n, r) { e.active = r; const i = this.getStyle(t, r); this._resolveAnimations(t, n, r).update(e, { options: !r && this.getSharedOptions(i) || i }) } removeHoverStyle(e, t, n) { this._setStyle(e, n, "active", !1) } setHoverStyle(e, t, n) { this._setStyle(e, n, "active", !0) } _removeDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !1) } _setDatasetHoverStyle() { const e = this._cachedMeta.dataset; e && this._setStyle(e, void 0, "active", !0) } _resyncElements(e) { const t = this._data, n = this._cachedMeta.data; for (const [a, s, l] of this._syncList) this[a](s, l); this._syncList = []; const r = n.length, i = t.length, o = Math.min(i, r); o && this.parse(0, o), i > r ? this._insertElements(r, i - r, e) : i < r && this._removeElements(i, r - i) } _insertElements(e, t) { let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; const r = this._cachedMeta, i = r.data, o = e + t; let a; const s = e => { for (e.length += t, a = e.length - 1; a >= o; a--)e[a] = e[a - t] }; for (s(i), a = e; a < o; ++a)i[a] = new this.dataElementType; this._parsing && s(r._parsed), this.parse(e, t), n && this.updateElements(i, e, t, "reset") } updateElements(e, t, n, r) { } _removeElements(e, t) { const n = this._cachedMeta; if (this._parsing) { const r = n._parsed.splice(e, t); n._stacked && Gd(n, r) } n.data.splice(e, t) } _sync(e) { if (this._parsing) this._syncList.push(e); else { const [t, n, r] = e; this[t](n, r) } this.chart._dataChanges.push([this.index, ...e]) } _onDataPush() { const e = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - e, e]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(e, t) { t && this._sync(["_removeElements", e, t]); const n = arguments.length - 2; n && this._sync(["_insertElements", e, n]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } function th(e) { const t = e.iScale, n = function (e, t) { if (!e._cache.$bar) { const n = e.getMatchingVisibleMetas(t); let r = []; for (let t = 0, i = n.length; t < i; t++)r = r.concat(n[t].controller.getAllParsedValues(e)); e._cache.$bar = Yc(r.sort(((e, t) => e - t))) } return e._cache.$bar }(t, e.type); let r, i, o, a, s = t._length; const l = () => { 32767 !== o && -32768 !== o && (pc(a) && (s = Math.min(s, Math.abs(o - a) || s)), a = o) }; for (r = 0, i = n.length; r < i; ++r)o = t.getPixelForValue(n[r]), l(); for (a = void 0, r = 0, i = t.ticks.length; r < i; ++r)o = t.getPixelForTick(r), l(); return s } function nh(e, t, n, r) { return Xl(e) ? function (e, t, n, r) { const i = n.parse(e[0], r), o = n.parse(e[1], r), a = Math.min(i, o), s = Math.max(i, o); let l = a, c = s; Math.abs(a) > Math.abs(s) && (l = s, c = a), t[n.axis] = c, t._custom = { barStart: l, barEnd: c, start: i, end: o, min: a, max: s } }(e, t, n, r) : t[n.axis] = n.parse(e, r), t } function rh(e, t, n, r) { const i = e.iScale, o = e.vScale, a = i.getLabels(), s = i === o, l = []; let c, u, d, h; for (c = n, u = n + r; c < u; ++c)h = t[c], d = {}, d[i.axis] = s || i.parse(a[c], c), l.push(nh(h, d, o, c)); return l } function ih(e) { return e && void 0 !== e.barStart && void 0 !== e.barEnd } function oh(e, t, n, r) { let i = t.borderSkipped; const o = {}; if (!i) return void (e.borderSkipped = o); if (!0 === i) return void (e.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }); const { start: a, end: s, reverse: l, top: c, bottom: u } = function (e) { let t, n, r, i, o; return e.horizontal ? (t = e.base > e.x, n = "left", r = "right") : (t = e.base < e.y, n = "bottom", r = "top"), t ? (i = "end", o = "start") : (i = "start", o = "end"), { start: n, end: r, reverse: t, top: i, bottom: o } }(e); "middle" === i && n && (e.enableBorderRadius = !0, (n._top || 0) === r ? i = c : (n._bottom || 0) === r ? i = u : (o[ah(u, a, s, l)] = !0, i = c)), o[ah(i, a, s, l)] = !0, e.borderSkipped = o } function ah(e, t, n, r) { var i, o, a; return r ? (a = n, e = sh(e = (i = e) === (o = t) ? a : i === a ? o : i, n, t)) : e = sh(e, t, n), e } function sh(e, t, n) { return "start" === e ? t : "end" === e ? n : e } function lh(e, t, n) { let { inflateAmount: r } = t; e.inflateAmount = "auto" === r ? 1 === n ? .33 : 0 : r } fl(eh, "defaults", {}), fl(eh, "datasetElementType", null), fl(eh, "dataElementType", null); class ch extends eh { parsePrimitiveData(e, t, n, r) { return rh(e, t, n, r) } parseArrayData(e, t, n, r) { return rh(e, t, n, r) } parseObjectData(e, t, n, r) { const { iScale: i, vScale: o } = e, { xAxisKey: a = "x", yAxisKey: s = "y" } = this._parsing, l = "x" === i.axis ? a : s, c = "x" === o.axis ? a : s, u = []; let d, h, f, p; for (d = n, h = n + r; d < h; ++d)p = t[d], f = {}, f[i.axis] = i.parse(hc(p, l), d), u.push(nh(hc(p, c), f, o, d)); return u } updateRangeFromParsed(e, t, n, r) { super.updateRangeFromParsed(e, t, n, r); const i = n._custom; i && t === this._cachedMeta.vScale && (e.min = Math.min(e.min, i.min), e.max = Math.max(e.max, i.max)) } getMaxOverflow() { return 0 } getLabelAndValue(e) { const t = this._cachedMeta, { iScale: n, vScale: r } = t, i = this.getParsed(e), o = i._custom, a = ih(o) ? "[" + o.start + ", " + o.end + "]" : "" + r.getLabelForValue(i[r.axis]); return { label: "" + n.getLabelForValue(i[n.axis]), value: a } } initialize() { this.enableOptionSharing = !0, super.initialize(); this._cachedMeta.stack = this.getDataset().stack } update(e) { const t = this._cachedMeta; this.updateElements(t.data, 0, t.data.length, e) } updateElements(e, t, n, r) { const i = "reset" === r, { index: o, _cachedMeta: { vScale: a } } = this, s = a.getBasePixel(), l = a.isHorizontal(), c = this._getRuler(), { sharedOptions: u, includeOptions: d } = this._getSharedOptions(t, r); for (let h = t; h < t + n; h++) { const t = this.getParsed(h), n = i || Ql(t[a.axis]) ? { base: s, head: s } : this._calculateBarValuePixels(h), f = this._calculateBarIndexPixels(h, c), p = (t._stacks || {})[a.axis], g = { horizontal: l, base: n.base, enableBorderRadius: !p || ih(t._custom) || o === p._top || o === p._bottom, x: l ? n.head : f.center, y: l ? f.center : n.head, height: l ? f.size : Math.abs(n.size), width: l ? Math.abs(n.size) : f.size }; d && (g.options = u || this.resolveDataElementOptions(h, e[h].active ? "active" : r)); const m = g.options || e[h].options; oh(g, m, p, o), lh(g, m, c.ratio), this.updateElement(e[h], h, g, r) } } _getStacks(e, t) { const { iScale: n } = this._cachedMeta, r = n.getMatchingVisibleMetas(this._type).filter((e => e.controller.options.grouped)), i = n.options.stacked, o = [], a = e => { const n = e.controller.getParsed(t), r = n && n[e.vScale.axis]; if (Ql(r) || isNaN(r)) return !0 }; for (const s of r) if ((void 0 === t || !a(s)) && ((!1 === i || -1 === o.indexOf(s.stack) || void 0 === i && void 0 === s.stack) && o.push(s.stack), s.index === e)) break; return o.length || o.push(void 0), o } _getStackCount(e) { return this._getStacks(void 0, e).length } _getStackIndex(e, t, n) { const r = this._getStacks(e, n), i = void 0 !== t ? r.indexOf(t) : -1; return -1 === i ? r.length - 1 : i } _getRuler() { const e = this.options, t = this._cachedMeta, n = t.iScale, r = []; let i, o; for (i = 0, o = t.data.length; i < o; ++i)r.push(n.getPixelForValue(this.getParsed(i)[n.axis], i)); const a = e.barThickness; return { min: a || th(t), pixels: r, start: n._startPixel, end: n._endPixel, stackCount: this._getStackCount(), scale: n, grouped: e.grouped, ratio: a ? 1 : e.categoryPercentage * e.barPercentage } } _calculateBarValuePixels(e) { const { _cachedMeta: { vScale: t, _stacked: n, index: r }, options: { base: i, minBarLength: o } } = this, a = i || 0, s = this.getParsed(e), l = s._custom, c = ih(l); let u, d, h = s[t.axis], f = 0, p = n ? this.applyStack(t, s, n) : h; p !== h && (f = p - h, p = h), c && (h = l.barStart, p = l.barEnd - l.barStart, 0 !== h && Ec(h) !== Ec(l.barEnd) && (f = 0), f += h); const g = Ql(i) || c ? f : i; let m = t.getPixelForValue(g); if (u = this.chart.getDataVisibility(e) ? t.getPixelForValue(f + p) : m, d = u - m, Math.abs(d) < o) { d = function (e, t, n) { return 0 !== e ? Ec(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= n ? 1 : -1) }(d, t, a) * o, h === a && (m -= d / 2); const e = t.getPixelForDecimal(0), i = t.getPixelForDecimal(1), l = Math.min(e, i), f = Math.max(e, i); m = Math.max(Math.min(m, f), l), u = m + d, n && !c && (s._stacks[t.axis]._visualValues[r] = t.getValueForPixel(u) - t.getValueForPixel(m)) } if (m === t.getPixelForValue(a)) { const e = Ec(d) * t.getLineWidthForValue(a) / 2; m += e, d -= e } return { size: d, base: m, head: u, center: u + d / 2 } } _calculateBarIndexPixels(e, t) { const n = t.scale, r = this.options, i = r.skipNull, o = ec(r.maxBarThickness, 1 / 0); let a, s; if (t.grouped) { const n = i ? this._getStackCount(e) : t.stackCount, l = "flex" === r.barThickness ? function (e, t, n, r) { const i = t.pixels, o = i[e]; let a = e > 0 ? i[e - 1] : null, s = e < i.length - 1 ? i[e + 1] : null; const l = n.categoryPercentage; null === a && (a = o - (null === s ? t.end - t.start : s - o)), null === s && (s = o + o - a); const c = o - (o - Math.min(a, s)) / 2 * l; return { chunk: Math.abs(s - a) / 2 * l / r, ratio: n.barPercentage, start: c } }(e, t, r, n) : function (e, t, n, r) { const i = n.barThickness; let o, a; return Ql(i) ? (o = t.min * n.categoryPercentage, a = n.barPercentage) : (o = i * r, a = 1), { chunk: o / r, ratio: a, start: t.pixels[e] - o / 2 } }(e, t, r, n), c = this._getStackIndex(this.index, this._cachedMeta.stack, i ? e : void 0); a = l.start + l.chunk * c + l.chunk / 2, s = Math.min(o, l.chunk * l.ratio) } else a = n.getPixelForValue(this.getParsed(e)[n.axis], e), s = Math.min(o, t.min * t.ratio); return { base: a - s / 2, head: a + s / 2, center: a, size: s } } draw() { const e = this._cachedMeta, t = e.vScale, n = e.data, r = n.length; let i = 0; for (; i < r; ++i)null !== this.getParsed(i)[t.axis] && n[i].draw(this._ctx) } } fl(ch, "id", "bar"), fl(ch, "defaults", { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }), fl(ch, "overrides", { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }); class uh extends eh { initialize() { this.enableOptionSharing = !0, super.initialize() } parsePrimitiveData(e, t, n, r) { const i = super.parsePrimitiveData(e, t, n, r); for (let o = 0; o < i.length; o++)i[o]._custom = this.resolveDataElementOptions(o + n).radius; return i } parseArrayData(e, t, n, r) { const i = super.parseArrayData(e, t, n, r); for (let o = 0; o < i.length; o++) { const e = t[n + o]; i[o]._custom = ec(e[2], this.resolveDataElementOptions(o + n).radius) } return i } parseObjectData(e, t, n, r) { const i = super.parseObjectData(e, t, n, r); for (let o = 0; o < i.length; o++) { const e = t[n + o]; i[o]._custom = ec(e && e.r && +e.r, this.resolveDataElementOptions(o + n).radius) } return i } getMaxOverflow() { const e = this._cachedMeta.data; let t = 0; for (let n = e.length - 1; n >= 0; --n)t = Math.max(t, e[n].size(this.resolveDataElementOptions(n)) / 2); return t > 0 && t } getLabelAndValue(e) { const t = this._cachedMeta, n = this.chart.data.labels || [], { xScale: r, yScale: i } = t, o = this.getParsed(e), a = r.getLabelForValue(o.x), s = i.getLabelForValue(o.y), l = o._custom; return { label: n[e] || "", value: "(" + a + ", " + s + (l ? ", " + l : "") + ")" } } update(e) { const t = this._cachedMeta.data; this.updateElements(t, 0, t.length, e) } updateElements(e, t, n, r) { const i = "reset" === r, { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: s, includeOptions: l } = this._getSharedOptions(t, r), c = o.axis, u = a.axis; for (let d = t; d < t + n; d++) { const t = e[d], n = !i && this.getParsed(d), h = {}, f = h[c] = i ? o.getPixelForDecimal(.5) : o.getPixelForValue(n[c]), p = h[u] = i ? a.getBasePixel() : a.getPixelForValue(n[u]); h.skip = isNaN(f) || isNaN(p), l && (h.options = s || this.resolveDataElementOptions(d, t.active ? "active" : r), i && (h.options.radius = 0)), this.updateElement(t, d, h, r) } } resolveDataElementOptions(e, t) { const n = this.getParsed(e); let r = super.resolveDataElementOptions(e, t); r.$shared && (r = Object.assign({}, r, { $shared: !1 })); const i = r.radius; return "active" !== t && (r.radius = 0), r.radius += ec(n && n._custom, i), r } } fl(uh, "id", "bubble"), fl(uh, "defaults", { datasetElementType: !1, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }), fl(uh, "overrides", { scales: { x: { type: "linear" }, y: { type: "linear" } } }); class dh extends eh { constructor(e, t) { super(e, t), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0 } linkScales() { } parse(e, t) { const n = this.getDataset().data, r = this._cachedMeta; if (!1 === this._parsing) r._parsed = n; else { let i, o, a = e => +n[e]; if (Gl(n[e])) { const { key: e = "value" } = this._parsing; a = t => +hc(n[t], e) } for (i = e, o = e + t; i < o; ++i)r._parsed[i] = a(i) } } _getRotation() { return Tc(this.options.rotation - 90) } _getCircumference() { return Tc(this.options.circumference) } _getRotationExtents() { let e = vc, t = -vc; for (let n = 0; n < this.chart.data.datasets.length; ++n)if (this.chart.isDatasetVisible(n) && this.chart.getDatasetMeta(n).type === this._type) { const r = this.chart.getDatasetMeta(n).controller, i = r._getRotation(), o = r._getCircumference(); e = Math.min(e, i), t = Math.max(t, i + o) } return { rotation: e, circumference: t - e } } update(e) { const t = this.chart, { chartArea: n } = t, r = this._cachedMeta, i = r.data, o = this.getMaxBorderWidth() + this.getMaxOffset(i) + this.options.spacing, a = Math.max((Math.min(n.width, n.height) - o) / 2, 0), s = Math.min((l = this.options.cutout, c = a, "string" === typeof l && l.endsWith("%") ? parseFloat(l) / 100 : +l / c), 1); var l, c; const u = this._getRingWeight(this.index), { circumference: d, rotation: h } = this._getRotationExtents(), { ratioX: f, ratioY: p, offsetX: g, offsetY: m } = function (e, t, n) { let r = 1, i = 1, o = 0, a = 0; if (t < vc) { const s = e, l = s + t, c = Math.cos(s), u = Math.sin(s), d = Math.cos(l), h = Math.sin(l), f = (e, t, r) => Ic(e, s, l, !0) ? 1 : Math.max(t, t * n, r, r * n), p = (e, t, r) => Ic(e, s, l, !0) ? -1 : Math.min(t, t * n, r, r * n), g = f(0, c, d), m = f(_c, u, h), b = p(bc, c, d), v = p(bc + _c, u, h); r = (g - b) / 2, i = (m - v) / 2, o = -(g + b) / 2, a = -(m + v) / 2 } return { ratioX: r, ratioY: i, offsetX: o, offsetY: a } }(h, d, s), b = (n.width - o) / f, v = (n.height - o) / p, y = Math.max(Math.min(b, v) / 2, 0), x = tc(this.options.radius, y), w = (x - Math.max(x * s, 0)) / this._getVisibleDatasetWeightTotal(); this.offsetX = g * x, this.offsetY = m * x, r.total = this.calculateTotal(), this.outerRadius = x - w * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - w * u, 0), this.updateElements(i, 0, i.length, e) } _circumference(e, t) { const n = this.options, r = this._cachedMeta, i = this._getCircumference(); return t && n.animation.animateRotate || !this.chart.getDataVisibility(e) || null === r._parsed[e] || r.data[e].hidden ? 0 : this.calculateCircumference(r._parsed[e] * i / vc) } updateElements(e, t, n, r) { const i = "reset" === r, o = this.chart, a = o.chartArea, s = o.options.animation, l = (a.left + a.right) / 2, c = (a.top + a.bottom) / 2, u = i && s.animateScale, d = u ? 0 : this.innerRadius, h = u ? 0 : this.outerRadius, { sharedOptions: f, includeOptions: p } = this._getSharedOptions(t, r); let g, m = this._getRotation(); for (g = 0; g < t; ++g)m += this._circumference(g, i); for (g = t; g < t + n; ++g) { const t = this._circumference(g, i), n = e[g], o = { x: l + this.offsetX, y: c + this.offsetY, startAngle: m, endAngle: m + t, circumference: t, outerRadius: h, innerRadius: d }; p && (o.options = f || this.resolveDataElementOptions(g, n.active ? "active" : r)), m += t, this.updateElement(n, g, o, r) } } calculateTotal() { const e = this._cachedMeta, t = e.data; let n, r = 0; for (n = 0; n < t.length; n++) { const i = e._parsed[n]; null === i || isNaN(i) || !this.chart.getDataVisibility(n) || t[n].hidden || (r += Math.abs(i)) } return r } calculateCircumference(e) { const t = this._cachedMeta.total; return t > 0 && !isNaN(e) ? vc * (Math.abs(e) / t) : 0 } getLabelAndValue(e) { const t = this._cachedMeta, n = this.chart, r = n.data.labels || [], i = cu(t._parsed[e], n.options.locale); return { label: r[e] || "", value: i } } getMaxBorderWidth(e) { let t = 0; const n = this.chart; let r, i, o, a, s; if (!e) for (r = 0, i = n.data.datasets.length; r < i; ++r)if (n.isDatasetVisible(r)) { o = n.getDatasetMeta(r), e = o.data, a = o.controller; break } if (!e) return 0; for (r = 0, i = e.length; r < i; ++r)s = a.resolveDataElementOptions(r), "inner" !== s.borderAlign && (t = Math.max(t, s.borderWidth || 0, s.hoverBorderWidth || 0)); return t } getMaxOffset(e) { let t = 0; for (let n = 0, r = e.length; n < r; ++n) { const e = this.resolveDataElementOptions(n); t = Math.max(t, e.offset || 0, e.hoverOffset || 0) } return t } _getRingWeightOffset(e) { let t = 0; for (let n = 0; n < e; ++n)this.chart.isDatasetVisible(n) && (t += this._getRingWeight(n)); return t } _getRingWeight(e) { return Math.max(ec(this.chart.data.datasets[e].weight, 1), 0) } _getVisibleDatasetWeightTotal() { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } } fl(dh, "id", "doughnut"), fl(dh, "defaults", { datasetElementType: !1, dataElementType: "arc", animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", spacing: 0, indexAxis: "r" }), fl(dh, "descriptors", { _scriptable: e => "spacing" !== e, _indexable: e => "spacing" !== e && !e.startsWith("borderDash") && !e.startsWith("hoverBorderDash") }), fl(dh, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(e) { const t = e.data; if (t.labels.length && t.datasets.length) { const { labels: { pointStyle: n, color: r } } = e.legend.options; return t.labels.map(((t, i) => { const o = e.getDatasetMeta(0).controller.getStyle(i); return { text: t, fillStyle: o.backgroundColor, strokeStyle: o.borderColor, fontColor: r, lineWidth: o.borderWidth, pointStyle: n, hidden: !e.getDataVisibility(i), index: i } })) } return [] } }, onClick(e, t, n) { n.chart.toggleDataVisibility(t.index), n.chart.update() } } } }); class hh extends eh { initialize() { this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize() } update(e) { const t = this._cachedMeta, { dataset: n, data: r = [], _dataset: i } = t, o = this.chart._animationsDisabled; let { start: a, count: s } = Gc(t, r, o); this._drawStart = a, this._drawCount = s, Jc(t) && (a = 0, s = r.length), n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!i._decimated, n.points = r; const l = this.resolveDatasetElementOptions(e); this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(n, void 0, { animated: !o, options: l }, e), this.updateElements(r, a, s, e) } updateElements(e, t, n, r) { const i = "reset" === r, { iScale: o, vScale: a, _stacked: s, _dataset: l } = this._cachedMeta, { sharedOptions: c, includeOptions: u } = this._getSharedOptions(t, r), d = o.axis, h = a.axis, { spanGaps: f, segment: p } = this.options, g = Pc(f) ? f : Number.POSITIVE_INFINITY, m = this.chart._animationsDisabled || i || "none" === r, b = t + n, v = e.length; let y = t > 0 && this.getParsed(t - 1); for (let x = 0; x < v; ++x) { const n = e[x], f = m ? n : {}; if (x < t || x >= b) { f.skip = !0; continue } const v = this.getParsed(x), w = Ql(v[h]), _ = f[d] = o.getPixelForValue(v[d], x), k = f[h] = i || w ? a.getBasePixel() : a.getPixelForValue(s ? this.applyStack(a, v, s) : v[h], x); f.skip = isNaN(_) || isNaN(k) || w, f.stop = x > 0 && Math.abs(v[d] - y[d]) > g, p && (f.parsed = v, f.raw = l.data[x]), u && (f.options = c || this.resolveDataElementOptions(x, n.active ? "active" : r)), m || this.updateElement(n, x, f, r), y = v } } getMaxOverflow() { const e = this._cachedMeta, t = e.dataset, n = t.options && t.options.borderWidth || 0, r = e.data || []; if (!r.length) return n; const i = r[0].size(this.resolveDataElementOptions(0)), o = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1)); return Math.max(n, i, o) / 2 } draw() { const e = this._cachedMeta; e.dataset.updateControlPoints(this.chart.chartArea, e.iScale.axis), super.draw() } } fl(hh, "id", "line"), fl(hh, "defaults", { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }), fl(hh, "overrides", { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }); class fh extends eh { constructor(e, t) { super(e, t), this.innerRadius = void 0, this.outerRadius = void 0 } getLabelAndValue(e) { const t = this._cachedMeta, n = this.chart, r = n.data.labels || [], i = cu(t._parsed[e].r, n.options.locale); return { label: r[e] || "", value: i } } parseObjectData(e, t, n, r) { return rd.bind(this)(e, t, n, r) } update(e) { const t = this._cachedMeta.data; this._updateRadius(), this.updateElements(t, 0, t.length, e) } getMinMax() { const e = this._cachedMeta, t = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; return e.data.forEach(((e, n) => { const r = this.getParsed(n).r; !isNaN(r) && this.chart.getDataVisibility(n) && (r < t.min && (t.min = r), r > t.max && (t.max = r)) })), t } _updateRadius() { const e = this.chart, t = e.chartArea, n = e.options, r = Math.min(t.right - t.left, t.bottom - t.top), i = Math.max(r / 2, 0), o = (i - Math.max(n.cutoutPercentage ? i / 100 * n.cutoutPercentage : 1, 0)) / e.getVisibleDatasetCount(); this.outerRadius = i - o * this.index, this.innerRadius = this.outerRadius - o } updateElements(e, t, n, r) { const i = "reset" === r, o = this.chart, a = o.options.animation, s = this._cachedMeta.rScale, l = s.xCenter, c = s.yCenter, u = s.getIndexAngle(0) - .5 * bc; let d, h = u; const f = 360 / this.countVisibleElements(); for (d = 0; d < t; ++d)h += this._computeAngle(d, r, f); for (d = t; d < t + n; d++) { const t = e[d]; let n = h, p = h + this._computeAngle(d, r, f), g = o.getDataVisibility(d) ? s.getDistanceFromCenterForValue(this.getParsed(d).r) : 0; h = p, i && (a.animateScale && (g = 0), a.animateRotate && (n = p = u)); const m = { x: l, y: c, innerRadius: 0, outerRadius: g, startAngle: n, endAngle: p, options: this.resolveDataElementOptions(d, t.active ? "active" : r) }; this.updateElement(t, d, m, r) } } countVisibleElements() { const e = this._cachedMeta; let t = 0; return e.data.forEach(((e, n) => { !isNaN(this.getParsed(n).r) && this.chart.getDataVisibility(n) && t++ })), t } _computeAngle(e, t, n) { return this.chart.getDataVisibility(e) ? Tc(this.resolveDataElementOptions(e, t).angle || n) : 0 } } fl(fh, "id", "polarArea"), fl(fh, "defaults", { dataElementType: "arc", animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 }), fl(fh, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(e) { const t = e.data; if (t.labels.length && t.datasets.length) { const { labels: { pointStyle: n, color: r } } = e.legend.options; return t.labels.map(((t, i) => { const o = e.getDatasetMeta(0).controller.getStyle(i); return { text: t, fillStyle: o.backgroundColor, strokeStyle: o.borderColor, fontColor: r, lineWidth: o.borderWidth, pointStyle: n, hidden: !e.getDataVisibility(i), index: i } })) } return [] } }, onClick(e, t, n) { n.chart.toggleDataVisibility(t.index), n.chart.update() } } }, scales: { r: { type: "radialLinear", angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }); class ph extends dh { } fl(ph, "id", "pie"), fl(ph, "defaults", { cutout: 0, rotation: 0, circumference: 360, radius: "100%" }); class gh extends eh { getLabelAndValue(e) { const t = this._cachedMeta.vScale, n = this.getParsed(e); return { label: t.getLabels()[e], value: "" + t.getLabelForValue(n[t.axis]) } } parseObjectData(e, t, n, r) { return rd.bind(this)(e, t, n, r) } update(e) { const t = this._cachedMeta, n = t.dataset, r = t.data || [], i = t.iScale.getLabels(); if (n.points = r, "resize" !== e) { const t = this.resolveDatasetElementOptions(e); this.options.showLine || (t.borderWidth = 0); const o = { _loop: !0, _fullLoop: i.length === r.length, options: t }; this.updateElement(n, void 0, o, e) } this.updateElements(r, 0, r.length, e) } updateElements(e, t, n, r) { const i = this._cachedMeta.rScale, o = "reset" === r; for (let a = t; a < t + n; a++) { const t = e[a], n = this.resolveDataElementOptions(a, t.active ? "active" : r), s = i.getPointPositionForValue(a, this.getParsed(a).r), l = o ? i.xCenter : s.x, c = o ? i.yCenter : s.y, u = { x: l, y: c, angle: s.angle, skip: isNaN(l) || isNaN(c), options: n }; this.updateElement(t, a, u, r) } } } fl(gh, "id", "radar"), fl(gh, "defaults", { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: !0, elements: { line: { fill: "start" } } }), fl(gh, "overrides", { aspectRatio: 1, scales: { r: { type: "radialLinear" } } }); class mh extends eh { getLabelAndValue(e) { const t = this._cachedMeta, n = this.chart.data.labels || [], { xScale: r, yScale: i } = t, o = this.getParsed(e), a = r.getLabelForValue(o.x), s = i.getLabelForValue(o.y); return { label: n[e] || "", value: "(" + a + ", " + s + ")" } } update(e) { const t = this._cachedMeta, { data: n = [] } = t, r = this.chart._animationsDisabled; let { start: i, count: o } = Gc(t, n, r); if (this._drawStart = i, this._drawCount = o, Jc(t) && (i = 0, o = n.length), this.options.showLine) { this.datasetElementType || this.addElements(); const { dataset: i, _dataset: o } = t; i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!o._decimated, i.points = n; const a = this.resolveDatasetElementOptions(e); a.segment = this.options.segment, this.updateElement(i, void 0, { animated: !r, options: a }, e) } else this.datasetElementType && (delete t.dataset, this.datasetElementType = !1); this.updateElements(n, i, o, e) } addElements() { const { showLine: e } = this.options; !this.datasetElementType && e && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements() } updateElements(e, t, n, r) { const i = "reset" === r, { iScale: o, vScale: a, _stacked: s, _dataset: l } = this._cachedMeta, c = this.resolveDataElementOptions(t, r), u = this.getSharedOptions(c), d = this.includeOptions(r, u), h = o.axis, f = a.axis, { spanGaps: p, segment: g } = this.options, m = Pc(p) ? p : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || i || "none" === r; let v = t > 0 && this.getParsed(t - 1); for (let y = t; y < t + n; ++y) { const t = e[y], n = this.getParsed(y), c = b ? t : {}, p = Ql(n[f]), x = c[h] = o.getPixelForValue(n[h], y), w = c[f] = i || p ? a.getBasePixel() : a.getPixelForValue(s ? this.applyStack(a, n, s) : n[f], y); c.skip = isNaN(x) || isNaN(w) || p, c.stop = y > 0 && Math.abs(n[h] - v[h]) > m, g && (c.parsed = n, c.raw = l.data[y]), d && (c.options = u || this.resolveDataElementOptions(y, t.active ? "active" : r)), b || this.updateElement(t, y, c, r), v = n } this.updateSharedOptions(u, r, c) } getMaxOverflow() { const e = this._cachedMeta, t = e.data || []; if (!this.options.showLine) { let e = 0; for (let n = t.length - 1; n >= 0; --n)e = Math.max(e, t[n].size(this.resolveDataElementOptions(n)) / 2); return e > 0 && e } const n = e.dataset, r = n.options && n.options.borderWidth || 0; if (!t.length) return r; const i = t[0].size(this.resolveDataElementOptions(0)), o = t[t.length - 1].size(this.resolveDataElementOptions(t.length - 1)); return Math.max(r, i, o) / 2 } } fl(mh, "id", "scatter"), fl(mh, "defaults", { datasetElementType: !1, dataElementType: "point", showLine: !1, fill: !1 }), fl(mh, "overrides", { interaction: { mode: "point" }, scales: { x: { type: "linear" }, y: { type: "linear" } } }); var bh = Object.freeze({ __proto__: null, BarController: ch, BubbleController: uh, DoughnutController: dh, LineController: hh, PieController: ph, PolarAreaController: fh, RadarController: gh, ScatterController: mh }); function vh() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class yh { static override(e) { Object.assign(yh.prototype, e) } constructor(e) { fl(this, "options", void 0), this.options = e || {} } init() { } formats() { return vh() } parse() { return vh() } format() { return vh() } add() { return vh() } diff() { return vh() } startOf() { return vh() } endOf() { return vh() } } var xh = yh; function wh(e, t, n, r) { const { controller: i, data: o, _sorted: a } = e, s = i._cachedMeta.iScale; if (s && t === s.axis && "r" !== t && a && o.length) { const e = s._reversePixels ? Hc : Vc; if (!r) return e(o, t, n); if (i._sharedOptions) { const r = o[0], i = "function" === typeof r.getRange && r.getRange(t); if (i) { const r = e(o, t, n - i), a = e(o, t, n + i); return { lo: r.lo, hi: a.hi } } } } return { lo: 0, hi: o.length - 1 } } function _h(e, t, n, r, i) { const o = e.getSortedVisibleDatasetMetas(), a = n[t]; for (let s = 0, l = o.length; s < l; ++s) { const { index: e, data: n } = o[s], { lo: l, hi: c } = wh(o[s], t, a, i); for (let t = l; t <= c; ++t) { const i = n[t]; i.skip || r(i, e, t) } } } function kh(e, t, n, r, i) { const o = []; if (!i && !e.isPointInArea(t)) return o; return _h(e, n, t, (function (n, a, s) { (i || Su(n, e.chartArea, 0)) && n.inRange(t.x, t.y, r) && o.push({ element: n, datasetIndex: a, index: s }) }), !0), o } function Sh(e, t, n, r, i, o) { let a = []; const s = function (e) { const t = -1 !== e.indexOf("x"), n = -1 !== e.indexOf("y"); return function (e, r) { const i = t ? Math.abs(e.x - r.x) : 0, o = n ? Math.abs(e.y - r.y) : 0; return Math.sqrt(Math.pow(i, 2) + Math.pow(o, 2)) } }(n); let l = Number.POSITIVE_INFINITY; return _h(e, n, t, (function (n, c, u) { const d = n.inRange(t.x, t.y, i); if (r && !d) return; const h = n.getCenterPoint(i); if (!(!!o || e.isPointInArea(h)) && !d) return; const f = s(t, h); f < l ? (a = [{ element: n, datasetIndex: c, index: u }], l = f) : f === l && a.push({ element: n, datasetIndex: c, index: u }) })), a } function Ch(e, t, n, r, i, o) { return o || e.isPointInArea(t) ? "r" !== n || r ? Sh(e, t, n, r, i, o) : function (e, t, n, r) { let i = []; return _h(e, n, t, (function (e, n, o) { const { startAngle: a, endAngle: s } = e.getProps(["startAngle", "endAngle"], r), { angle: l } = Rc(e, { x: t.x, y: t.y }); Ic(l, a, s) && i.push({ element: e, datasetIndex: n, index: o }) })), i }(e, t, n, i) : [] } function Eh(e, t, n, r, i) { const o = [], a = "x" === n ? "inXRange" : "inYRange"; let s = !1; return _h(e, n, t, ((e, r, l) => { e[a](t[n], i) && (o.push({ element: e, datasetIndex: r, index: l }), s = s || e.inRange(t.x, t.y, i)) })), r && !s ? [] : o } var Mh = { evaluateInteractionItems: _h, modes: { index(e, t, n, r) { const i = vd(t, e), o = n.axis || "x", a = n.includeInvisible || !1, s = n.intersect ? kh(e, i, o, r, a) : Ch(e, i, o, !1, r, a), l = []; return s.length ? (e.getSortedVisibleDatasetMetas().forEach((e => { const t = s[0].index, n = e.data[t]; n && !n.skip && l.push({ element: n, datasetIndex: e.index, index: t }) })), l) : [] }, dataset(e, t, n, r) { const i = vd(t, e), o = n.axis || "xy", a = n.includeInvisible || !1; let s = n.intersect ? kh(e, i, o, r, a) : Ch(e, i, o, !1, r, a); if (s.length > 0) { const t = s[0].datasetIndex, n = e.getDatasetMeta(t).data; s = []; for (let e = 0; e < n.length; ++e)s.push({ element: n[e], datasetIndex: t, index: e }) } return s }, point: (e, t, n, r) => kh(e, vd(t, e), n.axis || "xy", r, n.includeInvisible || !1), nearest(e, t, n, r) { const i = vd(t, e), o = n.axis || "xy", a = n.includeInvisible || !1; return Ch(e, i, o, n.intersect, r, a) }, x: (e, t, n, r) => Eh(e, vd(t, e), "x", n.intersect, r), y: (e, t, n, r) => Eh(e, vd(t, e), "y", n.intersect, r) } }; const Oh = ["left", "top", "right", "bottom"]; function Ph(e, t) { return e.filter((e => e.pos === t)) } function Nh(e, t) { return e.filter((e => -1 === Oh.indexOf(e.pos) && e.box.axis === t)) } function Th(e, t) { return e.sort(((e, n) => { const r = t ? n : e, i = t ? e : n; return r.weight === i.weight ? r.index - i.index : r.weight - i.weight })) } function jh(e, t) { const n = function (e) { const t = {}; for (const n of e) { const { stack: e, pos: r, stackWeight: i } = n; if (!e || !Oh.includes(r)) continue; const o = t[e] || (t[e] = { count: 0, placed: 0, weight: 0, size: 0 }); o.count++, o.weight += i } return t }(e), { vBoxMaxWidth: r, hBoxMaxHeight: i } = t; let o, a, s; for (o = 0, a = e.length; o < a; ++o) { s = e[o]; const { fullSize: a } = s.box, l = n[s.stack], c = l && s.stackWeight / l.weight; s.horizontal ? (s.width = c ? c * r : a && t.availableWidth, s.height = i) : (s.width = r, s.height = c ? c * i : a && t.availableHeight) } return n } function Dh(e, t, n, r) { return Math.max(e[n], t[n]) + Math.max(e[r], t[r]) } function Rh(e, t) { e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right) } function Lh(e, t, n, r) { const { pos: i, box: o } = n, a = e.maxPadding; if (!Gl(i)) { n.size && (e[i] -= n.size); const t = r[n.stack] || { size: 0, count: 1 }; t.size = Math.max(t.size, n.horizontal ? o.height : o.width), n.size = t.size / t.count, e[i] += n.size } o.getPadding && Rh(a, o.getPadding()); const s = Math.max(0, t.outerWidth - Dh(a, e, "left", "right")), l = Math.max(0, t.outerHeight - Dh(a, e, "top", "bottom")), c = s !== e.w, u = l !== e.h; return e.w = s, e.h = l, n.horizontal ? { same: c, other: u } : { same: u, other: c } } function Ah(e, t) { const n = t.maxPadding; function r(e) { const r = { left: 0, top: 0, right: 0, bottom: 0 }; return e.forEach((e => { r[e] = Math.max(t[e], n[e]) })), r } return r(e ? ["left", "right"] : ["top", "bottom"]) } function zh(e, t, n, r) { const i = []; let o, a, s, l, c, u; for (o = 0, a = e.length, c = 0; o < a; ++o) { s = e[o], l = s.box, l.update(s.width || t.w, s.height || t.h, Ah(s.horizontal, t)); const { same: a, other: d } = Lh(t, n, s, r); c |= a && i.length, u = u || d, l.fullSize || i.push(s) } return c && zh(i, t, n, r) || u } function Ih(e, t, n, r, i) { e.top = n, e.left = t, e.right = t + r, e.bottom = n + i, e.width = r, e.height = i } function Fh(e, t, n, r) { const i = n.padding; let { x: o, y: a } = t; for (const s of e) { const e = s.box, l = r[s.stack] || { count: 1, placed: 0, weight: 1 }, c = s.stackWeight / l.weight || 1; if (s.horizontal) { const r = t.w * c, o = l.size || e.height; pc(l.start) && (a = l.start), e.fullSize ? Ih(e, i.left, a, n.outerWidth - i.right - i.left, o) : Ih(e, t.left + l.placed, a, r, o), l.start = a, l.placed += r, a = e.bottom } else { const r = t.h * c, a = l.size || e.width; pc(l.start) && (o = l.start), e.fullSize ? Ih(e, o, i.top, a, n.outerHeight - i.bottom - i.top) : Ih(e, o, t.top + l.placed, a, r), l.start = o, l.placed += r, o = e.right } } t.x = o, t.y = a } var Bh = { addBox(e, t) { e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function () { return [{ z: 0, draw(e) { t.draw(e) } }] }, e.boxes.push(t) }, removeBox(e, t) { const n = e.boxes ? e.boxes.indexOf(t) : -1; -1 !== n && e.boxes.splice(n, 1) }, configure(e, t, n) { t.fullSize = n.fullSize, t.position = n.position, t.weight = n.weight }, update(e, t, n, r) { if (!e) return; const i = Bu(e.options.layout.padding), o = Math.max(t - i.width, 0), a = Math.max(n - i.height, 0), s = function (e) { const t = function (e) { const t = []; let n, r, i, o, a, s; for (n = 0, r = (e || []).length; n < r; ++n)i = e[n], ({ position: o, options: { stack: a, stackWeight: s = 1 } } = i), t.push({ index: n, box: i, pos: o, horizontal: i.isHorizontal(), weight: i.weight, stack: a && o + a, stackWeight: s }); return t }(e), n = Th(t.filter((e => e.box.fullSize)), !0), r = Th(Ph(t, "left"), !0), i = Th(Ph(t, "right")), o = Th(Ph(t, "top"), !0), a = Th(Ph(t, "bottom")), s = Nh(t, "x"), l = Nh(t, "y"); return { fullSize: n, leftAndTop: r.concat(o), rightAndBottom: i.concat(l).concat(a).concat(s), chartArea: Ph(t, "chartArea"), vertical: r.concat(i).concat(l), horizontal: o.concat(a).concat(s) } }(e.boxes), l = s.vertical, c = s.horizontal; rc(e.boxes, (e => { "function" === typeof e.beforeLayout && e.beforeLayout() })); const u = l.reduce(((e, t) => t.box.options && !1 === t.box.options.display ? e : e + 1), 0) || 1, d = Object.freeze({ outerWidth: t, outerHeight: n, padding: i, availableWidth: o, availableHeight: a, vBoxMaxWidth: o / 2 / u, hBoxMaxHeight: a / 2 }), h = Object.assign({}, i); Rh(h, Bu(r)); const f = Object.assign({ maxPadding: h, w: o, h: a, x: i.left, y: i.top }, i), p = jh(l.concat(c), d); zh(s.fullSize, f, d, p), zh(l, f, d, p), zh(c, f, d, p) && zh(l, f, d, p), function (e) { const t = e.maxPadding; function n(n) { const r = Math.max(t[n] - e[n], 0); return e[n] += r, r } e.y += n("top"), e.x += n("left"), n("right"), n("bottom") }(f), Fh(s.leftAndTop, f, d, p), f.x += f.w, f.y += f.h, Fh(s.rightAndBottom, f, d, p), e.chartArea = { left: f.left, top: f.top, right: f.left + f.w, bottom: f.top + f.h, height: f.h, width: f.w }, rc(s.chartArea, (t => { const n = t.box; Object.assign(n, e.chartArea), n.update(f.w, f.h, { left: 0, top: 0, right: 0, bottom: 0 }) })) } }; class Wh { acquireContext(e, t) { } releaseContext(e) { return !1 } addEventListener(e, t, n) { } removeEventListener(e, t, n) { } getDevicePixelRatio() { return 1 } getMaximumSize(e, t, n, r) { return t = Math.max(0, t || e.width), n = n || e.height, { width: t, height: Math.max(0, r ? Math.floor(t / r) : n) } } isAttached(e) { return !0 } updateConfig(e) { } } class Vh extends Wh { acquireContext(e) { return e && e.getContext && e.getContext("2d") || null } updateConfig(e) { e.options.animation = !1 } } const Hh = "$chartjs", Uh = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, $h = e => null === e || "" === e; const Yh = !!_d && { passive: !0 }; function qh(e, t, n) { e.canvas.removeEventListener(t, n, Yh) } function Kh(e, t) { for (const n of e) if (n === t || n.contains(t)) return !0 } function Qh(e, t, n) { const r = e.canvas, i = new MutationObserver((e => { let t = !1; for (const n of e) t = t || Kh(n.addedNodes, r), t = t && !Kh(n.removedNodes, r); t && n() })); return i.observe(document, { childList: !0, subtree: !0 }), i } function Xh(e, t, n) { const r = e.canvas, i = new MutationObserver((e => { let t = !1; for (const n of e) t = t || Kh(n.removedNodes, r), t = t && !Kh(n.addedNodes, r); t && n() })); return i.observe(document, { childList: !0, subtree: !0 }), i } const Gh = new Map; let Jh = 0; function Zh() { const e = window.devicePixelRatio; e !== Jh && (Jh = e, Gh.forEach(((t, n) => { n.currentDevicePixelRatio !== e && t() }))) } function ef(e, t, n) { const r = e.canvas, i = r && hd(r); if (!i) return; const o = Kc(((e, t) => { const r = i.clientWidth; n(e, t), r < i.clientWidth && n() }), window), a = new ResizeObserver((e => { const t = e[0], n = t.contentRect.width, r = t.contentRect.height; 0 === n && 0 === r || o(n, r) })); return a.observe(i), function (e, t) { Gh.size || window.addEventListener("resize", Zh), Gh.set(e, t) }(e, o), a } function tf(e, t, n) { n && n.disconnect(), "resize" === t && function (e) { Gh.delete(e), Gh.size || window.removeEventListener("resize", Zh) }(e) } function nf(e, t, n) { const r = e.canvas, i = Kc((t => { null !== e.ctx && n(function (e, t) { const n = Uh[e.type] || e.type, { x: r, y: i } = vd(e, t); return { type: n, chart: t, native: e, x: void 0 !== r ? r : null, y: void 0 !== i ? i : null } }(t, e)) }), e); return function (e, t, n) { e.addEventListener(t, n, Yh) }(r, t, i), i } class rf extends Wh { acquireContext(e, t) { const n = e && e.getContext && e.getContext("2d"); return n && n.canvas === e ? (function (e, t) { const n = e.style, r = e.getAttribute("height"), i = e.getAttribute("width"); if (e[Hh] = { initial: { height: r, width: i, style: { display: n.display, height: n.height, width: n.width } } }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", $h(i)) { const t = kd(e, "width"); void 0 !== t && (e.width = t) } if ($h(r)) if ("" === e.style.height) e.height = e.width / (t || 2); else { const t = kd(e, "height"); void 0 !== t && (e.height = t) } }(e, t), n) : null } releaseContext(e) { const t = e.canvas; if (!t[Hh]) return !1; const n = t[Hh].initial;["height", "width"].forEach((e => { const r = n[e]; Ql(r) ? t.removeAttribute(e) : t.setAttribute(e, r) })); const r = n.style || {}; return Object.keys(r).forEach((e => { t.style[e] = r[e] })), t.width = t.width, delete t[Hh], !0 } addEventListener(e, t, n) { this.removeEventListener(e, t); const r = e.$proxies || (e.$proxies = {}), i = { attach: Qh, detach: Xh, resize: ef }[t] || nf; r[t] = i(e, t, n) } removeEventListener(e, t) { const n = e.$proxies || (e.$proxies = {}), r = n[t]; if (!r) return; ({ attach: tf, detach: tf, resize: tf }[t] || qh)(e, t, r), n[t] = void 0 } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(e, t, n, r) { return xd(e, t, n, r) } isAttached(e) { const t = hd(e); return !(!t || !t.isConnected) } } class of { constructor() { fl(this, "x", void 0), fl(this, "y", void 0), fl(this, "active", !1), fl(this, "options", void 0), fl(this, "$animations", void 0) } tooltipPosition(e) { const { x: t, y: n } = this.getProps(["x", "y"], e); return { x: t, y: n } } hasValue() { return Pc(this.x) && Pc(this.y) } getProps(e, t) { const n = this.$animations; if (!t || !n) return this; const r = {}; return e.forEach((e => { r[e] = n[e] && n[e].active() ? n[e]._to : this[e] })), r } } function af(e, t) { const n = e.options.ticks, r = function (e) { const t = e.options.offset, n = e._tickSize(), r = e._length / n + (t ? 0 : 1), i = e._maxLength / n; return Math.floor(Math.min(r, i)) }(e), i = Math.min(n.maxTicksLimit || r, r), o = n.major.enabled ? function (e) { const t = []; let n, r; for (n = 0, r = e.length; n < r; n++)e[n].major && t.push(n); return t }(t) : [], a = o.length, s = o[0], l = o[a - 1], c = []; if (a > i) return function (e, t, n, r) { let i, o = 0, a = n[0]; for (r = Math.ceil(r), i = 0; i < e.length; i++)i === a && (t.push(e[i]), o++, a = n[o * r]) }(t, c, o, a / i), c; const u = function (e, t, n) { const r = function (e) { const t = e.length; let n, r; if (t < 2) return !1; for (r = e[0], n = 1; n < t; ++n)if (e[n] - e[n - 1] !== r) return !1; return r }(e), i = t.length / n; if (!r) return Math.max(i, 1); const o = function (e) { const t = [], n = Math.sqrt(e); let r; for (r = 1; r < n; r++)e % r === 0 && (t.push(r), t.push(e / r)); return n === (0 | n) && t.push(n), t.sort(((e, t) => e - t)).pop(), t }(r); for (let a = 0, s = o.length - 1; a < s; a++) { const e = o[a]; if (e > i) return e } return Math.max(i, 1) }(o, t, i); if (a > 0) { let e, n; const r = a > 1 ? Math.round((l - s) / (a - 1)) : null; for (sf(t, c, u, Ql(r) ? 0 : s - r, s), e = 0, n = a - 1; e < n; e++)sf(t, c, u, o[e], o[e + 1]); return sf(t, c, u, l, Ql(r) ? t.length : l + r), c } return sf(t, c, u), c } function sf(e, t, n, r, i) { const o = ec(r, 0), a = Math.min(ec(i, e.length), e.length); let s, l, c, u = 0; for (n = Math.ceil(n), i && (s = i - r, n = s / Math.floor(s / n)), c = o; c < 0;)u++, c = Math.round(o + u * n); for (l = Math.max(o, 0); l < a; l++)l === c && (t.push(e[l]), u++, c = Math.round(o + u * n)) } fl(of, "defaults", {}), fl(of, "defaultRoutes", void 0); const lf = (e, t, n) => "top" === t || "left" === t ? e[t] + n : e[t] - n, cf = (e, t) => Math.min(t || e, e); function uf(e, t) { const n = [], r = e.length / t, i = e.length; let o = 0; for (; o < i; o += r)n.push(e[Math.floor(o)]); return n } function df(e, t, n) { const r = e.ticks.length, i = Math.min(t, r - 1), o = e._startPixel, a = e._endPixel, s = 1e-6; let l, c = e.getPixelForTick(i); if (!(n && (l = 1 === r ? Math.max(c - o, a - c) : 0 === t ? (e.getPixelForTick(1) - c) / 2 : (c - e.getPixelForTick(i - 1)) / 2, c += i < t ? l : -l, c < o - s || c > a + s))) return c } function hf(e) { return e.drawTicks ? e.tickLength : 0 } function ff(e, t) { if (!e.display) return 0; const n = Wu(e.font, t), r = Bu(e.padding); return (Xl(e.text) ? e.text.length : 1) * n.lineHeight + r.height } function pf(e, t, n) { let r = Qc(e); return (n && "right" !== t || !n && "right" === t) && (r = (e => "left" === e ? "right" : "right" === e ? "left" : e)(r)), r } class gf extends of { constructor(e) { super(), this.id = e.id, this.type = e.type, this.options = void 0, this.ctx = e.ctx, this.chart = e.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(e) { this.options = e.setContext(this.getContext()), this.axis = e.axis, this._userMin = this.parse(e.min), this._userMax = this.parse(e.max), this._suggestedMin = this.parse(e.suggestedMin), this._suggestedMax = this.parse(e.suggestedMax) } parse(e, t) { return e } getUserBounds() { let { _userMin: e, _userMax: t, _suggestedMin: n, _suggestedMax: r } = this; return e = Zl(e, Number.POSITIVE_INFINITY), t = Zl(t, Number.NEGATIVE_INFINITY), n = Zl(n, Number.POSITIVE_INFINITY), r = Zl(r, Number.NEGATIVE_INFINITY), { min: Zl(e, n), max: Zl(t, r), minDefined: Jl(e), maxDefined: Jl(t) } } getMinMax(e) { let t, { min: n, max: r, minDefined: i, maxDefined: o } = this.getUserBounds(); if (i && o) return { min: n, max: r }; const a = this.getMatchingVisibleMetas(); for (let s = 0, l = a.length; s < l; ++s)t = a[s].controller.getMinMax(this, e), i || (n = Math.min(n, t.min)), o || (r = Math.max(r, t.max)); return n = o && n > r ? r : n, r = i && n > r ? n : r, { min: Zl(n, Zl(r, n)), max: Zl(r, Zl(n, r)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const e = this.chart.data; return this.options.labels || (this.isHorizontal() ? e.xLabels : e.yLabels) || e.labels || [] } getLabelItems() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.chart.chartArea; return this._labelItems || (this._labelItems = this._computeLabelItems(e)) } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { nc(this.options.beforeUpdate, [this]) } update(e, t, n) { const { beginAtZero: r, grace: i, ticks: o } = this.options, a = o.sampleSize; this.beforeUpdate(), this.maxWidth = e, this.maxHeight = t, this._margins = n = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, n), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = function (e, t, n) { const { min: r, max: i } = e, o = tc(t, (i - r) / 2), a = (e, t) => n && 0 === e ? 0 : e + t; return { min: a(r, -Math.abs(o)), max: a(i, o) } }(this, i, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const s = a < this.ticks.length; this._convertTicksToLabels(s ? uf(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || "auto" === o.source) && (this.ticks = af(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), s && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let e, t, n = this.options.reverse; this.isHorizontal() ? (e = this.left, t = this.right) : (e = this.top, t = this.bottom, n = !n), this._startPixel = e, this._endPixel = t, this._reversePixels = n, this._length = t - e, this._alignToPixels = this.options.alignToPixels } afterUpdate() { nc(this.options.afterUpdate, [this]) } beforeSetDimensions() { nc(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { nc(this.options.afterSetDimensions, [this]) } _callHooks(e) { this.chart.notifyPlugins(e, this.getContext()), nc(this.options[e], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { nc(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(e) { const t = this.options.ticks; let n, r, i; for (n = 0, r = e.length; n < r; n++)i = e[n], i.label = nc(t.callback, [i.value, n, e], this) } afterTickToLabelConversion() { nc(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { nc(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const e = this.options, t = e.ticks, n = cf(this.ticks.length, e.ticks.maxTicksLimit), r = t.minRotation || 0, i = t.maxRotation; let o, a, s, l = r; if (!this._isVisible() || !t.display || r >= i || n <= 1 || !this.isHorizontal()) return void (this.labelRotation = r); const c = this._getLabelSizes(), u = c.widest.width, d = c.highest.height, h = Fc(this.chart.width - u, 0, this.maxWidth); o = e.offset ? this.maxWidth / n : h / (n - 1), u + 6 > o && (o = h / (n - (e.offset ? .5 : 1)), a = this.maxHeight - hf(e.grid) - t.padding - ff(e.title, this.chart.options.font), s = Math.sqrt(u * u + d * d), l = jc(Math.min(Math.asin(Fc((c.highest.height + 6) / o, -1, 1)), Math.asin(Fc(a / s, -1, 1)) - Math.asin(Fc(d / s, -1, 1)))), l = Math.max(r, Math.min(i, l))), this.labelRotation = l } afterCalculateLabelRotation() { nc(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { nc(this.options.beforeFit, [this]) } fit() { const e = { width: 0, height: 0 }, { chart: t, options: { ticks: n, title: r, grid: i } } = this, o = this._isVisible(), a = this.isHorizontal(); if (o) { const o = ff(r, t.options.font); if (a ? (e.width = this.maxWidth, e.height = hf(i) + o) : (e.height = this.maxHeight, e.width = hf(i) + o), n.display && this.ticks.length) { const { first: t, last: r, widest: i, highest: o } = this._getLabelSizes(), s = 2 * n.padding, l = Tc(this.labelRotation), c = Math.cos(l), u = Math.sin(l); if (a) { const t = n.mirror ? 0 : u * i.width + c * o.height; e.height = Math.min(this.maxHeight, e.height + t + s) } else { const t = n.mirror ? 0 : c * i.width + u * o.height; e.width = Math.min(this.maxWidth, e.width + t + s) } this._calculatePadding(t, r, u, c) } } this._handleMargins(), a ? (this.width = this._length = t.width - this._margins.left - this._margins.right, this.height = e.height) : (this.width = e.width, this.height = this._length = t.height - this._margins.top - this._margins.bottom) } _calculatePadding(e, t, n, r) { const { ticks: { align: i, padding: o }, position: a } = this.options, s = 0 !== this.labelRotation, l = "top" !== a && "x" === this.axis; if (this.isHorizontal()) { const a = this.getPixelForTick(0) - this.left, c = this.right - this.getPixelForTick(this.ticks.length - 1); let u = 0, d = 0; s ? l ? (u = r * e.width, d = n * t.height) : (u = n * e.height, d = r * t.width) : "start" === i ? d = t.width : "end" === i ? u = e.width : "inner" !== i && (u = e.width / 2, d = t.width / 2), this.paddingLeft = Math.max((u - a + o) * this.width / (this.width - a), 0), this.paddingRight = Math.max((d - c + o) * this.width / (this.width - c), 0) } else { let n = t.height / 2, r = e.height / 2; "start" === i ? (n = 0, r = e.height) : "end" === i && (n = t.height, r = 0), this.paddingTop = n + o, this.paddingBottom = r + o } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { nc(this.options.afterFit, [this]) } isHorizontal() { const { axis: e, position: t } = this.options; return "top" === t || "bottom" === t || "x" === e } isFullSize() { return this.options.fullSize } _convertTicksToLabels(e) { let t, n; for (this.beforeTickToLabelConversion(), this.generateTickLabels(e), t = 0, n = e.length; t < n; t++)Ql(e[t].label) && (e.splice(t, 1), n--, t--); this.afterTickToLabelConversion() } _getLabelSizes() { let e = this._labelSizes; if (!e) { const t = this.options.ticks.sampleSize; let n = this.ticks; t < n.length && (n = uf(n, t)), this._labelSizes = e = this._computeLabelSizes(n, n.length, this.options.ticks.maxTicksLimit) } return e } _computeLabelSizes(e, t, n) { const { ctx: r, _longestTextCache: i } = this, o = [], a = [], s = Math.floor(t / cf(t, n)); let l, c, u, d, h, f, p, g, m, b, v, y = 0, x = 0; for (l = 0; l < t; l += s) { if (d = e[l].label, h = this._resolveTickFontOptions(l), r.font = f = h.string, p = i[f] = i[f] || { data: {}, gc: [] }, g = h.lineHeight, m = b = 0, Ql(d) || Xl(d)) { if (Xl(d)) for (c = 0, u = d.length; c < u; ++c)v = d[c], Ql(v) || Xl(v) || (m = vu(r, p.data, p.gc, m, v), b += g) } else m = vu(r, p.data, p.gc, m, d), b = g; o.push(m), a.push(b), y = Math.max(m, y), x = Math.max(b, x) } !function (e, t) { rc(e, (e => { const n = e.gc, r = n.length / 2; let i; if (r > t) { for (i = 0; i < r; ++i)delete e.data[n[i]]; n.splice(0, r) } })) }(i, t); const w = o.indexOf(y), _ = a.indexOf(x), k = e => ({ width: o[e] || 0, height: a[e] || 0 }); return { first: k(0), last: k(t - 1), widest: k(w), highest: k(_), widths: o, heights: a } } getLabelForValue(e) { return e } getPixelForValue(e, t) { return NaN } getValueForPixel(e) { } getPixelForTick(e) { const t = this.ticks; return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e].value) } getPixelForDecimal(e) { this._reversePixels && (e = 1 - e); const t = this._startPixel + e * this._length; return Fc(this._alignToPixels ? xu(this.chart, t, 0) : t, -32768, 32767) } getDecimalForPixel(e) { const t = (e - this._startPixel) / this._length; return this._reversePixels ? 1 - t : t } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: e, max: t } = this; return e < 0 && t < 0 ? t : e > 0 && t > 0 ? e : 0 } getContext(e) { const t = this.ticks || []; if (e >= 0 && e < t.length) { const n = t[e]; return n.$context || (n.$context = function (e, t, n) { return Hu(e, { tick: n, index: t, type: "tick" }) }(this.getContext(), e, n)) } return this.$context || (this.$context = Hu(this.chart.getContext(), { scale: this, type: "scale" })) } _tickSize() { const e = this.options.ticks, t = Tc(this.labelRotation), n = Math.abs(Math.cos(t)), r = Math.abs(Math.sin(t)), i = this._getLabelSizes(), o = e.autoSkipPadding || 0, a = i ? i.widest.width + o : 0, s = i ? i.highest.height + o : 0; return this.isHorizontal() ? s * n > a * r ? a / n : s / r : s * r < a * n ? s / n : a / r } _isVisible() { const e = this.options.display; return "auto" !== e ? !!e : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(e) { const t = this.axis, n = this.chart, r = this.options, { grid: i, position: o, border: a } = r, s = i.offset, l = this.isHorizontal(), c = this.ticks.length + (s ? 1 : 0), u = hf(i), d = [], h = a.setContext(this.getContext()), f = h.display ? h.width : 0, p = f / 2, g = function (e) { return xu(n, e, f) }; let m, b, v, y, x, w, _, k, S, C, E, M; if ("top" === o) m = g(this.bottom), w = this.bottom - u, k = m - p, C = g(e.top) + p, M = e.bottom; else if ("bottom" === o) m = g(this.top), C = e.top, M = g(e.bottom) - p, w = m + p, k = this.top + u; else if ("left" === o) m = g(this.right), x = this.right - u, _ = m - p, S = g(e.left) + p, E = e.right; else if ("right" === o) m = g(this.left), S = e.left, E = g(e.right) - p, x = m + p, _ = this.left + u; else if ("x" === t) { if ("center" === o) m = g((e.top + e.bottom) / 2 + .5); else if (Gl(o)) { const e = Object.keys(o)[0], t = o[e]; m = g(this.chart.scales[e].getPixelForValue(t)) } C = e.top, M = e.bottom, w = m + p, k = w + u } else if ("y" === t) { if ("center" === o) m = g((e.left + e.right) / 2); else if (Gl(o)) { const e = Object.keys(o)[0], t = o[e]; m = g(this.chart.scales[e].getPixelForValue(t)) } x = m - p, _ = x - u, S = e.left, E = e.right } const O = ec(r.ticks.maxTicksLimit, c), P = Math.max(1, Math.ceil(c / O)); for (b = 0; b < c; b += P) { const e = this.getContext(b), t = i.setContext(e), r = a.setContext(e), o = t.lineWidth, c = t.color, u = r.dash || [], h = r.dashOffset, f = t.tickWidth, p = t.tickColor, g = t.tickBorderDash || [], m = t.tickBorderDashOffset; v = df(this, b, s), void 0 !== v && (y = xu(n, v, o), l ? x = _ = S = E = y : w = k = C = M = y, d.push({ tx1: x, ty1: w, tx2: _, ty2: k, x1: S, y1: C, x2: E, y2: M, width: o, color: c, borderDash: u, borderDashOffset: h, tickWidth: f, tickColor: p, tickBorderDash: g, tickBorderDashOffset: m })) } return this._ticksLength = c, this._borderValue = m, d } _computeLabelItems(e) { const t = this.axis, n = this.options, { position: r, ticks: i } = n, o = this.isHorizontal(), a = this.ticks, { align: s, crossAlign: l, padding: c, mirror: u } = i, d = hf(n.grid), h = d + c, f = u ? -c : h, p = -Tc(this.labelRotation), g = []; let m, b, v, y, x, w, _, k, S, C, E, M, O = "middle"; if ("top" === r) w = this.bottom - f, _ = this._getXAxisLabelAlignment(); else if ("bottom" === r) w = this.top + f, _ = this._getXAxisLabelAlignment(); else if ("left" === r) { const e = this._getYAxisLabelAlignment(d); _ = e.textAlign, x = e.x } else if ("right" === r) { const e = this._getYAxisLabelAlignment(d); _ = e.textAlign, x = e.x } else if ("x" === t) { if ("center" === r) w = (e.top + e.bottom) / 2 + h; else if (Gl(r)) { const e = Object.keys(r)[0], t = r[e]; w = this.chart.scales[e].getPixelForValue(t) + h } _ = this._getXAxisLabelAlignment() } else if ("y" === t) { if ("center" === r) x = (e.left + e.right) / 2 - h; else if (Gl(r)) { const e = Object.keys(r)[0], t = r[e]; x = this.chart.scales[e].getPixelForValue(t) } _ = this._getYAxisLabelAlignment(d).textAlign } "y" === t && ("start" === s ? O = "top" : "end" === s && (O = "bottom")); const P = this._getLabelSizes(); for (m = 0, b = a.length; m < b; ++m) { v = a[m], y = v.label; const e = i.setContext(this.getContext(m)); k = this.getPixelForTick(m) + i.labelOffset, S = this._resolveTickFontOptions(m), C = S.lineHeight, E = Xl(y) ? y.length : 1; const t = E / 2, n = e.color, s = e.textStrokeColor, c = e.textStrokeWidth; let d, h = _; if (o ? (x = k, "inner" === _ && (h = m === b - 1 ? this.options.reverse ? "left" : "right" : 0 === m ? this.options.reverse ? "right" : "left" : "center"), M = "top" === r ? "near" === l || 0 !== p ? -E * C + C / 2 : "center" === l ? -P.highest.height / 2 - t * C + C : -P.highest.height + C / 2 : "near" === l || 0 !== p ? C / 2 : "center" === l ? P.highest.height / 2 - t * C : P.highest.height - E * C, u && (M *= -1), 0 === p || e.showLabelBackdrop || (x += C / 2 * Math.sin(p))) : (w = k, M = (1 - E) * C / 2), e.showLabelBackdrop) { const t = Bu(e.backdropPadding), n = P.heights[m], r = P.widths[m]; let i = M - t.top, o = 0 - t.left; switch (O) { case "middle": i -= n / 2; break; case "bottom": i -= n }switch (_) { case "center": o -= r / 2; break; case "right": o -= r; break; case "inner": m === b - 1 ? o -= r : m > 0 && (o -= r / 2) }d = { left: o, top: i, width: r + t.width, height: n + t.height, color: e.backdropColor } } g.push({ label: y, font: S, textOffset: M, options: { rotation: p, color: n, strokeColor: s, strokeWidth: c, textAlign: h, textBaseline: O, translation: [x, w], backdrop: d } }) } return g } _getXAxisLabelAlignment() { const { position: e, ticks: t } = this.options; if (-Tc(this.labelRotation)) return "top" === e ? "left" : "right"; let n = "center"; return "start" === t.align ? n = "left" : "end" === t.align ? n = "right" : "inner" === t.align && (n = "inner"), n } _getYAxisLabelAlignment(e) { const { position: t, ticks: { crossAlign: n, mirror: r, padding: i } } = this.options, o = e + i, a = this._getLabelSizes().widest.width; let s, l; return "left" === t ? r ? (l = this.right + i, "near" === n ? s = "left" : "center" === n ? (s = "center", l += a / 2) : (s = "right", l += a)) : (l = this.right - o, "near" === n ? s = "right" : "center" === n ? (s = "center", l -= a / 2) : (s = "left", l = this.left)) : "right" === t ? r ? (l = this.left + i, "near" === n ? s = "right" : "center" === n ? (s = "center", l -= a / 2) : (s = "left", l -= a)) : (l = this.left + o, "near" === n ? s = "left" : "center" === n ? (s = "center", l += a / 2) : (s = "right", l = this.right)) : s = "right", { textAlign: s, x: l } } _computeLabelArea() { if (this.options.ticks.mirror) return; const e = this.chart, t = this.options.position; return "left" === t || "right" === t ? { top: 0, left: this.left, bottom: e.height, right: this.right } : "top" === t || "bottom" === t ? { top: this.top, left: 0, bottom: this.bottom, right: e.width } : void 0 } drawBackground() { const { ctx: e, options: { backgroundColor: t }, left: n, top: r, width: i, height: o } = this; t && (e.save(), e.fillStyle = t, e.fillRect(n, r, i, o), e.restore()) } getLineWidthForValue(e) { const t = this.options.grid; if (!this._isVisible() || !t.display) return 0; const n = this.ticks.findIndex((t => t.value === e)); if (n >= 0) { return t.setContext(this.getContext(n)).lineWidth } return 0 } drawGrid(e) { const t = this.options.grid, n = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(e)); let i, o; const a = (e, t, r) => { r.width && r.color && (n.save(), n.lineWidth = r.width, n.strokeStyle = r.color, n.setLineDash(r.borderDash || []), n.lineDashOffset = r.borderDashOffset, n.beginPath(), n.moveTo(e.x, e.y), n.lineTo(t.x, t.y), n.stroke(), n.restore()) }; if (t.display) for (i = 0, o = r.length; i < o; ++i) { const e = r[i]; t.drawOnChartArea && a({ x: e.x1, y: e.y1 }, { x: e.x2, y: e.y2 }, e), t.drawTicks && a({ x: e.tx1, y: e.ty1 }, { x: e.tx2, y: e.ty2 }, { color: e.tickColor, width: e.tickWidth, borderDash: e.tickBorderDash, borderDashOffset: e.tickBorderDashOffset }) } } drawBorder() { const { chart: e, ctx: t, options: { border: n, grid: r } } = this, i = n.setContext(this.getContext()), o = n.display ? i.width : 0; if (!o) return; const a = r.setContext(this.getContext(0)).lineWidth, s = this._borderValue; let l, c, u, d; this.isHorizontal() ? (l = xu(e, this.left, o) - o / 2, c = xu(e, this.right, a) + a / 2, u = d = s) : (u = xu(e, this.top, o) - o / 2, d = xu(e, this.bottom, a) + a / 2, l = c = s), t.save(), t.lineWidth = i.width, t.strokeStyle = i.color, t.beginPath(), t.moveTo(l, u), t.lineTo(c, d), t.stroke(), t.restore() } drawLabels(e) { if (!this.options.ticks.display) return; const t = this.ctx, n = this._computeLabelArea(); n && Cu(t, n); const r = this.getLabelItems(e); for (const i of r) { const e = i.options, n = i.font; Tu(t, i.label, 0, i.textOffset, n, e) } n && Eu(t) } drawTitle() { const { ctx: e, options: { position: t, title: n, reverse: r } } = this; if (!n.display) return; const i = Wu(n.font), o = Bu(n.padding), a = n.align; let s = i.lineHeight / 2; "bottom" === t || "center" === t || Gl(t) ? (s += o.bottom, Xl(n.text) && (s += i.lineHeight * (n.text.length - 1))) : s += o.top; const { titleX: l, titleY: c, maxWidth: u, rotation: d } = function (e, t, n, r) { const { top: i, left: o, bottom: a, right: s, chart: l } = e, { chartArea: c, scales: u } = l; let d, h, f, p = 0; const g = a - i, m = s - o; if (e.isHorizontal()) { if (h = Xc(r, o, s), Gl(n)) { const e = Object.keys(n)[0], r = n[e]; f = u[e].getPixelForValue(r) + g - t } else f = "center" === n ? (c.bottom + c.top) / 2 + g - t : lf(e, n, t); d = s - o } else { if (Gl(n)) { const e = Object.keys(n)[0], r = n[e]; h = u[e].getPixelForValue(r) - m + t } else h = "center" === n ? (c.left + c.right) / 2 - m + t : lf(e, n, t); f = Xc(r, a, i), p = "left" === n ? -_c : _c } return { titleX: h, titleY: f, maxWidth: d, rotation: p } }(this, s, t, a); Tu(e, n.text, 0, 0, i, { color: n.color, maxWidth: u, rotation: d, textAlign: pf(a, t, r), textBaseline: "middle", translation: [l, c] }) } draw(e) { this._isVisible() && (this.drawBackground(), this.drawGrid(e), this.drawBorder(), this.drawTitle(), this.drawLabels(e)) } _layers() { const e = this.options, t = e.ticks && e.ticks.z || 0, n = ec(e.grid && e.grid.z, -1), r = ec(e.border && e.border.z, 0); return this._isVisible() && this.draw === gf.prototype.draw ? [{ z: n, draw: e => { this.drawBackground(), this.drawGrid(e), this.drawTitle() } }, { z: r, draw: () => { this.drawBorder() } }, { z: t, draw: e => { this.drawLabels(e) } }] : [{ z: t, draw: e => { this.draw(e) } }] } getMatchingVisibleMetas(e) { const t = this.chart.getSortedVisibleDatasetMetas(), n = this.axis + "AxisID", r = []; let i, o; for (i = 0, o = t.length; i < o; ++i) { const o = t[i]; o[n] !== this.id || e && o.type !== e || r.push(o) } return r } _resolveTickFontOptions(e) { return Wu(this.options.ticks.setContext(this.getContext(e)).font) } _maxDigits() { const e = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / e } } class mf { constructor(e, t, n) { this.type = e, this.scope = t, this.override = n, this.items = Object.create(null) } isForType(e) { return Object.prototype.isPrototypeOf.call(this.type.prototype, e.prototype) } register(e) { const t = Object.getPrototypeOf(e); let n; (function (e) { return "id" in e && "defaults" in e })(t) && (n = this.register(t)); const r = this.items, i = e.id, o = this.scope + "." + i; if (!i) throw new Error("class does not have id: " + e); return i in r || (r[i] = e, function (e, t, n) { const r = lc(Object.create(null), [n ? bu.get(n) : {}, bu.get(t), e.defaults]); bu.set(t, r), e.defaultRoutes && function (e, t) { Object.keys(t).forEach((n => { const r = n.split("."), i = r.pop(), o = [e].concat(r).join("."), a = t[n].split("."), s = a.pop(), l = a.join("."); bu.route(o, i, l, s) })) }(t, e.defaultRoutes); e.descriptors && bu.describe(t, e.descriptors) }(e, o, n), this.override && bu.override(e.id, e.overrides)), o } get(e) { return this.items[e] } unregister(e) { const t = this.items, n = e.id, r = this.scope; n in t && delete t[n], r && n in bu[r] && (delete bu[r][n], this.override && delete hu[n]) } } class bf { constructor() { this.controllers = new mf(eh, "datasets", !0), this.elements = new mf(of, "elements"), this.plugins = new mf(Object, "plugins"), this.scales = new mf(gf, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._each("register", t) } remove() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._each("unregister", t) } addControllers() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._each("register", t, this.controllers) } addElements() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._each("register", t, this.elements) } addPlugins() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._each("register", t, this.plugins) } addScales() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._each("register", t, this.scales) } getController(e) { return this._get(e, this.controllers, "controller") } getElement(e) { return this._get(e, this.elements, "element") } getPlugin(e) { return this._get(e, this.plugins, "plugin") } getScale(e) { return this._get(e, this.scales, "scale") } removeControllers() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._each("unregister", t, this.controllers) } removeElements() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._each("unregister", t, this.elements) } removePlugins() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._each("unregister", t, this.plugins) } removeScales() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; this._each("unregister", t, this.scales) } _each(e, t, n) { [...t].forEach((t => { const r = n || this._getRegistryForType(t); n || r.isForType(t) || r === this.plugins && t.id ? this._exec(e, r, t) : rc(t, (t => { const r = n || this._getRegistryForType(t); this._exec(e, r, t) })) })) } _exec(e, t, n) { const r = fc(e); nc(n["before" + r], [], n), t[e](n), nc(n["after" + r], [], n) } _getRegistryForType(e) { for (let t = 0; t < this._typedRegistries.length; t++) { const n = this._typedRegistries[t]; if (n.isForType(e)) return n } return this.plugins } _get(e, t, n) { const r = t.get(e); if (void 0 === r) throw new Error('"' + e + '" is not a registered ' + n + "."); return r } } var vf = new bf; class yf { constructor() { this._init = [] } notify(e, t, n, r) { "beforeInit" === t && (this._init = this._createDescriptors(e, !0), this._notify(this._init, e, "install")); const i = r ? this._descriptors(e).filter(r) : this._descriptors(e), o = this._notify(i, e, t, n); return "afterDestroy" === t && (this._notify(i, e, "stop"), this._notify(this._init, e, "uninstall")), o } _notify(e, t, n, r) { r = r || {}; for (const i of e) { const e = i.plugin; if (!1 === nc(e[n], [t, r, i.options], e) && r.cancelable) return !1 } return !0 } invalidate() { Ql(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(e) { if (this._cache) return this._cache; const t = this._cache = this._createDescriptors(e); return this._notifyStateChanges(e), t } _createDescriptors(e, t) { const n = e && e.config, r = ec(n.options && n.options.plugins, {}), i = function (e) { const t = {}, n = [], r = Object.keys(vf.plugins.items); for (let o = 0; o < r.length; o++)n.push(vf.getPlugin(r[o])); const i = e.plugins || []; for (let o = 0; o < i.length; o++) { const e = i[o]; -1 === n.indexOf(e) && (n.push(e), t[e.id] = !0) } return { plugins: n, localIds: t } }(n); return !1 !== r || t ? function (e, t, n, r) { let { plugins: i, localIds: o } = t; const a = [], s = e.getContext(); for (const l of i) { const t = l.id, i = xf(n[t], r); null !== i && a.push({ plugin: l, options: wf(e.config, { plugin: l, local: o[t] }, i, s) }) } return a }(e, i, r, t) : [] } _notifyStateChanges(e) { const t = this._oldCache || [], n = this._cache, r = (e, t) => e.filter((e => !t.some((t => e.plugin.id === t.plugin.id)))); this._notify(r(t, n), e, "stop"), this._notify(r(n, t), e, "start") } } function xf(e, t) { return t || !1 !== e ? !0 === e ? {} : e : null } function wf(e, t, n, r) { let { plugin: i, local: o } = t; const a = e.pluginScopeKeys(i), s = e.getOptionScopes(n, a); return o && i.defaults && s.push(i.defaults), e.createResolver(s, r, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function _f(e, t) { const n = bu.datasets[e] || {}; return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || "x" } function kf(e) { if ("x" === e || "y" === e || "r" === e) return e } function Sf(e) { if (kf(e)) return e; for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)n[r - 1] = arguments[r]; for (const o of n) { const t = o.axis || ("top" === (i = o.position) || "bottom" === i ? "x" : "left" === i || "right" === i ? "y" : void 0) || e.length > 1 && kf(e[0].toLowerCase()); if (t) return t } var i; throw new Error("Cannot determine type of '".concat(e, "' axis. Please provide 'axis' or 'position' option.")) } function Cf(e, t, n) { if (n[t + "AxisID"] === e) return { axis: t } } function Ef(e, t) { const n = hu[e.type] || { scales: {} }, r = t.scales || {}, i = _f(e.type, t), o = Object.create(null); return Object.keys(r).forEach((t => { const a = r[t]; if (!Gl(a)) return console.error("Invalid scale configuration for scale: ".concat(t)); if (a._proxy) return console.warn("Ignoring resolver passed as options for scale: ".concat(t)); const s = Sf(t, a, function (e, t) { if (t.data && t.data.datasets) { const n = t.data.datasets.filter((t => t.xAxisID === e || t.yAxisID === e)); if (n.length) return Cf(e, "x", n[0]) || Cf(e, "y", n[0]) } return {} }(t, e), bu.scales[a.type]), l = function (e, t) { return e === t ? "_index_" : "_value_" }(s, i), c = n.scales || {}; o[t] = cc(Object.create(null), [{ axis: s }, a, c[s], c[l]]) })), e.data.datasets.forEach((n => { const i = n.type || e.type, a = n.indexAxis || _f(i, t), s = (hu[i] || {}).scales || {}; Object.keys(s).forEach((e => { const t = function (e, t) { let n = e; return "_index_" === e ? n = t : "_value_" === e && (n = "x" === t ? "y" : "x"), n }(e, a), i = n[t + "AxisID"] || t; o[i] = o[i] || Object.create(null), cc(o[i], [{ axis: t }, r[i], s[e]]) })) })), Object.keys(o).forEach((e => { const t = o[e]; cc(t, [bu.scales[t.type], bu.scale]) })), o } function Mf(e) { const t = e.options || (e.options = {}); t.plugins = ec(t.plugins, {}), t.scales = Ef(e, t) } function Of(e) { return (e = e || {}).datasets = e.datasets || [], e.labels = e.labels || [], e } const Pf = new Map, Nf = new Set; function Tf(e, t) { let n = Pf.get(e); return n || (n = t(), Pf.set(e, n), Nf.add(n)), n } const jf = (e, t, n) => { const r = hc(t, n); void 0 !== r && e.add(r) }; class Df { constructor(e) { this._config = function (e) { return (e = e || {}).data = Of(e.data), Mf(e), e }(e), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(e) { this._config.type = e } get data() { return this._config.data } set data(e) { this._config.data = Of(e) } get options() { return this._config.options } set options(e) { this._config.options = e } get plugins() { return this._config.plugins } update() { const e = this._config; this.clearCache(), Mf(e) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(e) { return Tf(e, (() => [["datasets.".concat(e), ""]])) } datasetAnimationScopeKeys(e, t) { return Tf("".concat(e, ".transition.").concat(t), (() => [["datasets.".concat(e, ".transitions.").concat(t), "transitions.".concat(t)], ["datasets.".concat(e), ""]])) } datasetElementScopeKeys(e, t) { return Tf("".concat(e, "-").concat(t), (() => [["datasets.".concat(e, ".elements.").concat(t), "datasets.".concat(e), "elements.".concat(t), ""]])) } pluginScopeKeys(e) { const t = e.id, n = this.type; return Tf("".concat(n, "-plugin-").concat(t), (() => [["plugins.".concat(t), ...e.additionalOptionScopes || []]])) } _cachedScopes(e, t) { const n = this._scopeCache; let r = n.get(e); return r && !t || (r = new Map, n.set(e, r)), r } getOptionScopes(e, t, n) { const { options: r, type: i } = this, o = this._cachedScopes(e, n), a = o.get(t); if (a) return a; const s = new Set; t.forEach((t => { e && (s.add(e), t.forEach((t => jf(s, e, t)))), t.forEach((e => jf(s, r, e))), t.forEach((e => jf(s, hu[i] || {}, e))), t.forEach((e => jf(s, bu, e))), t.forEach((e => jf(s, fu, e))) })); const l = Array.from(s); return 0 === l.length && l.push(Object.create(null)), Nf.has(t) && o.set(t, l), l } chartOptionScopes() { const { options: e, type: t } = this; return [e, hu[t] || {}, bu.datasets[t] || {}, { type: t }, bu, fu] } resolveNamedOptions(e, t, n) { let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [""]; const i = { $shared: !0 }, { resolver: o, subPrefixes: a } = Rf(this._resolverCache, e, r); let s = o; if (function (e, t) { const { isScriptable: n, isIndexable: r } = Yu(e); for (const i of t) { const t = n(i), o = r(i), a = (o || t) && e[i]; if (t && (gc(a) || Lf(a)) || o && Xl(a)) return !0 } return !1 }(o, t)) { i.$shared = !1; s = $u(o, n = gc(n) ? n() : n, this.createResolver(e, n, a)) } for (const l of t) i[l] = s[l]; return i } createResolver(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [""], r = arguments.length > 3 ? arguments[3] : void 0; const { resolver: i } = Rf(this._resolverCache, e, n); return Gl(t) ? $u(i, t, void 0, r) : i } } function Rf(e, t, n) { let r = e.get(t); r || (r = new Map, e.set(t, r)); const i = n.join(); let o = r.get(i); if (!o) { o = { resolver: Uu(t, n), subPrefixes: n.filter((e => !e.toLowerCase().includes("hover"))) }, r.set(i, o) } return o } const Lf = e => Gl(e) && Object.getOwnPropertyNames(e).some((t => gc(e[t]))); const Af = ["top", "bottom", "left", "right", "chartArea"]; function zf(e, t) { return "top" === e || "bottom" === e || -1 === Af.indexOf(e) && "x" === t } function If(e, t) { return function (n, r) { return n[e] === r[e] ? n[t] - r[t] : n[e] - r[e] } } function Ff(e) { const t = e.chart, n = t.options.animation; t.notifyPlugins("afterRender"), nc(n && n.onComplete, [e], t) } function Bf(e) { const t = e.chart, n = t.options.animation; nc(n && n.onProgress, [e], t) } function Wf(e) { return dd() && "string" === typeof e ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e } const Vf = {}, Hf = e => { const t = Wf(e); return Object.values(Vf).filter((e => e.canvas === t)).pop() }; function Uf(e, t, n) { const r = Object.keys(e); for (const i of r) { const r = +i; if (r >= t) { const o = e[i]; delete e[i], (n > 0 || r > t) && (e[r + n] = o) } } } function $f(e, t, n) { return e.options.clip ? e[n] : t[n] } class Yf { static register() { vf.add(...arguments), qf() } static unregister() { vf.remove(...arguments), qf() } constructor(e, t) { const n = this.config = new Df(t), r = Wf(e), i = Hf(r); if (i) throw new Error("Canvas is already in use. Chart with ID '" + i.id + "' must be destroyed before the canvas with ID '" + i.canvas.id + "' can be reused."); const o = n.createResolver(n.chartOptionScopes(), this.getContext()); this.platform = new (n.platform || function (e) { return !dd() || "undefined" !== typeof OffscreenCanvas && e instanceof OffscreenCanvas ? Vh : rf }(r)), this.platform.updateConfig(n); const a = this.platform.acquireContext(r, o.aspectRatio), s = a && a.canvas, l = s && s.height, c = s && s.width; this.id = Kl(), this.ctx = a, this.canvas = s, this.width = c, this.height = l, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new yf, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = function (e, t) { let n; return function () { for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)i[o] = arguments[o]; return t ? (clearTimeout(n), n = setTimeout(e, t, i)) : e.apply(this, i), t } }((e => this.update(e)), o.resizeDelay || 0), this._dataChanges = [], Vf[this.id] = this, a && s ? (Id.listen(this, "complete", Ff), Id.listen(this, "progress", Bf), this._initialize(), this.attached && this.update()) : console.error("Failed to create chart: can't acquire context from the given item") } get aspectRatio() { const { options: { aspectRatio: e, maintainAspectRatio: t }, width: n, height: r, _aspectRatio: i } = this; return Ql(e) ? t && i ? i : r ? n / r : null : e } get data() { return this.config.data } set data(e) { this.config.data = e } get options() { return this._options } set options(e) { this.config.options = e } get registry() { return vf } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : wd(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return wu(this.canvas, this.ctx), this } stop() { return Id.stop(this), this } resize(e, t) { Id.running(this) ? this._resizeBeforeDraw = { width: e, height: t } : this._resize(e, t) } _resize(e, t) { const n = this.options, r = this.canvas, i = n.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(r, e, t, i), a = n.devicePixelRatio || this.platform.getDevicePixelRatio(), s = this.width ? "resize" : "attach"; this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, wd(this, a, !0) && (this.notifyPlugins("resize", { size: o }), nc(n.onResize, [this, o], this), this.attached && this._doResize(s) && this.render()) } ensureScalesHaveIDs() { rc(this.options.scales || {}, ((e, t) => { e.id = t })) } buildOrUpdateScales() { const e = this.options, t = e.scales, n = this.scales, r = Object.keys(n).reduce(((e, t) => (e[t] = !1, e)), {}); let i = []; t && (i = i.concat(Object.keys(t).map((e => { const n = t[e], r = Sf(e, n), i = "r" === r, o = "x" === r; return { options: n, dposition: i ? "chartArea" : o ? "bottom" : "left", dtype: i ? "radialLinear" : o ? "category" : "linear" } })))), rc(i, (t => { const i = t.options, o = i.id, a = Sf(o, i), s = ec(i.type, t.dtype); void 0 !== i.position && zf(i.position, a) === zf(t.dposition) || (i.position = t.dposition), r[o] = !0; let l = null; if (o in n && n[o].type === s) l = n[o]; else { l = new (vf.getScale(s))({ id: o, type: s, ctx: this.ctx, chart: this }), n[l.id] = l } l.init(i, e) })), rc(r, ((e, t) => { e || delete n[t] })), rc(n, (e => { Bh.configure(this, e, e.options), Bh.addBox(this, e) })) } _updateMetasets() { const e = this._metasets, t = this.data.datasets.length, n = e.length; if (e.sort(((e, t) => e.index - t.index)), n > t) { for (let e = t; e < n; ++e)this._destroyDatasetMeta(e); e.splice(t, n - t) } this._sortedMetasets = e.slice(0).sort(If("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: e, data: { datasets: t } } = this; e.length > t.length && delete this._stacks, e.forEach(((e, n) => { 0 === t.filter((t => t === e._dataset)).length && this._destroyDatasetMeta(n) })) } buildOrUpdateControllers() { const e = [], t = this.data.datasets; let n, r; for (this._removeUnreferencedMetasets(), n = 0, r = t.length; n < r; n++) { const r = t[n]; let i = this.getDatasetMeta(n); const o = r.type || this.config.type; if (i.type && i.type !== o && (this._destroyDatasetMeta(n), i = this.getDatasetMeta(n)), i.type = o, i.indexAxis = r.indexAxis || _f(o, this.options), i.order = r.order || 0, i.index = n, i.label = "" + r.label, i.visible = this.isDatasetVisible(n), i.controller) i.controller.updateIndex(n), i.controller.linkScales(); else { const t = vf.getController(o), { datasetElementType: r, dataElementType: a } = bu.datasets[o]; Object.assign(t, { dataElementType: vf.getElement(a), datasetElementType: r && vf.getElement(r) }), i.controller = new t(this, n), e.push(i.controller) } } return this._updateMetasets(), e } _resetElements() { rc(this.data.datasets, ((e, t) => { this.getDatasetMeta(t).controller.reset() }), this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(e) { const t = this.config; t.update(); const n = this._options = t.createResolver(t.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !n.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins("beforeUpdate", { mode: e, cancelable: !0 })) return; const i = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let o = 0; for (let l = 0, c = this.data.datasets.length; l < c; l++) { const { controller: e } = this.getDatasetMeta(l), t = !r && -1 === i.indexOf(e); e.buildOrUpdateElements(t), o = Math.max(+e.getMaxOverflow(), o) } o = this._minPadding = n.layout.autoPadding ? o : 0, this._updateLayout(o), r || rc(i, (e => { e.reset() })), this._updateDatasets(e), this.notifyPlugins("afterUpdate", { mode: e }), this._layers.sort(If("z", "_idx")); const { _active: a, _lastEvent: s } = this; s ? this._eventHandler(s, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render() } _updateScales() { rc(this.scales, (e => { Bh.removeBox(this, e) })), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const e = this.options, t = new Set(Object.keys(this._listeners)), n = new Set(e.events); mc(t, n) && !!this._responsiveListeners === e.responsive || (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: e } = this, t = this._getUniformDataChanges() || []; for (const { method: n, start: r, count: i } of t) { Uf(e, r, "_removeElements" === n ? -i : i) } } _getUniformDataChanges() { const e = this._dataChanges; if (!e || !e.length) return; this._dataChanges = []; const t = this.data.datasets.length, n = t => new Set(e.filter((e => e[0] === t)).map(((e, t) => t + "," + e.splice(1).join(",")))), r = n(0); for (let i = 1; i < t; i++)if (!mc(r, n(i))) return; return Array.from(r).map((e => e.split(","))).map((e => ({ method: e[1], start: +e[2], count: +e[3] }))) } _updateLayout(e) { if (!1 === this.notifyPlugins("beforeLayout", { cancelable: !0 })) return; Bh.update(this, this.width, this.height, e); const t = this.chartArea, n = t.width <= 0 || t.height <= 0; this._layers = [], rc(this.boxes, (e => { n && "chartArea" === e.position || (e.configure && e.configure(), this._layers.push(...e._layers())) }), this), this._layers.forEach(((e, t) => { e._idx = t })), this.notifyPlugins("afterLayout") } _updateDatasets(e) { if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", { mode: e, cancelable: !0 })) { for (let e = 0, t = this.data.datasets.length; e < t; ++e)this.getDatasetMeta(e).controller.configure(); for (let t = 0, n = this.data.datasets.length; t < n; ++t)this._updateDataset(t, gc(e) ? e({ datasetIndex: t }) : e); this.notifyPlugins("afterDatasetsUpdate", { mode: e }) } } _updateDataset(e, t) { const n = this.getDatasetMeta(e), r = { meta: n, index: e, mode: t, cancelable: !0 }; !1 !== this.notifyPlugins("beforeDatasetUpdate", r) && (n.controller._update(t), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r)) } render() { !1 !== this.notifyPlugins("beforeRender", { cancelable: !0 }) && (Id.has(this) ? this.attached && !Id.running(this) && Id.start(this) : (this.draw(), Ff({ chart: this }))) } draw() { let e; if (this._resizeBeforeDraw) { const { width: e, height: t } = this._resizeBeforeDraw; this._resize(e, t), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0) return; if (!1 === this.notifyPlugins("beforeDraw", { cancelable: !0 })) return; const t = this._layers; for (e = 0; e < t.length && t[e].z <= 0; ++e)t[e].draw(this.chartArea); for (this._drawDatasets(); e < t.length; ++e)t[e].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(e) { const t = this._sortedMetasets, n = []; let r, i; for (r = 0, i = t.length; r < i; ++r) { const i = t[r]; e && !i.visible || n.push(i) } return n } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (!1 === this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 })) return; const e = this.getSortedVisibleDatasetMetas(); for (let t = e.length - 1; t >= 0; --t)this._drawDataset(e[t]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(e) { const t = this.ctx, n = e._clip, r = !n.disabled, i = function (e, t) { const { xScale: n, yScale: r } = e; return n && r ? { left: $f(n, t, "left"), right: $f(n, t, "right"), top: $f(r, t, "top"), bottom: $f(r, t, "bottom") } : t }(e, this.chartArea), o = { meta: e, index: e.index, cancelable: !0 }; !1 !== this.notifyPlugins("beforeDatasetDraw", o) && (r && Cu(t, { left: !1 === n.left ? 0 : i.left - n.left, right: !1 === n.right ? this.width : i.right + n.right, top: !1 === n.top ? 0 : i.top - n.top, bottom: !1 === n.bottom ? this.height : i.bottom + n.bottom }), e.controller.draw(), r && Eu(t), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o)) } isPointInArea(e) { return Su(e, this.chartArea, this._minPadding) } getElementsAtEventForMode(e, t, n, r) { const i = Mh.modes[t]; return "function" === typeof i ? i(this, e, n, r) : [] } getDatasetMeta(e) { const t = this.data.datasets[e], n = this._metasets; let r = n.filter((e => e && e._dataset === t)).pop(); return r || (r = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: t && t.order || 0, index: e, _dataset: t, _parsed: [], _sorted: !1 }, n.push(r)), r } getContext() { return this.$context || (this.$context = Hu(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(e) { const t = this.data.datasets[e]; if (!t) return !1; const n = this.getDatasetMeta(e); return "boolean" === typeof n.hidden ? !n.hidden : !t.hidden } setDatasetVisibility(e, t) { this.getDatasetMeta(e).hidden = !t } toggleDataVisibility(e) { this._hiddenIndices[e] = !this._hiddenIndices[e] } getDataVisibility(e) { return !this._hiddenIndices[e] } _updateVisibility(e, t, n) { const r = n ? "show" : "hide", i = this.getDatasetMeta(e), o = i.controller._resolveAnimations(void 0, r); pc(t) ? (i.data[t].hidden = !n, this.update()) : (this.setDatasetVisibility(e, n), o.update(i, { visible: n }), this.update((t => t.datasetIndex === e ? r : void 0))) } hide(e, t) { this._updateVisibility(e, t, !1) } show(e, t) { this._updateVisibility(e, t, !0) } _destroyDatasetMeta(e) { const t = this._metasets[e]; t && t.controller && t.controller._destroy(), delete this._metasets[e] } _stop() { let e, t; for (this.stop(), Id.remove(this), e = 0, t = this.data.datasets.length; e < t; ++e)this._destroyDatasetMeta(e) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: e, ctx: t } = this; this._stop(), this.config.clearCache(), e && (this.unbindEvents(), wu(e, t), this.platform.releaseContext(t), this.canvas = null, this.ctx = null), delete Vf[this.id], this.notifyPlugins("afterDestroy") } toBase64Image() { return this.canvas.toDataURL(...arguments) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const e = this._listeners, t = this.platform, n = (n, r) => { t.addEventListener(this, n, r), e[n] = r }, r = (e, t, n) => { e.offsetX = t, e.offsetY = n, this._eventHandler(e) }; rc(this.options.events, (e => n(e, r))) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const e = this._responsiveListeners, t = this.platform, n = (n, r) => { t.addEventListener(this, n, r), e[n] = r }, r = (n, r) => { e[n] && (t.removeEventListener(this, n, r), delete e[n]) }, i = (e, t) => { this.canvas && this.resize(e, t) }; let o; const a = () => { r("attach", a), this.attached = !0, this.resize(), n("resize", i), n("detach", o) }; o = () => { this.attached = !1, r("resize", i), this._stop(), this._resize(0, 0), n("attach", a) }, t.isAttached(this.canvas) ? a() : o() } unbindEvents() { rc(this._listeners, ((e, t) => { this.platform.removeEventListener(this, t, e) })), this._listeners = {}, rc(this._responsiveListeners, ((e, t) => { this.platform.removeEventListener(this, t, e) })), this._responsiveListeners = void 0 } updateHoverStyle(e, t, n) { const r = n ? "set" : "remove"; let i, o, a, s; for ("dataset" === t && (i = this.getDatasetMeta(e[0].datasetIndex), i.controller["_" + r + "DatasetHoverStyle"]()), a = 0, s = e.length; a < s; ++a) { o = e[a]; const t = o && this.getDatasetMeta(o.datasetIndex).controller; t && t[r + "HoverStyle"](o.element, o.datasetIndex, o.index) } } getActiveElements() { return this._active || [] } setActiveElements(e) { const t = this._active || [], n = e.map((e => { let { datasetIndex: t, index: n } = e; const r = this.getDatasetMeta(t); if (!r) throw new Error("No dataset found at index " + t); return { datasetIndex: t, element: r.data[n], index: n } })); !ic(n, t) && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, t)) } notifyPlugins(e, t, n) { return this._plugins.notify(this, e, t, n) } isPluginEnabled(e) { return 1 === this._plugins._cache.filter((t => t.plugin.id === e)).length } _updateHoverStyles(e, t, n) { const r = this.options.hover, i = (e, t) => e.filter((e => !t.some((t => e.datasetIndex === t.datasetIndex && e.index === t.index)))), o = i(t, e), a = n ? e : i(e, t); o.length && this.updateHoverStyle(o, r.mode, !1), a.length && r.mode && this.updateHoverStyle(a, r.mode, !0) } _eventHandler(e, t) { const n = { event: e, replay: t, cancelable: !0, inChartArea: this.isPointInArea(e) }, r = t => (t.options.events || this.options.events).includes(e.native.type); if (!1 === this.notifyPlugins("beforeEvent", n, r)) return; const i = this._handleEvent(e, t, n.inChartArea); return n.cancelable = !1, this.notifyPlugins("afterEvent", n, r), (i || n.changed) && this.render(), this } _handleEvent(e, t, n) { const { _active: r = [], options: i } = this, o = t, a = this._getActiveElements(e, r, n, o), s = function (e) { return "mouseup" === e.type || "click" === e.type || "contextmenu" === e.type }(e), l = function (e, t, n, r) { return n && "mouseout" !== e.type ? r ? t : e : null }(e, this._lastEvent, n, s); n && (this._lastEvent = null, nc(i.onHover, [e, a, this], this), s && nc(i.onClick, [e, a, this], this)); const c = !ic(a, r); return (c || t) && (this._active = a, this._updateHoverStyles(a, r, t)), this._lastEvent = l, c } _getActiveElements(e, t, n, r) { if ("mouseout" === e.type) return []; if (!n) return t; const i = this.options.hover; return this.getElementsAtEventForMode(e, i.mode, i, r) } } function qf() { return rc(Yf.instances, (e => e._plugins.invalidate())) } function Kf(e, t, n, r) { const i = zu(e.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]); const o = (n - t) / 2, a = Math.min(o, r * t / 2), s = e => { const t = (n - Math.min(o, e)) * r / 2; return Fc(e, 0, Math.min(o, t)) }; return { outerStart: s(i.outerStart), outerEnd: s(i.outerEnd), innerStart: Fc(i.innerStart, 0, a), innerEnd: Fc(i.innerEnd, 0, a) } } function Qf(e, t, n, r) { return { x: n + e * Math.cos(t), y: r + e * Math.sin(t) } } function Xf(e, t, n, r, i, o) { const { x: a, y: s, startAngle: l, pixelMargin: c, innerRadius: u } = t, d = Math.max(t.outerRadius + r + n - c, 0), h = u > 0 ? u + r + n + c : 0; let f = 0; const p = i - l; if (r) { const e = ((u > 0 ? u - r : 0) + (d > 0 ? d - r : 0)) / 2; f = (p - (0 !== e ? p * e / (e + r) : p)) / 2 } const g = (p - Math.max(.001, p * d - n / bc) / d) / 2, m = l + g + f, b = i - g - f, { outerStart: v, outerEnd: y, innerStart: x, innerEnd: w } = Kf(t, h, d, b - m), _ = d - v, k = d - y, S = m + v / _, C = b - y / k, E = h + x, M = h + w, O = m + x / E, P = b - w / M; if (e.beginPath(), o) { const t = (S + C) / 2; if (e.arc(a, s, d, S, t), e.arc(a, s, d, t, C), y > 0) { const t = Qf(k, C, a, s); e.arc(t.x, t.y, y, C, b + _c) } const n = Qf(M, b, a, s); if (e.lineTo(n.x, n.y), w > 0) { const t = Qf(M, P, a, s); e.arc(t.x, t.y, w, b + _c, P + Math.PI) } const r = (b - w / h + (m + x / h)) / 2; if (e.arc(a, s, h, b - w / h, r, !0), e.arc(a, s, h, r, m + x / h, !0), x > 0) { const t = Qf(E, O, a, s); e.arc(t.x, t.y, x, O + Math.PI, m - _c) } const i = Qf(_, m, a, s); if (e.lineTo(i.x, i.y), v > 0) { const t = Qf(_, S, a, s); e.arc(t.x, t.y, v, m - _c, S) } } else { e.moveTo(a, s); const t = Math.cos(S) * d + a, n = Math.sin(S) * d + s; e.lineTo(t, n); const r = Math.cos(C) * d + a, i = Math.sin(C) * d + s; e.lineTo(r, i) } e.closePath() } function Gf(e, t, n, r, i) { const { fullCircles: o, startAngle: a, circumference: s, options: l } = t, { borderWidth: c, borderJoinStyle: u, borderDash: d, borderDashOffset: h } = l, f = "inner" === l.borderAlign; if (!c) return; e.setLineDash(d || []), e.lineDashOffset = h, f ? (e.lineWidth = 2 * c, e.lineJoin = u || "round") : (e.lineWidth = c, e.lineJoin = u || "bevel"); let p = t.endAngle; if (o) { Xf(e, t, n, r, p, i); for (let t = 0; t < o; ++t)e.stroke(); isNaN(s) || (p = a + (s % vc || vc)) } f && function (e, t, n) { const { startAngle: r, pixelMargin: i, x: o, y: a, outerRadius: s, innerRadius: l } = t; let c = i / s; e.beginPath(), e.arc(o, a, s, r - c, n + c), l > i ? (c = i / l, e.arc(o, a, l, n + c, r - c, !0)) : e.arc(o, a, i, n + _c, r - _c), e.closePath(), e.clip() }(e, t, p), o || (Xf(e, t, n, r, p, i), e.stroke()) } fl(Yf, "defaults", bu), fl(Yf, "instances", Vf), fl(Yf, "overrides", hu), fl(Yf, "registry", vf), fl(Yf, "version", "4.4.1"), fl(Yf, "getChart", Hf); class Jf extends of { constructor(e) { super(), fl(this, "circumference", void 0), fl(this, "endAngle", void 0), fl(this, "fullCircles", void 0), fl(this, "innerRadius", void 0), fl(this, "outerRadius", void 0), fl(this, "pixelMargin", void 0), fl(this, "startAngle", void 0), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, e && Object.assign(this, e) } inRange(e, t, n) { const r = this.getProps(["x", "y"], n), { angle: i, distance: o } = Rc(r, { x: e, y: t }), { startAngle: a, endAngle: s, innerRadius: l, outerRadius: c, circumference: u } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], n), d = (this.options.spacing + this.options.borderWidth) / 2, h = ec(u, s - a) >= vc || Ic(i, a, s), f = Bc(o, l + d, c + d); return h && f } getCenterPoint(e) { const { x: t, y: n, startAngle: r, endAngle: i, innerRadius: o, outerRadius: a } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], e), { offset: s, spacing: l } = this.options, c = (r + i) / 2, u = (o + a + l + s) / 2; return { x: t + Math.cos(c) * u, y: n + Math.sin(c) * u } } tooltipPosition(e) { return this.getCenterPoint(e) } draw(e) { const { options: t, circumference: n } = this, r = (t.offset || 0) / 4, i = (t.spacing || 0) / 2, o = t.circular; if (this.pixelMargin = "inner" === t.borderAlign ? .33 : 0, this.fullCircles = n > vc ? Math.floor(n / vc) : 0, 0 === n || this.innerRadius < 0 || this.outerRadius < 0) return; e.save(); const a = (this.startAngle + this.endAngle) / 2; e.translate(Math.cos(a) * r, Math.sin(a) * r); const s = r * (1 - Math.sin(Math.min(bc, n || 0))); e.fillStyle = t.backgroundColor, e.strokeStyle = t.borderColor, function (e, t, n, r, i) { const { fullCircles: o, startAngle: a, circumference: s } = t; let l = t.endAngle; if (o) { Xf(e, t, n, r, l, i); for (let t = 0; t < o; ++t)e.fill(); isNaN(s) || (l = a + (s % vc || vc)) } Xf(e, t, n, r, l, i), e.fill() }(e, this, s, i, o), Gf(e, this, s, i, o), e.restore() } } function Zf(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t; e.lineCap = ec(n.borderCapStyle, t.borderCapStyle), e.setLineDash(ec(n.borderDash, t.borderDash)), e.lineDashOffset = ec(n.borderDashOffset, t.borderDashOffset), e.lineJoin = ec(n.borderJoinStyle, t.borderJoinStyle), e.lineWidth = ec(n.borderWidth, t.borderWidth), e.strokeStyle = ec(n.borderColor, t.borderColor) } function ep(e, t, n) { e.lineTo(n.x, n.y) } function tp(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const r = e.length, { start: i = 0, end: o = r - 1 } = n, { start: a, end: s } = t, l = Math.max(i, a), c = Math.min(o, s), u = i < a && o < a || i > s && o > s; return { count: r, start: l, loop: t.loop, ilen: c < l && !u ? r + c - l : c - l } } function np(e, t, n, r) { const { points: i, options: o } = t, { count: a, start: s, loop: l, ilen: c } = tp(i, n, r), u = function (e) { return e.stepped ? Mu : e.tension || "monotone" === e.cubicInterpolationMode ? Ou : ep }(o); let d, h, f, { move: p = !0, reverse: g } = r || {}; for (d = 0; d <= c; ++d)h = i[(s + (g ? c - d : d)) % a], h.skip || (p ? (e.moveTo(h.x, h.y), p = !1) : u(e, f, h, g, o.stepped), f = h); return l && (h = i[(s + (g ? c : 0)) % a], u(e, f, h, g, o.stepped)), !!l } function rp(e, t, n, r) { const i = t.points, { count: o, start: a, ilen: s } = tp(i, n, r), { move: l = !0, reverse: c } = r || {}; let u, d, h, f, p, g, m = 0, b = 0; const v = e => (a + (c ? s - e : e)) % o, y = () => { f !== p && (e.lineTo(m, p), e.lineTo(m, f), e.lineTo(m, g)) }; for (l && (d = i[v(0)], e.moveTo(d.x, d.y)), u = 0; u <= s; ++u) { if (d = i[v(u)], d.skip) continue; const t = d.x, n = d.y, r = 0 | t; r === h ? (n < f ? f = n : n > p && (p = n), m = (b * m + t) / ++b) : (y(), e.lineTo(t, n), h = r, b = 0, f = p = n), g = n } y() } function ip(e) { const t = e.options, n = t.borderDash && t.borderDash.length; return !e._decimated && !e._loop && !t.tension && "monotone" !== t.cubicInterpolationMode && !t.stepped && !n ? rp : np } fl(Jf, "id", "arc"), fl(Jf, "defaults", { borderAlign: "center", borderColor: "#fff", borderDash: [], borderDashOffset: 0, borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0, circular: !0 }), fl(Jf, "defaultRoutes", { backgroundColor: "backgroundColor" }), fl(Jf, "descriptors", { _scriptable: !0, _indexable: e => "borderDash" !== e }); const op = "function" === typeof Path2D; function ap(e, t, n, r) { op && !t.options.segment ? function (e, t, n, r) { let i = t._path; i || (i = t._path = new Path2D, t.path(i, n, r) && i.closePath()), Zf(e, t.options), e.stroke(i) }(e, t, n, r) : function (e, t, n, r) { const { segments: i, options: o } = t, a = ip(t); for (const s of i) Zf(e, o, s.style), e.beginPath(), a(e, t, s, { start: n, end: n + r - 1 }) && e.closePath(), e.stroke() }(e, t, n, r) } class sp extends of { constructor(e) { super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, e && Object.assign(this, e) } updateControlPoints(e, t) { const n = this.options; if ((n.tension || "monotone" === n.cubicInterpolationMode) && !n.stepped && !this._pointsUpdated) { const r = n.spanGaps ? this._loop : this._fullLoop; ud(this._points, n, e, r, t), this._pointsUpdated = !0 } } set points(e) { this._points = e, delete this._segments, delete this._path, this._pointsUpdated = !1 } get points() { return this._points } get segments() { return this._segments || (this._segments = function (e, t) { const n = e.points, r = e.options.spanGaps, i = n.length; if (!i) return []; const o = !!e._loop, { start: a, end: s } = function (e, t, n, r) { let i = 0, o = t - 1; if (n && !r) for (; i < t && !e[i].skip;)i++; for (; i < t && e[i].skip;)i++; for (i %= t, n && (o += i); o > i && e[o % t].skip;)o--; return o %= t, { start: i, end: o } }(n, i, o, r); return Rd(e, !0 === r ? [{ start: a, end: s, loop: o }] : function (e, t, n, r) { const i = e.length, o = []; let a, s = t, l = e[t]; for (a = t + 1; a <= n; ++a) { const n = e[a % i]; n.skip || n.stop ? l.skip || (r = !1, o.push({ start: t % i, end: (a - 1) % i, loop: r }), t = s = n.stop ? a : null) : (s = a, l.skip && (t = a)), l = n } return null !== s && o.push({ start: t % i, end: s % i, loop: r }), o }(n, a, s < a ? s + i : s, !!e._fullLoop && 0 === a && s === i - 1), n, t) }(this, this.options.segment)) } first() { const e = this.segments, t = this.points; return e.length && t[e[0].start] } last() { const e = this.segments, t = this.points, n = e.length; return n && t[e[n - 1].end] } interpolate(e, t) { const n = this.options, r = e[t], i = this.points, o = Dd(this, { property: t, start: r, end: r }); if (!o.length) return; const a = [], s = function (e) { return e.stepped ? Cd : e.tension || "monotone" === e.cubicInterpolationMode ? Ed : Sd }(n); let l, c; for (l = 0, c = o.length; l < c; ++l) { const { start: c, end: u } = o[l], d = i[c], h = i[u]; if (d === h) { a.push(d); continue } const f = s(d, h, Math.abs((r - d[t]) / (h[t] - d[t])), n.stepped); f[t] = e[t], a.push(f) } return 1 === a.length ? a[0] : a } pathSegment(e, t, n) { return ip(this)(e, this, t, n) } path(e, t, n) { const r = this.segments, i = ip(this); let o = this._loop; t = t || 0, n = n || this.points.length - t; for (const a of r) o &= i(e, this, a, { start: t, end: t + n - 1 }); return !!o } draw(e, t, n, r) { const i = this.options || {}; (this.points || []).length && i.borderWidth && (e.save(), ap(e, this, n, r), e.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } } function lp(e, t, n, r) { const i = e.options, { [n]: o } = e.getProps([n], r); return Math.abs(t - o) < i.radius + i.hitRadius } fl(sp, "id", "line"), fl(sp, "defaults", { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 }), fl(sp, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }), fl(sp, "descriptors", { _scriptable: !0, _indexable: e => "borderDash" !== e && "fill" !== e }); class cp extends of { constructor(e) { super(), fl(this, "parsed", void 0), fl(this, "skip", void 0), fl(this, "stop", void 0), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, e && Object.assign(this, e) } inRange(e, t, n) { const r = this.options, { x: i, y: o } = this.getProps(["x", "y"], n); return Math.pow(e - i, 2) + Math.pow(t - o, 2) < Math.pow(r.hitRadius + r.radius, 2) } inXRange(e, t) { return lp(this, e, "x", t) } inYRange(e, t) { return lp(this, e, "y", t) } getCenterPoint(e) { const { x: t, y: n } = this.getProps(["x", "y"], e); return { x: t, y: n } } size(e) { let t = (e = e || this.options || {}).radius || 0; t = Math.max(t, t && e.hoverRadius || 0); return 2 * (t + (t && e.borderWidth || 0)) } draw(e, t) { const n = this.options; this.skip || n.radius < .1 || !Su(this, t, this.size(n) / 2) || (e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.fillStyle = n.backgroundColor, _u(e, n, this.x, this.y)) } getRange() { const e = this.options || {}; return e.radius + e.hitRadius } } function up(e, t) { const { x: n, y: r, base: i, width: o, height: a } = e.getProps(["x", "y", "base", "width", "height"], t); let s, l, c, u, d; return e.horizontal ? (d = a / 2, s = Math.min(n, i), l = Math.max(n, i), c = r - d, u = r + d) : (d = o / 2, s = n - d, l = n + d, c = Math.min(r, i), u = Math.max(r, i)), { left: s, top: c, right: l, bottom: u } } function dp(e, t, n, r) { return e ? 0 : Fc(t, n, r) } function hp(e) { const t = up(e), n = t.right - t.left, r = t.bottom - t.top, i = function (e, t, n) { const r = e.options.borderWidth, i = e.borderSkipped, o = Iu(r); return { t: dp(i.top, o.top, 0, n), r: dp(i.right, o.right, 0, t), b: dp(i.bottom, o.bottom, 0, n), l: dp(i.left, o.left, 0, t) } }(e, n / 2, r / 2), o = function (e, t, n) { const { enableBorderRadius: r } = e.getProps(["enableBorderRadius"]), i = e.options.borderRadius, o = Fu(i), a = Math.min(t, n), s = e.borderSkipped, l = r || Gl(i); return { topLeft: dp(!l || s.top || s.left, o.topLeft, 0, a), topRight: dp(!l || s.top || s.right, o.topRight, 0, a), bottomLeft: dp(!l || s.bottom || s.left, o.bottomLeft, 0, a), bottomRight: dp(!l || s.bottom || s.right, o.bottomRight, 0, a) } }(e, n / 2, r / 2); return { outer: { x: t.left, y: t.top, w: n, h: r, radius: o }, inner: { x: t.left + i.l, y: t.top + i.t, w: n - i.l - i.r, h: r - i.t - i.b, radius: { topLeft: Math.max(0, o.topLeft - Math.max(i.t, i.l)), topRight: Math.max(0, o.topRight - Math.max(i.t, i.r)), bottomLeft: Math.max(0, o.bottomLeft - Math.max(i.b, i.l)), bottomRight: Math.max(0, o.bottomRight - Math.max(i.b, i.r)) } } } } function fp(e, t, n, r) { const i = null === t, o = null === n, a = e && !(i && o) && up(e, r); return a && (i || Bc(t, a.left, a.right)) && (o || Bc(n, a.top, a.bottom)) } function pp(e, t) { e.rect(t.x, t.y, t.w, t.h) } function gp(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; const r = e.x !== n.x ? -t : 0, i = e.y !== n.y ? -t : 0, o = (e.x + e.w !== n.x + n.w ? t : 0) - r, a = (e.y + e.h !== n.y + n.h ? t : 0) - i; return { x: e.x + r, y: e.y + i, w: e.w + o, h: e.h + a, radius: e.radius } } fl(cp, "id", "point"), fl(cp, "defaults", { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }), fl(cp, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); class mp extends of { constructor(e) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, e && Object.assign(this, e) } draw(e) { const { inflateAmount: t, options: { borderColor: n, backgroundColor: r } } = this, { inner: i, outer: o } = hp(this), a = (s = o.radius).topLeft || s.topRight || s.bottomLeft || s.bottomRight ? ju : pp; var s; e.save(), o.w === i.w && o.h === i.h || (e.beginPath(), a(e, gp(o, t, i)), e.clip(), a(e, gp(i, -t, o)), e.fillStyle = n, e.fill("evenodd")), e.beginPath(), a(e, gp(i, t)), e.fillStyle = r, e.fill(), e.restore() } inRange(e, t, n) { return fp(this, e, t, n) } inXRange(e, t) { return fp(this, e, null, t) } inYRange(e, t) { return fp(this, null, e, t) } getCenterPoint(e) { const { x: t, y: n, base: r, horizontal: i } = this.getProps(["x", "y", "base", "horizontal"], e); return { x: i ? (t + r) / 2 : t, y: i ? n : (n + r) / 2 } } getRange(e) { return "x" === e ? this.width / 2 : this.height / 2 } } fl(mp, "id", "bar"), fl(mp, "defaults", { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 }), fl(mp, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); var bp = Object.freeze({ __proto__: null, ArcElement: Jf, BarElement: mp, LineElement: sp, PointElement: cp }); const vp = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"], yp = vp.map((e => e.replace("rgb(", "rgba(").replace(")", ", 0.5)"))); function xp(e) { return vp[e % vp.length] } function wp(e) { return yp[e % yp.length] } function _p(e) { let t = 0; return (n, r) => { const i = e.getDatasetMeta(r).controller; i instanceof dh ? t = function (e, t) { return e.backgroundColor = e.data.map((() => xp(t++))), t }(n, t) : i instanceof fh ? t = function (e, t) { return e.backgroundColor = e.data.map((() => wp(t++))), t }(n, t) : i && (t = function (e, t) { return e.borderColor = xp(t), e.backgroundColor = wp(t), ++t }(n, t)) } } function kp(e) { let t; for (t in e) if (e[t].borderColor || e[t].backgroundColor) return !0; return !1 } var Sp = { id: "colors", defaults: { enabled: !0, forceOverride: !1 }, beforeLayout(e, t, n) { if (!n.enabled) return; const { data: { datasets: r }, options: i } = e.config, { elements: o } = i; if (!n.forceOverride && (kp(r) || (a = i) && (a.borderColor || a.backgroundColor) || o && kp(o))) return; var a; const s = _p(e); r.forEach(s) } }; function Cp(e) { if (e._decimated) { const t = e._data; delete e._decimated, delete e._data, Object.defineProperty(e, "data", { configurable: !0, enumerable: !0, writable: !0, value: t }) } } function Ep(e) { e.data.datasets.forEach((e => { Cp(e) })) } var Mp = { id: "decimation", defaults: { algorithm: "min-max", enabled: !1 }, beforeElementsUpdate: (e, t, n) => { if (!n.enabled) return void Ep(e); const r = e.width; e.data.datasets.forEach(((t, i) => { const { _data: o, indexAxis: a } = t, s = e.getDatasetMeta(i), l = o || t.data; if ("y" === Vu([a, e.options.indexAxis])) return; if (!s.controller.supportsDecimation) return; const c = e.scales[s.xAxisID]; if ("linear" !== c.type && "time" !== c.type) return; if (e.options.parsing) return; let { start: u, count: d } = function (e, t) { const n = t.length; let r, i = 0; const { iScale: o } = e, { min: a, max: s, minDefined: l, maxDefined: c } = o.getUserBounds(); return l && (i = Fc(Vc(t, o.axis, a).lo, 0, n - 1)), r = c ? Fc(Vc(t, o.axis, s).hi + 1, i, n) - i : n - i, { start: i, count: r } }(s, l); if (d <= (n.threshold || 4 * r)) return void Cp(t); let h; switch (Ql(o) && (t._data = l, delete t.data, Object.defineProperty(t, "data", { configurable: !0, enumerable: !0, get: function () { return this._decimated }, set: function (e) { this._data = e } })), n.algorithm) { case "lttb": h = function (e, t, n, r, i) { const o = i.samples || r; if (o >= n) return e.slice(t, t + n); const a = [], s = (n - 2) / (o - 2); let l = 0; const c = t + n - 1; let u, d, h, f, p, g = t; for (a[l++] = e[g], u = 0; u < o - 2; u++) { let r, i = 0, o = 0; const c = Math.floor((u + 1) * s) + 1 + t, m = Math.min(Math.floor((u + 2) * s) + 1, n) + t, b = m - c; for (r = c; r < m; r++)i += e[r].x, o += e[r].y; i /= b, o /= b; const v = Math.floor(u * s) + 1 + t, y = Math.min(Math.floor((u + 1) * s) + 1, n) + t, { x: x, y: w } = e[g]; for (h = f = -1, r = v; r < y; r++)f = .5 * Math.abs((x - i) * (e[r].y - w) - (x - e[r].x) * (o - w)), f > h && (h = f, d = e[r], p = r); a[l++] = d, g = p } return a[l++] = e[c], a }(l, u, d, r, n); break; case "min-max": h = function (e, t, n, r) { let i, o, a, s, l, c, u, d, h, f, p = 0, g = 0; const m = [], b = t + n - 1, v = e[t].x, y = e[b].x - v; for (i = t; i < t + n; ++i) { o = e[i], a = (o.x - v) / y * r, s = o.y; const t = 0 | a; if (t === l) s < h ? (h = s, c = i) : s > f && (f = s, u = i), p = (g * p + o.x) / ++g; else { const n = i - 1; if (!Ql(c) && !Ql(u)) { const t = Math.min(c, u), r = Math.max(c, u); t !== d && t !== n && m.push({ ...e[t], x: p }), r !== d && r !== n && m.push({ ...e[r], x: p }) } i > 0 && n !== d && m.push(e[n]), m.push(o), l = t, g = 0, h = f = s, c = u = d = i } } return m }(l, u, d, r); break; default: throw new Error("Unsupported decimation algorithm '".concat(n.algorithm, "'")) }t._decimated = h })) }, destroy(e) { Ep(e) } }; function Op(e, t, n, r) { if (r) return; let i = t[e], o = n[e]; return "angle" === e && (i = zc(i), o = zc(o)), { property: e, start: i, end: o } } function Pp(e, t, n) { for (; t > e; t--) { const e = n[t]; if (!isNaN(e.x) && !isNaN(e.y)) break } return t } function Np(e, t, n, r) { return e && t ? r(e[n], t[n]) : e ? e[n] : t ? t[n] : 0 } function Tp(e, t) { let n = [], r = !1; return Xl(e) ? (r = !0, n = e) : n = function (e, t) { const { x: n = null, y: r = null } = e || {}, i = t.points, o = []; return t.segments.forEach((e => { let { start: t, end: a } = e; a = Pp(t, a, i); const s = i[t], l = i[a]; null !== r ? (o.push({ x: s.x, y: r }), o.push({ x: l.x, y: r })) : null !== n && (o.push({ x: n, y: s.y }), o.push({ x: n, y: l.y })) })), o }(e, t), n.length ? new sp({ points: n, options: { tension: 0 }, _loop: r, _fullLoop: r }) : null } function jp(e) { return e && !1 !== e.fill } function Dp(e, t, n) { let r = e[t].fill; const i = [t]; let o; if (!n) return r; for (; !1 !== r && -1 === i.indexOf(r);) { if (!Jl(r)) return r; if (o = e[r], !o) return !1; if (o.visible) return r; i.push(r), r = o.fill } return !1 } function Rp(e, t, n) { const r = function (e) { const t = e.options, n = t.fill; let r = ec(n && n.target, n); void 0 === r && (r = !!t.backgroundColor); if (!1 === r || null === r) return !1; if (!0 === r) return "origin"; return r }(e); if (Gl(r)) return !isNaN(r.value) && r; let i = parseFloat(r); return Jl(i) && Math.floor(i) === i ? function (e, t, n, r) { "-" !== e && "+" !== e || (n = t + n); if (n === t || n < 0 || n >= r) return !1; return n }(r[0], t, i, n) : ["origin", "start", "end", "stack", "shape"].indexOf(r) >= 0 && r } function Lp(e, t, n) { const r = []; for (let i = 0; i < n.length; i++) { const o = n[i], { first: a, last: s, point: l } = Ap(o, t, "x"); if (!(!l || a && s)) if (a) r.unshift(l); else if (e.push(l), !s) break } e.push(...r) } function Ap(e, t, n) { const r = e.interpolate(t, n); if (!r) return {}; const i = r[n], o = e.segments, a = e.points; let s = !1, l = !1; for (let c = 0; c < o.length; c++) { const e = o[c], t = a[e.start][n], r = a[e.end][n]; if (Bc(i, t, r)) { s = i === t, l = i === r; break } } return { first: s, last: l, point: r } } class zp { constructor(e) { this.x = e.x, this.y = e.y, this.radius = e.radius } pathSegment(e, t, n) { const { x: r, y: i, radius: o } = this; return t = t || { start: 0, end: vc }, e.arc(r, i, o, t.end, t.start, !0), !n.bounds } interpolate(e) { const { x: t, y: n, radius: r } = this, i = e.angle; return { x: t + Math.cos(i) * r, y: n + Math.sin(i) * r, angle: i } } } function Ip(e) { const { chart: t, fill: n, line: r } = e; if (Jl(n)) return function (e, t) { const n = e.getDatasetMeta(t), r = n && e.isDatasetVisible(t); return r ? n.dataset : null }(t, n); if ("stack" === n) return function (e) { const { scale: t, index: n, line: r } = e, i = [], o = r.segments, a = r.points, s = function (e, t) { const n = [], r = e.getMatchingVisibleMetas("line"); for (let i = 0; i < r.length; i++) { const e = r[i]; if (e.index === t) break; e.hidden || n.unshift(e.dataset) } return n }(t, n); s.push(Tp({ x: null, y: t.bottom }, r)); for (let l = 0; l < o.length; l++) { const e = o[l]; for (let t = e.start; t <= e.end; t++)Lp(i, a[t], s) } return new sp({ points: i, options: {} }) }(e); if ("shape" === n) return !0; const i = function (e) { const t = e.scale || {}; if (t.getPointPositionForValue) return function (e) { const { scale: t, fill: n } = e, r = t.options, i = t.getLabels().length, o = r.reverse ? t.max : t.min, a = function (e, t, n) { let r; return r = "start" === e ? n : "end" === e ? t.options.reverse ? t.min : t.max : Gl(e) ? e.value : t.getBaseValue(), r }(n, t, o), s = []; if (r.grid.circular) { const e = t.getPointPositionForValue(0, o); return new zp({ x: e.x, y: e.y, radius: t.getDistanceFromCenterForValue(a) }) } for (let l = 0; l < i; ++l)s.push(t.getPointPositionForValue(l, a)); return s }(e); return function (e) { const { scale: t = {}, fill: n } = e, r = function (e, t) { let n = null; return "start" === e ? n = t.bottom : "end" === e ? n = t.top : Gl(e) ? n = t.getPixelForValue(e.value) : t.getBasePixel && (n = t.getBasePixel()), n }(n, t); if (Jl(r)) { const e = t.isHorizontal(); return { x: e ? r : null, y: e ? null : r } } return null }(e) }(e); return i instanceof zp ? i : Tp(i, r) } function Fp(e, t, n) { const r = Ip(t), { line: i, scale: o, axis: a } = t, s = i.options, l = s.fill, c = s.backgroundColor, { above: u = c, below: d = c } = l || {}; r && i.points.length && (Cu(e, n), function (e, t) { const { line: n, target: r, above: i, below: o, area: a, scale: s } = t, l = n._loop ? "angle" : t.axis; e.save(), "x" === l && o !== i && (Bp(e, r, a.top), Wp(e, { line: n, target: r, color: i, scale: s, property: l }), e.restore(), e.save(), Bp(e, r, a.bottom)); Wp(e, { line: n, target: r, color: o, scale: s, property: l }), e.restore() }(e, { line: i, target: r, above: u, below: d, area: n, scale: o, axis: a }), Eu(e)) } function Bp(e, t, n) { const { segments: r, points: i } = t; let o = !0, a = !1; e.beginPath(); for (const s of r) { const { start: r, end: l } = s, c = i[r], u = i[Pp(r, l, i)]; o ? (e.moveTo(c.x, c.y), o = !1) : (e.lineTo(c.x, n), e.lineTo(c.x, c.y)), a = !!t.pathSegment(e, s, { move: a }), a ? e.closePath() : e.lineTo(u.x, n) } e.lineTo(t.first().x, n), e.closePath(), e.clip() } function Wp(e, t) { const { line: n, target: r, property: i, color: o, scale: a } = t, s = function (e, t, n) { const r = e.segments, i = e.points, o = t.points, a = []; for (const s of r) { let { start: e, end: r } = s; r = Pp(e, r, i); const l = Op(n, i[e], i[r], s.loop); if (!t.segments) { a.push({ source: s, target: l, start: i[e], end: i[r] }); continue } const c = Dd(t, l); for (const t of c) { const e = Op(n, o[t.start], o[t.end], t.loop), r = jd(s, i, e); for (const i of r) a.push({ source: i, target: t, start: { [n]: Np(l, e, "start", Math.max) }, end: { [n]: Np(l, e, "end", Math.min) } }) } } return a }(n, r, i); for (const { source: l, target: c, start: u, end: d } of s) { const { style: { backgroundColor: t = o } = {} } = l, s = !0 !== r; e.save(), e.fillStyle = t, Vp(e, a, s && Op(i, u, d)), e.beginPath(); const h = !!n.pathSegment(e, l); let f; if (s) { h ? e.closePath() : Hp(e, r, d, i); const t = !!r.pathSegment(e, c, { move: h, reverse: !0 }); f = h && t, f || Hp(e, r, u, i) } e.closePath(), e.fill(f ? "evenodd" : "nonzero"), e.restore() } } function Vp(e, t, n) { const { top: r, bottom: i } = t.chart.chartArea, { property: o, start: a, end: s } = n || {}; "x" === o && (e.beginPath(), e.rect(a, r, s - a, i - r), e.clip()) } function Hp(e, t, n, r) { const i = t.interpolate(n, r); i && e.lineTo(i.x, i.y) } var Up = { id: "filler", afterDatasetsUpdate(e, t, n) { const r = (e.data.datasets || []).length, i = []; let o, a, s, l; for (a = 0; a < r; ++a)o = e.getDatasetMeta(a), s = o.dataset, l = null, s && s.options && s instanceof sp && (l = { visible: e.isDatasetVisible(a), index: a, fill: Rp(s, a, r), chart: e, axis: o.controller.options.indexAxis, scale: o.vScale, line: s }), o.$filler = l, i.push(l); for (a = 0; a < r; ++a)l = i[a], l && !1 !== l.fill && (l.fill = Dp(i, a, n.propagate)) }, beforeDraw(e, t, n) { const r = "beforeDraw" === n.drawTime, i = e.getSortedVisibleDatasetMetas(), o = e.chartArea; for (let a = i.length - 1; a >= 0; --a) { const t = i[a].$filler; t && (t.line.updateControlPoints(o, t.axis), r && t.fill && Fp(e.ctx, t, o)) } }, beforeDatasetsDraw(e, t, n) { if ("beforeDatasetsDraw" !== n.drawTime) return; const r = e.getSortedVisibleDatasetMetas(); for (let i = r.length - 1; i >= 0; --i) { const t = r[i].$filler; jp(t) && Fp(e.ctx, t, e.chartArea) } }, beforeDatasetDraw(e, t, n) { const r = t.meta.$filler; jp(r) && "beforeDatasetDraw" === n.drawTime && Fp(e.ctx, r, e.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const $p = (e, t) => { let { boxHeight: n = t, boxWidth: r = t } = e; return e.usePointStyle && (n = Math.min(n, t), r = e.pointStyleWidth || Math.min(r, t)), { boxWidth: r, boxHeight: n, itemHeight: Math.max(t, n) } }; class Yp extends of { constructor(e) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, t, n) { this.maxWidth = e, this.maxHeight = t, this._margins = n, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const e = this.options.labels || {}; let t = nc(e.generateLabels, [this.chart], this) || []; e.filter && (t = t.filter((t => e.filter(t, this.chart.data)))), e.sort && (t = t.sort(((t, n) => e.sort(t, n, this.chart.data)))), this.options.reverse && t.reverse(), this.legendItems = t } fit() { const { options: e, ctx: t } = this; if (!e.display) return void (this.width = this.height = 0); const n = e.labels, r = Wu(n.font), i = r.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: s } = $p(n, i); let l, c; t.font = r.string, this.isHorizontal() ? (l = this.maxWidth, c = this._fitRows(o, i, a, s) + 10) : (c = this.maxHeight, l = this._fitCols(o, r, a, s) + 10), this.width = Math.min(l, e.maxWidth || this.maxWidth), this.height = Math.min(c, e.maxHeight || this.maxHeight) } _fitRows(e, t, n, r) { const { ctx: i, maxWidth: o, options: { labels: { padding: a } } } = this, s = this.legendHitBoxes = [], l = this.lineWidths = [0], c = r + a; let u = e; i.textAlign = "left", i.textBaseline = "middle"; let d = -1, h = -c; return this.legendItems.forEach(((e, f) => { const p = n + t / 2 + i.measureText(e.text).width; (0 === f || l[l.length - 1] + p + 2 * a > o) && (u += c, l[l.length - (f > 0 ? 0 : 1)] = 0, h += c, d++), s[f] = { left: 0, top: h, row: d, width: p, height: r }, l[l.length - 1] += p + a })), u } _fitCols(e, t, n, r) { const { ctx: i, maxHeight: o, options: { labels: { padding: a } } } = this, s = this.legendHitBoxes = [], l = this.columnSizes = [], c = o - e; let u = a, d = 0, h = 0, f = 0, p = 0; return this.legendItems.forEach(((e, o) => { const { itemWidth: g, itemHeight: m } = function (e, t, n, r, i) { const o = function (e, t, n, r) { let i = e.text; i && "string" !== typeof i && (i = i.reduce(((e, t) => e.length > t.length ? e : t))); return t + n.size / 2 + r.measureText(i).width }(r, e, t, n), a = function (e, t, n) { let r = e; "string" !== typeof t.text && (r = qp(t, n)); return r }(i, r, t.lineHeight); return { itemWidth: o, itemHeight: a } }(n, t, i, e, r); o > 0 && h + m + 2 * a > c && (u += d + a, l.push({ width: d, height: h }), f += d + a, p++, d = h = 0), s[o] = { left: f, top: h, col: p, width: g, height: m }, d = Math.max(d, g), h += m + a })), u += d, l.push({ width: d, height: h }), u } adjustHitBoxes() { if (!this.options.display) return; const e = this._computeTitleHeight(), { legendHitBoxes: t, options: { align: n, labels: { padding: r }, rtl: i } } = this, o = Md(i, this.left, this.width); if (this.isHorizontal()) { let i = 0, a = Xc(n, this.left + r, this.right - this.lineWidths[i]); for (const s of t) i !== s.row && (i = s.row, a = Xc(n, this.left + r, this.right - this.lineWidths[i])), s.top += this.top + e + r, s.left = o.leftForLtr(o.x(a), s.width), a += s.width + r } else { let i = 0, a = Xc(n, this.top + e + r, this.bottom - this.columnSizes[i].height); for (const s of t) s.col !== i && (i = s.col, a = Xc(n, this.top + e + r, this.bottom - this.columnSizes[i].height)), s.top = a, s.left += this.left + r, s.left = o.leftForLtr(o.x(s.left), s.width), a += s.height + r } } isHorizontal() { return "top" === this.options.position || "bottom" === this.options.position } draw() { if (this.options.display) { const e = this.ctx; Cu(e, this), this._draw(), Eu(e) } } _draw() { const { options: e, columnSizes: t, lineWidths: n, ctx: r } = this, { align: i, labels: o } = e, a = bu.color, s = Md(e.rtl, this.left, this.width), l = Wu(o.font), { padding: c } = o, u = l.size, d = u / 2; let h; this.drawTitle(), r.textAlign = s.textAlign("left"), r.textBaseline = "middle", r.lineWidth = .5, r.font = l.string; const { boxWidth: f, boxHeight: p, itemHeight: g } = $p(o, u), m = this.isHorizontal(), b = this._computeTitleHeight(); h = m ? { x: Xc(i, this.left + c, this.right - n[0]), y: this.top + c + b, line: 0 } : { x: this.left + c, y: Xc(i, this.top + b + c, this.bottom - t[0].height), line: 0 }, Od(this.ctx, e.textDirection); const v = g + c; this.legendItems.forEach(((y, x) => { r.strokeStyle = y.fontColor, r.fillStyle = y.fontColor; const w = r.measureText(y.text).width, _ = s.textAlign(y.textAlign || (y.textAlign = o.textAlign)), k = f + d + w; let S = h.x, C = h.y; s.setWidth(this.width), m ? x > 0 && S + k + c > this.right && (C = h.y += v, h.line++, S = h.x = Xc(i, this.left + c, this.right - n[h.line])) : x > 0 && C + v > this.bottom && (S = h.x = S + t[h.line].width + c, h.line++, C = h.y = Xc(i, this.top + b + c, this.bottom - t[h.line].height)); if (function (e, t, n) { if (isNaN(f) || f <= 0 || isNaN(p) || p < 0) return; r.save(); const i = ec(n.lineWidth, 1); if (r.fillStyle = ec(n.fillStyle, a), r.lineCap = ec(n.lineCap, "butt"), r.lineDashOffset = ec(n.lineDashOffset, 0), r.lineJoin = ec(n.lineJoin, "miter"), r.lineWidth = i, r.strokeStyle = ec(n.strokeStyle, a), r.setLineDash(ec(n.lineDash, [])), o.usePointStyle) { const a = { radius: p * Math.SQRT2 / 2, pointStyle: n.pointStyle, rotation: n.rotation, borderWidth: i }, l = s.xPlus(e, f / 2); ku(r, a, l, t + d, o.pointStyleWidth && f) } else { const o = t + Math.max((u - p) / 2, 0), a = s.leftForLtr(e, f), l = Fu(n.borderRadius); r.beginPath(), Object.values(l).some((e => 0 !== e)) ? ju(r, { x: a, y: o, w: f, h: p, radius: l }) : r.rect(a, o, f, p), r.fill(), 0 !== i && r.stroke() } r.restore() }(s.x(S), C, y), S = ((e, t, n, r) => e === (r ? "left" : "right") ? n : "center" === e ? (t + n) / 2 : t)(_, S + f + d, m ? S + k : this.right, e.rtl), function (e, t, n) { Tu(r, n.text, e, t + g / 2, l, { strikethrough: n.hidden, textAlign: s.textAlign(n.textAlign) }) }(s.x(S), C, y), m) h.x += k + c; else if ("string" !== typeof y.text) { const e = l.lineHeight; h.y += qp(y, e) + c } else h.y += v })), Pd(this.ctx, e.textDirection) } drawTitle() { const e = this.options, t = e.title, n = Wu(t.font), r = Bu(t.padding); if (!t.display) return; const i = Md(e.rtl, this.left, this.width), o = this.ctx, a = t.position, s = n.size / 2, l = r.top + s; let c, u = this.left, d = this.width; if (this.isHorizontal()) d = Math.max(...this.lineWidths), c = this.top + l, u = Xc(e.align, u, this.right - d); else { const t = this.columnSizes.reduce(((e, t) => Math.max(e, t.height)), 0); c = l + Xc(e.align, this.top, this.bottom - t - e.labels.padding - this._computeTitleHeight()) } const h = Xc(a, u, u + d); o.textAlign = i.textAlign(Qc(a)), o.textBaseline = "middle", o.strokeStyle = t.color, o.fillStyle = t.color, o.font = n.string, Tu(o, t.text, h, c, n) } _computeTitleHeight() { const e = this.options.title, t = Wu(e.font), n = Bu(e.padding); return e.display ? t.lineHeight + n.height : 0 } _getLegendItemAt(e, t) { let n, r, i; if (Bc(e, this.left, this.right) && Bc(t, this.top, this.bottom)) for (i = this.legendHitBoxes, n = 0; n < i.length; ++n)if (r = i[n], Bc(e, r.left, r.left + r.width) && Bc(t, r.top, r.top + r.height)) return this.legendItems[n]; return null } handleEvent(e) { const t = this.options; if (!function (e, t) { if (("mousemove" === e || "mouseout" === e) && (t.onHover || t.onLeave)) return !0; if (t.onClick && ("click" === e || "mouseup" === e)) return !0; return !1 }(e.type, t)) return; const n = this._getLegendItemAt(e.x, e.y); if ("mousemove" === e.type || "mouseout" === e.type) { const r = this._hoveredItem, i = ((e, t) => null !== e && null !== t && e.datasetIndex === t.datasetIndex && e.index === t.index)(r, n); r && !i && nc(t.onLeave, [e, r, this], this), this._hoveredItem = n, n && !i && nc(t.onHover, [e, n, this], this) } else n && nc(t.onClick, [e, n, this], this) } } function qp(e, t) { return t * (e.text ? e.text.length : 0) } var Kp = { id: "legend", _element: Yp, start(e, t, n) { const r = e.legend = new Yp({ ctx: e.ctx, options: n, chart: e }); Bh.configure(e, r, n), Bh.addBox(e, r) }, stop(e) { Bh.removeBox(e, e.legend), delete e.legend }, beforeUpdate(e, t, n) { const r = e.legend; Bh.configure(e, r, n), r.options = n }, afterUpdate(e) { const t = e.legend; t.buildLabels(), t.adjustHitBoxes() }, afterEvent(e, t) { t.replay || e.legend.handleEvent(t.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(e, t, n) { const r = t.datasetIndex, i = n.chart; i.isDatasetVisible(r) ? (i.hide(r), t.hidden = !0) : (i.show(r), t.hidden = !1) }, onHover: null, onLeave: null, labels: { color: e => e.chart.options.color, boxWidth: 40, padding: 10, generateLabels(e) { const t = e.data.datasets, { labels: { usePointStyle: n, pointStyle: r, textAlign: i, color: o, useBorderRadius: a, borderRadius: s } } = e.legend.options; return e._getSortedDatasetMetas().map((e => { const l = e.controller.getStyle(n ? 0 : void 0), c = Bu(l.borderWidth); return { text: t[e.index].label, fillStyle: l.backgroundColor, fontColor: o, hidden: !e.visible, lineCap: l.borderCapStyle, lineDash: l.borderDash, lineDashOffset: l.borderDashOffset, lineJoin: l.borderJoinStyle, lineWidth: (c.width + c.height) / 4, strokeStyle: l.borderColor, pointStyle: r || l.pointStyle, rotation: l.rotation, textAlign: i || l.textAlign, borderRadius: a && (s || l.borderRadius), datasetIndex: e.index } }), this) } }, title: { color: e => e.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: e => !e.startsWith("on"), labels: { _scriptable: e => !["generateLabels", "filter", "sort"].includes(e) } } }; class Qp extends of { constructor(e) { super(), this.chart = e.chart, this.options = e.options, this.ctx = e.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(e, t) { const n = this.options; if (this.left = 0, this.top = 0, !n.display) return void (this.width = this.height = this.right = this.bottom = 0); this.width = this.right = e, this.height = this.bottom = t; const r = Xl(n.text) ? n.text.length : 1; this._padding = Bu(n.padding); const i = r * Wu(n.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = i : this.width = i } isHorizontal() { const e = this.options.position; return "top" === e || "bottom" === e } _drawArgs(e) { const { top: t, left: n, bottom: r, right: i, options: o } = this, a = o.align; let s, l, c, u = 0; return this.isHorizontal() ? (l = Xc(a, n, i), c = t + e, s = i - n) : ("left" === o.position ? (l = n + e, c = Xc(a, r, t), u = -.5 * bc) : (l = i - e, c = Xc(a, t, r), u = .5 * bc), s = r - t), { titleX: l, titleY: c, maxWidth: s, rotation: u } } draw() { const e = this.ctx, t = this.options; if (!t.display) return; const n = Wu(t.font), r = n.lineHeight / 2 + this._padding.top, { titleX: i, titleY: o, maxWidth: a, rotation: s } = this._drawArgs(r); Tu(e, t.text, 0, 0, n, { color: t.color, maxWidth: a, rotation: s, textAlign: Qc(t.align), textBaseline: "middle", translation: [i, o] }) } } var Xp = { id: "title", _element: Qp, start(e, t, n) { !function (e, t) { const n = new Qp({ ctx: e.ctx, options: t, chart: e }); Bh.configure(e, n, t), Bh.addBox(e, n), e.titleBlock = n }(e, n) }, stop(e) { const t = e.titleBlock; Bh.removeBox(e, t), delete e.titleBlock }, beforeUpdate(e, t, n) { const r = e.titleBlock; Bh.configure(e, r, n), r.options = n }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const Gp = new WeakMap; var Jp = { id: "subtitle", start(e, t, n) { const r = new Qp({ ctx: e.ctx, options: n, chart: e }); Bh.configure(e, r, n), Bh.addBox(e, r), Gp.set(e, r) }, stop(e) { Bh.removeBox(e, Gp.get(e)), Gp.delete(e) }, beforeUpdate(e, t, n) { const r = Gp.get(e); Bh.configure(e, r, n), r.options = n }, defaults: { align: "center", display: !1, font: { weight: "normal" }, fullSize: !0, padding: 0, position: "top", text: "", weight: 1500 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const Zp = { average(e) { if (!e.length) return !1; let t, n, r = 0, i = 0, o = 0; for (t = 0, n = e.length; t < n; ++t) { const n = e[t].element; if (n && n.hasValue()) { const e = n.tooltipPosition(); r += e.x, i += e.y, ++o } } return { x: r / o, y: i / o } }, nearest(e, t) { if (!e.length) return !1; let n, r, i, o = t.x, a = t.y, s = Number.POSITIVE_INFINITY; for (n = 0, r = e.length; n < r; ++n) { const r = e[n].element; if (r && r.hasValue()) { const e = Lc(t, r.getCenterPoint()); e < s && (s = e, i = r) } } if (i) { const e = i.tooltipPosition(); o = e.x, a = e.y } return { x: o, y: a } } }; function eg(e, t) { return t && (Xl(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e } function tg(e) { return ("string" === typeof e || e instanceof String) && e.indexOf("\n") > -1 ? e.split("\n") : e } function ng(e, t) { const { element: n, datasetIndex: r, index: i } = t, o = e.getDatasetMeta(r).controller, { label: a, value: s } = o.getLabelAndValue(i); return { chart: e, label: a, parsed: o.getParsed(i), raw: e.data.datasets[r].data[i], formattedValue: s, dataset: o.getDataset(), dataIndex: i, datasetIndex: r, element: n } } function rg(e, t) { const n = e.chart.ctx, { body: r, footer: i, title: o } = e, { boxWidth: a, boxHeight: s } = t, l = Wu(t.bodyFont), c = Wu(t.titleFont), u = Wu(t.footerFont), d = o.length, h = i.length, f = r.length, p = Bu(t.padding); let g = p.height, m = 0, b = r.reduce(((e, t) => e + t.before.length + t.lines.length + t.after.length), 0); if (b += e.beforeBody.length + e.afterBody.length, d && (g += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), b) { g += f * (t.displayColors ? Math.max(s, l.lineHeight) : l.lineHeight) + (b - f) * l.lineHeight + (b - 1) * t.bodySpacing } h && (g += t.footerMarginTop + h * u.lineHeight + (h - 1) * t.footerSpacing); let v = 0; const y = function (e) { m = Math.max(m, n.measureText(e).width + v) }; return n.save(), n.font = c.string, rc(e.title, y), n.font = l.string, rc(e.beforeBody.concat(e.afterBody), y), v = t.displayColors ? a + 2 + t.boxPadding : 0, rc(r, (e => { rc(e.before, y), rc(e.lines, y), rc(e.after, y) })), v = 0, n.font = u.string, rc(e.footer, y), n.restore(), m += p.width, { width: m, height: g } } function ig(e, t, n, r) { const { x: i, width: o } = n, { width: a, chartArea: { left: s, right: l } } = e; let c = "center"; return "center" === r ? c = i <= (s + l) / 2 ? "left" : "right" : i <= o / 2 ? c = "left" : i >= a - o / 2 && (c = "right"), function (e, t, n, r) { const { x: i, width: o } = r, a = n.caretSize + n.caretPadding; return "left" === e && i + o + a > t.width || "right" === e && i - o - a < 0 || void 0 }(c, e, t, n) && (c = "center"), c } function og(e, t, n) { const r = n.yAlign || t.yAlign || function (e, t) { const { y: n, height: r } = t; return n < r / 2 ? "top" : n > e.height - r / 2 ? "bottom" : "center" }(e, n); return { xAlign: n.xAlign || t.xAlign || ig(e, t, n, r), yAlign: r } } function ag(e, t, n, r) { const { caretSize: i, caretPadding: o, cornerRadius: a } = e, { xAlign: s, yAlign: l } = n, c = i + o, { topLeft: u, topRight: d, bottomLeft: h, bottomRight: f } = Fu(a); let p = function (e, t) { let { x: n, width: r } = e; return "right" === t ? n -= r : "center" === t && (n -= r / 2), n }(t, s); const g = function (e, t, n) { let { y: r, height: i } = e; return "top" === t ? r += n : r -= "bottom" === t ? i + n : i / 2, r }(t, l, c); return "center" === l ? "left" === s ? p += c : "right" === s && (p -= c) : "left" === s ? p -= Math.max(u, h) + i : "right" === s && (p += Math.max(d, f) + i), { x: Fc(p, 0, r.width - t.width), y: Fc(g, 0, r.height - t.height) } } function sg(e, t, n) { const r = Bu(n.padding); return "center" === t ? e.x + e.width / 2 : "right" === t ? e.x + e.width - r.right : e.x + r.left } function lg(e) { return eg([], tg(e)) } function cg(e, t) { const n = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks; return n ? e.override(n) : e } const ug = { beforeTitle: ql, title(e) { if (e.length > 0) { const t = e[0], n = t.chart.data.labels, r = n ? n.length : 0; if (this && this.options && "dataset" === this.options.mode) return t.dataset.label || ""; if (t.label) return t.label; if (r > 0 && t.dataIndex < r) return n[t.dataIndex] } return "" }, afterTitle: ql, beforeBody: ql, beforeLabel: ql, label(e) { if (this && this.options && "dataset" === this.options.mode) return e.label + ": " + e.formattedValue || e.formattedValue; let t = e.dataset.label || ""; t && (t += ": "); const n = e.formattedValue; return Ql(n) || (t += n), t }, labelColor(e) { const t = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex); return { borderColor: t.borderColor, backgroundColor: t.backgroundColor, borderWidth: t.borderWidth, borderDash: t.borderDash, borderDashOffset: t.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(e) { const t = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex); return { pointStyle: t.pointStyle, rotation: t.rotation } }, afterLabel: ql, afterBody: ql, beforeFooter: ql, footer: ql, afterFooter: ql }; function dg(e, t, n, r) { const i = e[t].call(n, r); return "undefined" === typeof i ? ug[t].call(n, r) : i } class hg extends of { constructor(e) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = e.chart, this.options = e.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(e) { this.options = e, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const e = this._cachedAnimations; if (e) return e; const t = this.chart, n = this.options.setContext(this.getContext()), r = n.enabled && t.options.animation && n.animations, i = new Vd(this.chart, r); return r._cacheable && (this._cachedAnimations = Object.freeze(i)), i } getContext() { return this.$context || (this.$context = (e = this.chart.getContext(), t = this, n = this._tooltipItems, Hu(e, { tooltip: t, tooltipItems: n, type: "tooltip" }))); var e, t, n } getTitle(e, t) { const { callbacks: n } = t, r = dg(n, "beforeTitle", this, e), i = dg(n, "title", this, e), o = dg(n, "afterTitle", this, e); let a = []; return a = eg(a, tg(r)), a = eg(a, tg(i)), a = eg(a, tg(o)), a } getBeforeBody(e, t) { return lg(dg(t.callbacks, "beforeBody", this, e)) } getBody(e, t) { const { callbacks: n } = t, r = []; return rc(e, (e => { const t = { before: [], lines: [], after: [] }, i = cg(n, e); eg(t.before, tg(dg(i, "beforeLabel", this, e))), eg(t.lines, dg(i, "label", this, e)), eg(t.after, tg(dg(i, "afterLabel", this, e))), r.push(t) })), r } getAfterBody(e, t) { return lg(dg(t.callbacks, "afterBody", this, e)) } getFooter(e, t) { const { callbacks: n } = t, r = dg(n, "beforeFooter", this, e), i = dg(n, "footer", this, e), o = dg(n, "afterFooter", this, e); let a = []; return a = eg(a, tg(r)), a = eg(a, tg(i)), a = eg(a, tg(o)), a } _createItems(e) { const t = this._active, n = this.chart.data, r = [], i = [], o = []; let a, s, l = []; for (a = 0, s = t.length; a < s; ++a)l.push(ng(this.chart, t[a])); return e.filter && (l = l.filter(((t, r, i) => e.filter(t, r, i, n)))), e.itemSort && (l = l.sort(((t, r) => e.itemSort(t, r, n)))), rc(l, (t => { const n = cg(e.callbacks, t); r.push(dg(n, "labelColor", this, t)), i.push(dg(n, "labelPointStyle", this, t)), o.push(dg(n, "labelTextColor", this, t)) })), this.labelColors = r, this.labelPointStyles = i, this.labelTextColors = o, this.dataPoints = l, l } update(e, t) { const n = this.options.setContext(this.getContext()), r = this._active; let i, o = []; if (r.length) { const e = Zp[n.position].call(this, r, this._eventPosition); o = this._createItems(n), this.title = this.getTitle(o, n), this.beforeBody = this.getBeforeBody(o, n), this.body = this.getBody(o, n), this.afterBody = this.getAfterBody(o, n), this.footer = this.getFooter(o, n); const t = this._size = rg(this, n), a = Object.assign({}, e, t), s = og(this.chart, n, a), l = ag(n, a, s, this.chart); this.xAlign = s.xAlign, this.yAlign = s.yAlign, i = { opacity: 1, x: l.x, y: l.y, width: t.width, height: t.height, caretX: e.x, caretY: e.y } } else 0 !== this.opacity && (i = { opacity: 0 }); this._tooltipItems = o, this.$context = void 0, i && this._resolveAnimations().update(this, i), e && n.external && n.external.call(this, { chart: this.chart, tooltip: this, replay: t }) } drawCaret(e, t, n, r) { const i = this.getCaretPosition(e, n, r); t.lineTo(i.x1, i.y1), t.lineTo(i.x2, i.y2), t.lineTo(i.x3, i.y3) } getCaretPosition(e, t, n) { const { xAlign: r, yAlign: i } = this, { caretSize: o, cornerRadius: a } = n, { topLeft: s, topRight: l, bottomLeft: c, bottomRight: u } = Fu(a), { x: d, y: h } = e, { width: f, height: p } = t; let g, m, b, v, y, x; return "center" === i ? (y = h + p / 2, "left" === r ? (g = d, m = g - o, v = y + o, x = y - o) : (g = d + f, m = g + o, v = y - o, x = y + o), b = g) : (m = "left" === r ? d + Math.max(s, c) + o : "right" === r ? d + f - Math.max(l, u) - o : this.caretX, "top" === i ? (v = h, y = v - o, g = m - o, b = m + o) : (v = h + p, y = v + o, g = m + o, b = m - o), x = v), { x1: g, x2: m, x3: b, y1: v, y2: y, y3: x } } drawTitle(e, t, n) { const r = this.title, i = r.length; let o, a, s; if (i) { const l = Md(n.rtl, this.x, this.width); for (e.x = sg(this, n.titleAlign, n), t.textAlign = l.textAlign(n.titleAlign), t.textBaseline = "middle", o = Wu(n.titleFont), a = n.titleSpacing, t.fillStyle = n.titleColor, t.font = o.string, s = 0; s < i; ++s)t.fillText(r[s], l.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + a, s + 1 === i && (e.y += n.titleMarginBottom - a) } } _drawColorBox(e, t, n, r, i) { const o = this.labelColors[n], a = this.labelPointStyles[n], { boxHeight: s, boxWidth: l } = i, c = Wu(i.bodyFont), u = sg(this, "left", i), d = r.x(u), h = s < c.lineHeight ? (c.lineHeight - s) / 2 : 0, f = t.y + h; if (i.usePointStyle) { const t = { radius: Math.min(l, s) / 2, pointStyle: a.pointStyle, rotation: a.rotation, borderWidth: 1 }, n = r.leftForLtr(d, l) + l / 2, c = f + s / 2; e.strokeStyle = i.multiKeyBackground, e.fillStyle = i.multiKeyBackground, _u(e, t, n, c), e.strokeStyle = o.borderColor, e.fillStyle = o.backgroundColor, _u(e, t, n, c) } else { e.lineWidth = Gl(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, e.strokeStyle = o.borderColor, e.setLineDash(o.borderDash || []), e.lineDashOffset = o.borderDashOffset || 0; const t = r.leftForLtr(d, l), n = r.leftForLtr(r.xPlus(d, 1), l - 2), a = Fu(o.borderRadius); Object.values(a).some((e => 0 !== e)) ? (e.beginPath(), e.fillStyle = i.multiKeyBackground, ju(e, { x: t, y: f, w: l, h: s, radius: a }), e.fill(), e.stroke(), e.fillStyle = o.backgroundColor, e.beginPath(), ju(e, { x: n, y: f + 1, w: l - 2, h: s - 2, radius: a }), e.fill()) : (e.fillStyle = i.multiKeyBackground, e.fillRect(t, f, l, s), e.strokeRect(t, f, l, s), e.fillStyle = o.backgroundColor, e.fillRect(n, f + 1, l - 2, s - 2)) } e.fillStyle = this.labelTextColors[n] } drawBody(e, t, n) { const { body: r } = this, { bodySpacing: i, bodyAlign: o, displayColors: a, boxHeight: s, boxWidth: l, boxPadding: c } = n, u = Wu(n.bodyFont); let d = u.lineHeight, h = 0; const f = Md(n.rtl, this.x, this.width), p = function (n) { t.fillText(n, f.x(e.x + h), e.y + d / 2), e.y += d + i }, g = f.textAlign(o); let m, b, v, y, x, w, _; for (t.textAlign = o, t.textBaseline = "middle", t.font = u.string, e.x = sg(this, g, n), t.fillStyle = n.bodyColor, rc(this.beforeBody, p), h = a && "right" !== g ? "center" === o ? l / 2 + c : l + 2 + c : 0, y = 0, w = r.length; y < w; ++y) { for (m = r[y], b = this.labelTextColors[y], t.fillStyle = b, rc(m.before, p), v = m.lines, a && v.length && (this._drawColorBox(t, e, y, f, n), d = Math.max(u.lineHeight, s)), x = 0, _ = v.length; x < _; ++x)p(v[x]), d = u.lineHeight; rc(m.after, p) } h = 0, d = u.lineHeight, rc(this.afterBody, p), e.y -= i } drawFooter(e, t, n) { const r = this.footer, i = r.length; let o, a; if (i) { const s = Md(n.rtl, this.x, this.width); for (e.x = sg(this, n.footerAlign, n), e.y += n.footerMarginTop, t.textAlign = s.textAlign(n.footerAlign), t.textBaseline = "middle", o = Wu(n.footerFont), t.fillStyle = n.footerColor, t.font = o.string, a = 0; a < i; ++a)t.fillText(r[a], s.x(e.x), e.y + o.lineHeight / 2), e.y += o.lineHeight + n.footerSpacing } } drawBackground(e, t, n, r) { const { xAlign: i, yAlign: o } = this, { x: a, y: s } = e, { width: l, height: c } = n, { topLeft: u, topRight: d, bottomLeft: h, bottomRight: f } = Fu(r.cornerRadius); t.fillStyle = r.backgroundColor, t.strokeStyle = r.borderColor, t.lineWidth = r.borderWidth, t.beginPath(), t.moveTo(a + u, s), "top" === o && this.drawCaret(e, t, n, r), t.lineTo(a + l - d, s), t.quadraticCurveTo(a + l, s, a + l, s + d), "center" === o && "right" === i && this.drawCaret(e, t, n, r), t.lineTo(a + l, s + c - f), t.quadraticCurveTo(a + l, s + c, a + l - f, s + c), "bottom" === o && this.drawCaret(e, t, n, r), t.lineTo(a + h, s + c), t.quadraticCurveTo(a, s + c, a, s + c - h), "center" === o && "left" === i && this.drawCaret(e, t, n, r), t.lineTo(a, s + u), t.quadraticCurveTo(a, s, a + u, s), t.closePath(), t.fill(), r.borderWidth > 0 && t.stroke() } _updateAnimationTarget(e) { const t = this.chart, n = this.$animations, r = n && n.x, i = n && n.y; if (r || i) { const n = Zp[e.position].call(this, this._active, this._eventPosition); if (!n) return; const o = this._size = rg(this, e), a = Object.assign({}, n, this._size), s = og(t, e, a), l = ag(e, a, s, t); r._to === l.x && i._to === l.y || (this.xAlign = s.xAlign, this.yAlign = s.yAlign, this.width = o.width, this.height = o.height, this.caretX = n.x, this.caretY = n.y, this._resolveAnimations().update(this, l)) } } _willRender() { return !!this.opacity } draw(e) { const t = this.options.setContext(this.getContext()); let n = this.opacity; if (!n) return; this._updateAnimationTarget(t); const r = { width: this.width, height: this.height }, i = { x: this.x, y: this.y }; n = Math.abs(n) < .001 ? 0 : n; const o = Bu(t.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length; t.enabled && a && (e.save(), e.globalAlpha = n, this.drawBackground(i, e, r, t), Od(e, t.textDirection), i.y += o.top, this.drawTitle(i, e, t), this.drawBody(i, e, t), this.drawFooter(i, e, t), Pd(e, t.textDirection), e.restore()) } getActiveElements() { return this._active || [] } setActiveElements(e, t) { const n = this._active, r = e.map((e => { let { datasetIndex: t, index: n } = e; const r = this.chart.getDatasetMeta(t); if (!r) throw new Error("Cannot find a dataset at index " + t); return { datasetIndex: t, element: r.data[n], index: n } })), i = !ic(n, r), o = this._positionChanged(r, t); (i || o) && (this._active = r, this._eventPosition = t, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(e, t) { let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]; if (t && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const r = this.options, i = this._active || [], o = this._getActiveElements(e, i, t, n), a = this._positionChanged(o, e), s = t || !ic(o, i) || a; return s && (this._active = o, (r.enabled || r.external) && (this._eventPosition = { x: e.x, y: e.y }, this.update(!0, t))), s } _getActiveElements(e, t, n, r) { const i = this.options; if ("mouseout" === e.type) return []; if (!r) return t.filter((e => this.chart.data.datasets[e.datasetIndex] && void 0 !== this.chart.getDatasetMeta(e.datasetIndex).controller.getParsed(e.index))); const o = this.chart.getElementsAtEventForMode(e, i.mode, i, n); return i.reverse && o.reverse(), o } _positionChanged(e, t) { const { caretX: n, caretY: r, options: i } = this, o = Zp[i.position].call(this, e, t); return !1 !== o && (n !== o.x || r !== o.y) } } fl(hg, "positioners", Zp); var fg = { id: "tooltip", _element: hg, positioners: Zp, afterInit(e, t, n) { n && (e.tooltip = new hg({ chart: e, options: n })) }, beforeUpdate(e, t, n) { e.tooltip && e.tooltip.initialize(n) }, reset(e, t, n) { e.tooltip && e.tooltip.initialize(n) }, afterDraw(e) { const t = e.tooltip; if (t && t._willRender()) { const n = { tooltip: t }; if (!1 === e.notifyPlugins("beforeTooltipDraw", { ...n, cancelable: !0 })) return; t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", n) } }, afterEvent(e, t) { if (e.tooltip) { const n = t.replay; e.tooltip.handleEvent(t.event, n, t.inChartArea) && (t.changed = !0) } }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (e, t) => t.bodyFont.size, boxWidth: (e, t) => t.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: ug }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: e => "filter" !== e && "itemSort" !== e && "external" !== e, _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }, pg = Object.freeze({ __proto__: null, Colors: Sp, Decimation: Mp, Filler: Up, Legend: Kp, SubTitle: Jp, Title: Xp, Tooltip: fg }); function gg(e, t, n, r) { const i = e.indexOf(t); if (-1 === i) return ((e, t, n, r) => ("string" === typeof t ? (n = e.push(t) - 1, r.unshift({ index: n, label: t })) : isNaN(t) && (n = null), n))(e, t, n, r); return i !== e.lastIndexOf(t) ? n : i } function mg(e) { const t = this.getLabels(); return e >= 0 && e < t.length ? t[e] : e } class bg extends gf { constructor(e) { super(e), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(e) { const t = this._addedLabels; if (t.length) { const e = this.getLabels(); for (const { index: n, label: r } of t) e[n] === r && e.splice(n, 1); this._addedLabels = [] } super.init(e) } parse(e, t) { if (Ql(e)) return null; const n = this.getLabels(); return ((e, t) => null === e ? null : Fc(Math.round(e), 0, t))(t = isFinite(t) && n[t] === e ? t : gg(n, e, ec(t, e), this._addedLabels), n.length - 1) } determineDataLimits() { const { minDefined: e, maxDefined: t } = this.getUserBounds(); let { min: n, max: r } = this.getMinMax(!0); "ticks" === this.options.bounds && (e || (n = 0), t || (r = this.getLabels().length - 1)), this.min = n, this.max = r } buildTicks() { const e = this.min, t = this.max, n = this.options.offset, r = []; let i = this.getLabels(); i = 0 === e && t === i.length - 1 ? i : i.slice(e, t + 1), this._valueRange = Math.max(i.length - (n ? 0 : 1), 1), this._startValue = this.min - (n ? .5 : 0); for (let o = e; o <= t; o++)r.push({ value: o }); return r } getLabelForValue(e) { return mg.call(this, e) } configure() { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(e) { return "number" !== typeof e && (e = this.parse(e)), null === e ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getPixelForTick(e) { const t = this.ticks; return e < 0 || e > t.length - 1 ? null : this.getPixelForValue(t[e].value) } getValueForPixel(e) { return Math.round(this._startValue + this.getDecimalForPixel(e) * this._valueRange) } getBasePixel() { return this.bottom } } function vg(e, t) { const n = [], { bounds: r, step: i, min: o, max: a, precision: s, count: l, maxTicks: c, maxDigits: u, includeBounds: d } = e, h = i || 1, f = c - 1, { min: p, max: g } = t, m = !Ql(o), b = !Ql(a), v = !Ql(l), y = (g - p) / (u + 1); let x, w, _, k, S = Oc((g - p) / f / h) * h; if (S < 1e-14 && !m && !b) return [{ value: p }, { value: g }]; k = Math.ceil(g / S) - Math.floor(p / S), k > f && (S = Oc(k * S / f / h) * h), Ql(s) || (x = Math.pow(10, s), S = Math.ceil(S * x) / x), "ticks" === r ? (w = Math.floor(p / S) * S, _ = Math.ceil(g / S) * S) : (w = p, _ = g), m && b && i && function (e, t) { const n = Math.round(e); return n - t <= e && n + t >= e }((a - o) / i, S / 1e3) ? (k = Math.round(Math.min((a - o) / S, c)), S = (a - o) / k, w = o, _ = a) : v ? (w = m ? o : w, _ = b ? a : _, k = l - 1, S = (_ - w) / k) : (k = (_ - w) / S, k = Mc(k, Math.round(k), S / 1e3) ? Math.round(k) : Math.ceil(k)); const C = Math.max(Dc(S), Dc(w)); x = Math.pow(10, Ql(s) ? C : s), w = Math.round(w * x) / x, _ = Math.round(_ * x) / x; let E = 0; for (m && (d && w !== o ? (n.push({ value: o }), w < o && E++, Mc(Math.round((w + E * S) * x) / x, o, yg(o, y, e)) && E++) : w < o && E++); E < k; ++E) { const e = Math.round((w + E * S) * x) / x; if (b && e > a) break; n.push({ value: e }) } return b && d && _ !== a ? n.length && Mc(n[n.length - 1].value, a, yg(a, y, e)) ? n[n.length - 1].value = a : n.push({ value: a }) : b && _ !== a || n.push({ value: _ }), n } function yg(e, t, n) { let { horizontal: r, minRotation: i } = n; const o = Tc(i), a = (r ? Math.sin(o) : Math.cos(o)) || .001, s = .75 * t * ("" + e).length; return Math.min(t / a, s) } fl(bg, "id", "category"), fl(bg, "defaults", { ticks: { callback: mg } }); class xg extends gf { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(e, t) { return Ql(e) || ("number" === typeof e || e instanceof Number) && !isFinite(+e) ? null : +e } handleTickRangeOptions() { const { beginAtZero: e } = this.options, { minDefined: t, maxDefined: n } = this.getUserBounds(); let { min: r, max: i } = this; const o = e => r = t ? r : e, a = e => i = n ? i : e; if (e) { const e = Ec(r), t = Ec(i); e < 0 && t < 0 ? a(0) : e > 0 && t > 0 && o(0) } if (r === i) { let t = 0 === i ? 1 : Math.abs(.05 * i); a(i + t), e || o(r - t) } this.min = r, this.max = i } getTickLimit() { const e = this.options.ticks; let t, { maxTicksLimit: n, stepSize: r } = e; return r ? (t = Math.ceil(this.max / r) - Math.floor(this.min / r) + 1, t > 1e3 && (console.warn("scales.".concat(this.id, ".ticks.stepSize: ").concat(r, " would result generating up to ").concat(t, " ticks. Limiting to 1000.")), t = 1e3)) : (t = this.computeTickLimit(), n = n || 11), n && (t = Math.min(n, t)), t } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const e = this.options, t = e.ticks; let n = this.getTickLimit(); n = Math.max(2, n); const r = vg({ maxTicks: n, bounds: e.bounds, min: e.min, max: e.max, precision: t.precision, step: t.stepSize, count: t.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: t.minRotation || 0, includeBounds: !1 !== t.includeBounds }, this._range || this); return "ticks" === e.bounds && Nc(r, this, "value"), e.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r } configure() { const e = this.ticks; let t = this.min, n = this.max; if (super.configure(), this.options.offset && e.length) { const r = (n - t) / Math.max(e.length - 1, 1) / 2; t -= r, n += r } this._startValue = t, this._endValue = n, this._valueRange = n - t } getLabelForValue(e) { return cu(e, this.chart.options.locale, this.options.ticks.format) } } class wg extends xg { determineDataLimits() { const { min: e, max: t } = this.getMinMax(!0); this.min = Jl(e) ? e : 0, this.max = Jl(t) ? t : 1, this.handleTickRangeOptions() } computeTickLimit() { const e = this.isHorizontal(), t = e ? this.width : this.height, n = Tc(this.options.ticks.minRotation), r = (e ? Math.sin(n) : Math.cos(n)) || .001, i = this._resolveTickFontOptions(0); return Math.ceil(t / Math.min(40, i.lineHeight / r)) } getPixelForValue(e) { return null === e ? NaN : this.getPixelForDecimal((e - this._startValue) / this._valueRange) } getValueForPixel(e) { return this._startValue + this.getDecimalForPixel(e) * this._valueRange } } fl(wg, "id", "linear"), fl(wg, "defaults", { ticks: { callback: du.formatters.numeric } }); const _g = e => Math.floor(Cc(e)), kg = (e, t) => Math.pow(10, _g(e) + t); function Sg(e) { return 1 === e / Math.pow(10, _g(e)) } function Cg(e, t, n) { const r = Math.pow(10, n), i = Math.floor(e / r); return Math.ceil(t / r) - i } function Eg(e, t) { let { min: n, max: r } = t; n = Zl(e.min, n); const i = [], o = _g(n); let a = function (e, t) { let n = _g(t - e); for (; Cg(e, t, n) > 10;)n++; for (; Cg(e, t, n) < 10;)n--; return Math.min(n, _g(e)) }(n, r), s = a < 0 ? Math.pow(10, Math.abs(a)) : 1; const l = Math.pow(10, a), c = o > a ? Math.pow(10, o) : 0, u = Math.round((n - c) * s) / s, d = Math.floor((n - c) / l / 10) * l * 10; let h = Math.floor((u - d) / Math.pow(10, a)), f = Zl(e.min, Math.round((c + d + h * Math.pow(10, a)) * s) / s); for (; f < r;)i.push({ value: f, major: Sg(f), significand: h }), h >= 10 ? h = h < 15 ? 15 : 20 : h++, h >= 20 && (a++, h = 2, s = a >= 0 ? 1 : s), f = Math.round((c + d + h * Math.pow(10, a)) * s) / s; const p = Zl(e.max, f); return i.push({ value: p, major: Sg(p), significand: h }), i } class Mg extends gf { constructor(e) { super(e), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(e, t) { const n = xg.prototype.parse.apply(this, [e, t]); if (0 !== n) return Jl(n) && n > 0 ? n : null; this._zero = !0 } determineDataLimits() { const { min: e, max: t } = this.getMinMax(!0); this.min = Jl(e) ? Math.max(0, e) : null, this.max = Jl(t) ? Math.max(0, t) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Jl(this._userMin) && (this.min = e === kg(this.min, 0) ? kg(this.min, -1) : kg(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: e, maxDefined: t } = this.getUserBounds(); let n = this.min, r = this.max; const i = t => n = e ? n : t, o = e => r = t ? r : e; n === r && (n <= 0 ? (i(1), o(10)) : (i(kg(n, -1)), o(kg(r, 1)))), n <= 0 && i(kg(r, -1)), r <= 0 && o(kg(n, 1)), this.min = n, this.max = r } buildTicks() { const e = this.options, t = Eg({ min: this._userMin, max: this._userMax }, this); return "ticks" === e.bounds && Nc(t, this, "value"), e.reverse ? (t.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), t } getLabelForValue(e) { return void 0 === e ? "0" : cu(e, this.chart.options.locale, this.options.ticks.format) } configure() { const e = this.min; super.configure(), this._startValue = Cc(e), this._valueRange = Cc(this.max) - Cc(e) } getPixelForValue(e) { return void 0 !== e && 0 !== e || (e = this.min), null === e || isNaN(e) ? NaN : this.getPixelForDecimal(e === this.min ? 0 : (Cc(e) - this._startValue) / this._valueRange) } getValueForPixel(e) { const t = this.getDecimalForPixel(e); return Math.pow(10, this._startValue + t * this._valueRange) } } function Og(e) { const t = e.ticks; if (t.display && e.display) { const e = Bu(t.backdropPadding); return ec(t.font && t.font.size, bu.font.size) + e.height } return 0 } function Pg(e, t, n, r, i) { return e === r || e === i ? { start: t - n / 2, end: t + n / 2 } : e < r || e > i ? { start: t - n, end: t } : { start: t, end: t + n } } function Ng(e) { const t = { l: e.left + e._padding.left, r: e.right - e._padding.right, t: e.top + e._padding.top, b: e.bottom - e._padding.bottom }, n = Object.assign({}, t), r = [], i = [], o = e._pointLabels.length, a = e.options.pointLabels, s = a.centerPointLabels ? bc / o : 0; for (let d = 0; d < o; d++) { const o = a.setContext(e.getPointLabelContext(d)); i[d] = o.padding; const h = e.getPointPosition(d, e.drawingArea + i[d], s), f = Wu(o.font), p = (l = e.ctx, c = f, u = Xl(u = e._pointLabels[d]) ? u : [u], { w: yu(l, c.string, u), h: u.length * c.lineHeight }); r[d] = p; const g = zc(e.getIndexAngle(d) + s), m = Math.round(jc(g)); Tg(n, t, g, Pg(m, h.x, p.w, 0, 180), Pg(m, h.y, p.h, 90, 270)) } var l, c, u; e.setCenterPoint(t.l - n.l, n.r - t.r, t.t - n.t, n.b - t.b), e._pointLabelItems = function (e, t, n) { const r = [], i = e._pointLabels.length, o = e.options, { centerPointLabels: a, display: s } = o.pointLabels, l = { extra: Og(o) / 2, additionalAngle: a ? bc / i : 0 }; let c; for (let u = 0; u < i; u++) { l.padding = n[u], l.size = t[u]; const i = jg(e, u, l); r.push(i), "auto" === s && (i.visible = Dg(i, c), i.visible && (c = i)) } return r }(e, r, i) } function Tg(e, t, n, r, i) { const o = Math.abs(Math.sin(n)), a = Math.abs(Math.cos(n)); let s = 0, l = 0; r.start < t.l ? (s = (t.l - r.start) / o, e.l = Math.min(e.l, t.l - s)) : r.end > t.r && (s = (r.end - t.r) / o, e.r = Math.max(e.r, t.r + s)), i.start < t.t ? (l = (t.t - i.start) / a, e.t = Math.min(e.t, t.t - l)) : i.end > t.b && (l = (i.end - t.b) / a, e.b = Math.max(e.b, t.b + l)) } function jg(e, t, n) { const r = e.drawingArea, { extra: i, additionalAngle: o, padding: a, size: s } = n, l = e.getPointPosition(t, r + i + a, o), c = Math.round(jc(zc(l.angle + _c))), u = function (e, t, n) { 90 === n || 270 === n ? e -= t / 2 : (n > 270 || n < 90) && (e -= t); return e }(l.y, s.h, c), d = function (e) { if (0 === e || 180 === e) return "center"; if (e < 180) return "left"; return "right" }(c), h = function (e, t, n) { "right" === n ? e -= t : "center" === n && (e -= t / 2); return e }(l.x, s.w, d); return { visible: !0, x: l.x, y: u, textAlign: d, left: h, top: u, right: h + s.w, bottom: u + s.h } } function Dg(e, t) { if (!t) return !0; const { left: n, top: r, right: i, bottom: o } = e; return !(Su({ x: n, y: r }, t) || Su({ x: n, y: o }, t) || Su({ x: i, y: r }, t) || Su({ x: i, y: o }, t)) } function Rg(e, t, n) { const { left: r, top: i, right: o, bottom: a } = n, { backdropColor: s } = t; if (!Ql(s)) { const n = Fu(t.borderRadius), l = Bu(t.backdropPadding); e.fillStyle = s; const c = r - l.left, u = i - l.top, d = o - r + l.width, h = a - i + l.height; Object.values(n).some((e => 0 !== e)) ? (e.beginPath(), ju(e, { x: c, y: u, w: d, h: h, radius: n }), e.fill()) : e.fillRect(c, u, d, h) } } function Lg(e, t, n, r) { const { ctx: i } = e; if (n) i.arc(e.xCenter, e.yCenter, t, 0, vc); else { let n = e.getPointPosition(0, t); i.moveTo(n.x, n.y); for (let o = 1; o < r; o++)n = e.getPointPosition(o, t), i.lineTo(n.x, n.y) } } fl(Mg, "id", "logarithmic"), fl(Mg, "defaults", { ticks: { callback: du.formatters.logarithmic, major: { enabled: !0 } } }); class Ag extends xg { constructor(e) { super(e), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const e = this._padding = Bu(Og(this.options) / 2), t = this.width = this.maxWidth - e.width, n = this.height = this.maxHeight - e.height; this.xCenter = Math.floor(this.left + t / 2 + e.left), this.yCenter = Math.floor(this.top + n / 2 + e.top), this.drawingArea = Math.floor(Math.min(t, n) / 2) } determineDataLimits() { const { min: e, max: t } = this.getMinMax(!1); this.min = Jl(e) && !isNaN(e) ? e : 0, this.max = Jl(t) && !isNaN(t) ? t : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / Og(this.options)) } generateTickLabels(e) { xg.prototype.generateTickLabels.call(this, e), this._pointLabels = this.getLabels().map(((e, t) => { const n = nc(this.options.pointLabels.callback, [e, t], this); return n || 0 === n ? n : "" })).filter(((e, t) => this.chart.getDataVisibility(t))) } fit() { const e = this.options; e.display && e.pointLabels.display ? Ng(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(e, t, n, r) { this.xCenter += Math.floor((e - t) / 2), this.yCenter += Math.floor((n - r) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(e, t, n, r)) } getIndexAngle(e) { return zc(e * (vc / (this._pointLabels.length || 1)) + Tc(this.options.startAngle || 0)) } getDistanceFromCenterForValue(e) { if (Ql(e)) return NaN; const t = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - e) * t : (e - this.min) * t } getValueForDistanceFromCenter(e) { if (Ql(e)) return NaN; const t = e / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - t : this.min + t } getPointLabelContext(e) { const t = this._pointLabels || []; if (e >= 0 && e < t.length) { const n = t[e]; return function (e, t, n) { return Hu(e, { label: n, index: t, type: "pointLabel" }) }(this.getContext(), e, n) } } getPointPosition(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0; const r = this.getIndexAngle(e) - _c + n; return { x: Math.cos(r) * t + this.xCenter, y: Math.sin(r) * t + this.yCenter, angle: r } } getPointPositionForValue(e, t) { return this.getPointPosition(e, this.getDistanceFromCenterForValue(t)) } getBasePosition(e) { return this.getPointPositionForValue(e || 0, this.getBaseValue()) } getPointLabelPosition(e) { const { left: t, top: n, right: r, bottom: i } = this._pointLabelItems[e]; return { left: t, top: n, right: r, bottom: i } } drawBackground() { const { backgroundColor: e, grid: { circular: t } } = this.options; if (e) { const n = this.ctx; n.save(), n.beginPath(), Lg(this, this.getDistanceFromCenterForValue(this._endValue), t, this._pointLabels.length), n.closePath(), n.fillStyle = e, n.fill(), n.restore() } } drawGrid() { const e = this.ctx, t = this.options, { angleLines: n, grid: r, border: i } = t, o = this._pointLabels.length; let a, s, l; if (t.pointLabels.display && function (e, t) { const { ctx: n, options: { pointLabels: r } } = e; for (let i = t - 1; i >= 0; i--) { const t = e._pointLabelItems[i]; if (!t.visible) continue; const o = r.setContext(e.getPointLabelContext(i)); Rg(n, o, t); const a = Wu(o.font), { x: s, y: l, textAlign: c } = t; Tu(n, e._pointLabels[i], s, l + a.lineHeight / 2, a, { color: o.color, textAlign: c, textBaseline: "middle" }) } }(this, o), r.display && this.ticks.forEach(((e, t) => { if (0 !== t) { s = this.getDistanceFromCenterForValue(e.value); const n = this.getContext(t), a = r.setContext(n), l = i.setContext(n); !function (e, t, n, r, i) { const o = e.ctx, a = t.circular, { color: s, lineWidth: l } = t; !a && !r || !s || !l || n < 0 || (o.save(), o.strokeStyle = s, o.lineWidth = l, o.setLineDash(i.dash), o.lineDashOffset = i.dashOffset, o.beginPath(), Lg(e, n, a, r), o.closePath(), o.stroke(), o.restore()) }(this, a, s, o, l) } })), n.display) { for (e.save(), a = o - 1; a >= 0; a--) { const r = n.setContext(this.getPointLabelContext(a)), { color: i, lineWidth: o } = r; o && i && (e.lineWidth = o, e.strokeStyle = i, e.setLineDash(r.borderDash), e.lineDashOffset = r.borderDashOffset, s = this.getDistanceFromCenterForValue(t.ticks.reverse ? this.min : this.max), l = this.getPointPosition(a, s), e.beginPath(), e.moveTo(this.xCenter, this.yCenter), e.lineTo(l.x, l.y), e.stroke()) } e.restore() } } drawBorder() { } drawLabels() { const e = this.ctx, t = this.options, n = t.ticks; if (!n.display) return; const r = this.getIndexAngle(0); let i, o; e.save(), e.translate(this.xCenter, this.yCenter), e.rotate(r), e.textAlign = "center", e.textBaseline = "middle", this.ticks.forEach(((r, a) => { if (0 === a && !t.reverse) return; const s = n.setContext(this.getContext(a)), l = Wu(s.font); if (i = this.getDistanceFromCenterForValue(this.ticks[a].value), s.showLabelBackdrop) { e.font = l.string, o = e.measureText(r.label).width, e.fillStyle = s.backdropColor; const t = Bu(s.backdropPadding); e.fillRect(-o / 2 - t.left, -i - l.size / 2 - t.top, o + t.width, l.size + t.height) } Tu(e, r.label, 0, -i, l, { color: s.color, strokeColor: s.textStrokeColor, strokeWidth: s.textStrokeWidth }) })), e.restore() } drawTitle() { } } fl(Ag, "id", "radialLinear"), fl(Ag, "defaults", { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: du.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback: e => e, padding: 5, centerPointLabels: !1 } }), fl(Ag, "defaultRoutes", { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }), fl(Ag, "descriptors", { angleLines: { _fallback: "grid" } }); const zg = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, Ig = Object.keys(zg); function Fg(e, t) { return e - t } function Bg(e, t) { if (Ql(t)) return null; const n = e._adapter, { parser: r, round: i, isoWeekday: o } = e._parseOpts; let a = t; return "function" === typeof r && (a = r(a)), Jl(a) || (a = "string" === typeof r ? n.parse(a, r) : n.parse(a)), null === a ? null : (i && (a = "week" !== i || !Pc(o) && !0 !== o ? n.startOf(a, i) : n.startOf(a, "isoWeek", o)), +a) } function Wg(e, t, n, r) { const i = Ig.length; for (let o = Ig.indexOf(e); o < i - 1; ++o) { const e = zg[Ig[o]], i = e.steps ? e.steps : Number.MAX_SAFE_INTEGER; if (e.common && Math.ceil((n - t) / (i * e.size)) <= r) return Ig[o] } return Ig[i - 1] } function Vg(e, t, n) { if (n) { if (n.length) { const { lo: r, hi: i } = Wc(n, t); e[n[r] >= t ? n[r] : n[i]] = !0 } } else e[t] = !0 } function Hg(e, t, n) { const r = [], i = {}, o = t.length; let a, s; for (a = 0; a < o; ++a)s = t[a], i[s] = a, r.push({ value: s, major: !1 }); return 0 !== o && n ? function (e, t, n, r) { const i = e._adapter, o = +i.startOf(t[0].value, r), a = t[t.length - 1].value; let s, l; for (s = o; s <= a; s = +i.add(s, 1, r))l = n[s], l >= 0 && (t[l].major = !0); return t }(e, r, i, n) : r } class Ug extends gf { constructor(e) { super(e), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; const n = e.time || (e.time = {}), r = this._adapter = new xh(e.adapters.date); r.init(t), cc(n.displayFormats, r.formats()), this._parseOpts = { parser: n.parser, round: n.round, isoWeekday: n.isoWeekday }, super.init(e), this._normalized = t.normalized } parse(e, t) { return void 0 === e ? null : Bg(this, e) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const e = this.options, t = this._adapter, n = e.time.unit || "day"; let { min: r, max: i, minDefined: o, maxDefined: a } = this.getUserBounds(); function s(e) { o || isNaN(e.min) || (r = Math.min(r, e.min)), a || isNaN(e.max) || (i = Math.max(i, e.max)) } o && a || (s(this._getLabelBounds()), "ticks" === e.bounds && "labels" === e.ticks.source || s(this.getMinMax(!1))), r = Jl(r) && !isNaN(r) ? r : +t.startOf(Date.now(), n), i = Jl(i) && !isNaN(i) ? i : +t.endOf(Date.now(), n) + 1, this.min = Math.min(r, i - 1), this.max = Math.max(r + 1, i) } _getLabelBounds() { const e = this.getLabelTimestamps(); let t = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY; return e.length && (t = e[0], n = e[e.length - 1]), { min: t, max: n } } buildTicks() { const e = this.options, t = e.time, n = e.ticks, r = "labels" === n.source ? this.getLabelTimestamps() : this._generate(); "ticks" === e.bounds && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]); const i = this.min, o = function (e, t, n) { let r = 0, i = e.length; for (; r < i && e[r] < t;)r++; for (; i > r && e[i - 1] > n;)i--; return r > 0 || i < e.length ? e.slice(r, i) : e }(r, i, this.max); return this._unit = t.unit || (n.autoSkip ? Wg(t.minUnit, this.min, this.max, this._getLabelCapacity(i)) : function (e, t, n, r, i) { for (let o = Ig.length - 1; o >= Ig.indexOf(n); o--) { const n = Ig[o]; if (zg[n].common && e._adapter.diff(i, r, n) >= t - 1) return n } return Ig[n ? Ig.indexOf(n) : 0] }(this, o.length, t.minUnit, this.min, this.max)), this._majorUnit = n.major.enabled && "year" !== this._unit ? function (e) { for (let t = Ig.indexOf(e) + 1, n = Ig.length; t < n; ++t)if (zg[Ig[t]].common) return Ig[t] }(this._unit) : void 0, this.initOffsets(r), e.reverse && o.reverse(), Hg(this, o, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((e => +e.value))) } initOffsets() { let e, t, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], r = 0, i = 0; this.options.offset && n.length && (e = this.getDecimalForValue(n[0]), r = 1 === n.length ? 1 - e : (this.getDecimalForValue(n[1]) - e) / 2, t = this.getDecimalForValue(n[n.length - 1]), i = 1 === n.length ? t : (t - this.getDecimalForValue(n[n.length - 2])) / 2); const o = n.length < 3 ? .5 : .25; r = Fc(r, 0, o), i = Fc(i, 0, o), this._offsets = { start: r, end: i, factor: 1 / (r + 1 + i) } } _generate() { const e = this._adapter, t = this.min, n = this.max, r = this.options, i = r.time, o = i.unit || Wg(i.minUnit, t, n, this._getLabelCapacity(t)), a = ec(r.ticks.stepSize, 1), s = "week" === o && i.isoWeekday, l = Pc(s) || !0 === s, c = {}; let u, d, h = t; if (l && (h = +e.startOf(h, "isoWeek", s)), h = +e.startOf(h, l ? "day" : o), e.diff(n, t, o) > 1e5 * a) throw new Error(t + " and " + n + " are too far apart with stepSize of " + a + " " + o); const f = "data" === r.ticks.source && this.getDataTimestamps(); for (u = h, d = 0; u < n; u = +e.add(u, a, o), d++)Vg(c, u, f); return u !== n && "ticks" !== r.bounds && 1 !== d || Vg(c, u, f), Object.keys(c).sort(Fg).map((e => +e)) } getLabelForValue(e) { const t = this._adapter, n = this.options.time; return n.tooltipFormat ? t.format(e, n.tooltipFormat) : t.format(e, n.displayFormats.datetime) } format(e, t) { const n = this.options.time.displayFormats, r = this._unit, i = t || n[r]; return this._adapter.format(e, i) } _tickFormatFunction(e, t, n, r) { const i = this.options, o = i.ticks.callback; if (o) return nc(o, [e, t, n], this); const a = i.time.displayFormats, s = this._unit, l = this._majorUnit, c = s && a[s], u = l && a[l], d = n[t], h = l && u && d && d.major; return this._adapter.format(e, r || (h ? u : c)) } generateTickLabels(e) { let t, n, r; for (t = 0, n = e.length; t < n; ++t)r = e[t], r.label = this._tickFormatFunction(r.value, t, e) } getDecimalForValue(e) { return null === e ? NaN : (e - this.min) / (this.max - this.min) } getPixelForValue(e) { const t = this._offsets, n = this.getDecimalForValue(e); return this.getPixelForDecimal((t.start + n) * t.factor) } getValueForPixel(e) { const t = this._offsets, n = this.getDecimalForPixel(e) / t.factor - t.end; return this.min + n * (this.max - this.min) } _getLabelSize(e) { const t = this.options.ticks, n = this.ctx.measureText(e).width, r = Tc(this.isHorizontal() ? t.maxRotation : t.minRotation), i = Math.cos(r), o = Math.sin(r), a = this._resolveTickFontOptions(0).size; return { w: n * i + a * o, h: n * o + a * i } } _getLabelCapacity(e) { const t = this.options.time, n = t.displayFormats, r = n[t.unit] || n.millisecond, i = this._tickFormatFunction(e, 0, Hg(this, [e], this._majorUnit), r), o = this._getLabelSize(i), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1; return a > 0 ? a : 1 } getDataTimestamps() { let e, t, n = this._cache.data || []; if (n.length) return n; const r = this.getMatchingVisibleMetas(); if (this._normalized && r.length) return this._cache.data = r[0].controller.getAllParsedValues(this); for (e = 0, t = r.length; e < t; ++e)n = n.concat(r[e].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(n) } getLabelTimestamps() { const e = this._cache.labels || []; let t, n; if (e.length) return e; const r = this.getLabels(); for (t = 0, n = r.length; t < n; ++t)e.push(Bg(this, r[t])); return this._cache.labels = this._normalized ? e : this.normalize(e) } normalize(e) { return Yc(e.sort(Fg)) } } function $g(e, t, n) { let r, i, o, a, s = 0, l = e.length - 1; n ? (t >= e[s].pos && t <= e[l].pos && ({ lo: s, hi: l } = Vc(e, "pos", t)), ({ pos: r, time: o } = e[s]), ({ pos: i, time: a } = e[l])) : (t >= e[s].time && t <= e[l].time && ({ lo: s, hi: l } = Vc(e, "time", t)), ({ time: r, pos: o } = e[s]), ({ time: i, pos: a } = e[l])); const c = i - r; return c ? o + (a - o) * (t - r) / c : o } fl(Ug, "id", "time"), fl(Ug, "defaults", { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }); class Yg extends Ug { constructor(e) { super(e), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const e = this._getTimestampsForTable(), t = this._table = this.buildLookupTable(e); this._minPos = $g(t, this.min), this._tableRange = $g(t, this.max) - this._minPos, super.initOffsets(e) } buildLookupTable(e) { const { min: t, max: n } = this, r = [], i = []; let o, a, s, l, c; for (o = 0, a = e.length; o < a; ++o)l = e[o], l >= t && l <= n && r.push(l); if (r.length < 2) return [{ time: t, pos: 0 }, { time: n, pos: 1 }]; for (o = 0, a = r.length; o < a; ++o)c = r[o + 1], s = r[o - 1], l = r[o], Math.round((c + s) / 2) !== l && i.push({ time: l, pos: o / (a - 1) }); return i } _generate() { const e = this.min, t = this.max; let n = super.getDataTimestamps(); return n.includes(e) && n.length || n.splice(0, 0, e), n.includes(t) && 1 !== n.length || n.push(t), n.sort(((e, t) => e - t)) } _getTimestampsForTable() { let e = this._cache.all || []; if (e.length) return e; const t = this.getDataTimestamps(), n = this.getLabelTimestamps(); return e = t.length && n.length ? this.normalize(t.concat(n)) : t.length ? t : n, e = this._cache.all = e, e } getDecimalForValue(e) { return ($g(this._table, e) - this._minPos) / this._tableRange } getValueForPixel(e) { const t = this._offsets, n = this.getDecimalForPixel(e) / t.factor - t.end; return $g(this._table, n * this._tableRange + this._minPos, !0) } } fl(Yg, "id", "timeseries"), fl(Yg, "defaults", Ug.defaults); const qg = [bh, bp, pg, Object.freeze({ __proto__: null, CategoryScale: bg, LinearScale: wg, LogarithmicScale: Mg, RadialLinearScale: Ag, TimeScale: Ug, TimeSeriesScale: Yg })], Kg = "label"; function Qg(e, t) { "function" === typeof e ? e(t) : e && (e.current = t) } function Xg(e, t) { e.labels = t } function Gg(e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Kg; const r = []; e.datasets = t.map((t => { const i = e.datasets.find((e => e[n] === t[n])); return i && t.data && !r.includes(i) ? (r.push(i), Object.assign(i, t), i) : { ...t } })) } function Jg(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Kg; const n = { labels: [], datasets: [] }; return Xg(n, e.labels), Gg(n, e.datasets, t), n } function Zg(t, n) { const { height: r = 150, width: i = 300, redraw: o = !1, datasetIdKey: a, type: s, data: l, options: c, plugins: u = [], fallbackContent: d, updateMode: h, ...f } = t, p = (0, e.useRef)(null), g = (0, e.useRef)(), m = () => { p.current && (g.current = new Yf(p.current, { type: s, data: Jg(l, a), options: c && { ...c }, plugins: u }), Qg(n, g.current)) }, b = () => { Qg(n, null), g.current && (g.current.destroy(), g.current = null) }; return (0, e.useEffect)((() => { !o && g.current && c && function (e, t) { const n = e.options; n && t && Object.assign(n, t) }(g.current, c) }), [o, c]), (0, e.useEffect)((() => { !o && g.current && Xg(g.current.config.data, l.labels) }), [o, l.labels]), (0, e.useEffect)((() => { !o && g.current && l.datasets && Gg(g.current.config.data, l.datasets, a) }), [o, l.datasets]), (0, e.useEffect)((() => { g.current && (o ? (b(), setTimeout(m)) : g.current.update(h)) }), [o, c, l.labels, l.datasets, h]), (0, e.useEffect)((() => { g.current && (b(), setTimeout(m)) }), [s]), (0, e.useEffect)((() => (m(), () => b())), []), e.createElement("canvas", Object.assign({ ref: p, role: "img", height: r, width: i }, f), d) } const em = (0, e.forwardRef)(Zg); function tm(t, n) { return Yf.register(n), (0, e.forwardRef)(((n, r) => e.createElement(em, Object.assign({}, n, { ref: r, type: t })))) } const nm = tm("bar", ch), rm = ["#CC0000B3", "#CC1E00B3", "#CC3E00B3", "#CC5C00B3", "#CC7A00B3", "#CC9900B3", "#CCB700B3", "#C2CC00B3", "#A3CC00B3", "#85CC00B3", "#66CC00B3", "#47CC00B3", "#29CC00B3", "#0ACC00B3", "#00CC14B3", "#00CC33B3", "#00CC52B3", "#00CC70B3", "#00CC8EB3", "#00CCAEB3", "#00CCCCB3", "#00AECCB3", "#008FCCB3", "#0070CCB3", "#0052CCB3", "#0033CCB3", "#0015CCB3", "#0A00CCB3", "#2900CCB3", "#4700CCB3", "#6600CCB3", "#8500CCB3", "#A300CCB3", "#C200CCB3", "#CC00B8B3", "#CC0099B3", "#CC007AB3", "#CC005CB3", "#CC003EB3", "#CC001EB3"], im = ["#CC000099", "#CC1E0099", "#CC3E0099", "#CC5C0099", "#CC7A0099", "#CC990099", "#CCB70099", "#C2CC0099", "#A3CC0099", "#85CC0099", "#66CC0099", "#47CC0099", "#29CC0099", "#0ACC0099", "#00CC1499", "#00CC3399", "#00CC5299", "#00CC7099", "#00CC8E99", "#00CCAE99", "#00CCCC99", "#00AECC99", "#008FCC99", "#0070CC99", "#0052CC99", "#0033CC99", "#0015CC99", "#0A00CC99", "#2900CC99", "#4700CC99", "#6600CC99", "#8500CC99", "#A300CC99", "#C200CC99", "#CC00B899", "#CC009999", "#CC007A99", "#CC005C99", "#CC003E99", "#CC001E99"]; Yf.register(...qg); const om = { "A+": "A_plus", "A-": "A_minus", "B+": "B_plus", "B-": "B_minus", "C+": "C_plus", "C-": "C_minus", "D+": "D_plus", "D-": "D_minus" }; let am = null; const sm = e => e.includes("Fall") ? "9" : e.includes("Spring") ? "2" : e.includes("Summer") ? "6" : "", lm = t => { let { data: n, selectedCourses: r, displayMode: i, aggregateMode: o, saveMode: s, setDisplayMode: l, setAggregateMode: c, windowSize: u, theme: d } = t; const h = 0 !== r.length, f = u[0], p = u[1]; (0, e.useEffect)((() => { const e = document.querySelector(".the-table-card"); document.querySelector(".the-graph-card").style.minHeight = "".concat(e.clientHeight, "px") }), [h, f, p, s]); const g = n.filter((e => r.includes(e.internal_id))), m = g.some((e => "LAW" === e.dept)) ? ["A+", "A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D+", "D", "D-", "F", "Other"] : ["A", "A-", "B+", "B", "B-", "C+", "C", "C-", "D+", "D", "D-", "F", "Other"], b = 1 === g.length, v = 14 === m.length, y = "light" === d ? "#212529" : "#dee2e6", x = "light" === d ? "rgba(33, 37, 41, 0.15)" : "rgba(222, 226, 230, 0.15)", w = { scales: { y: { beginAtZero: !0, title: { display: !0, text: "frequency" === i ? "Frequency" : "Percentage", color: y }, ticks: { color: y, callback: function (e) { return "frequency" === i ? e : "".concat(Math.round(e), "%") } }, grid: { color: x } }, x: { ticks: { color: y }, grid: { color: x } } }, plugins: { legend: { display: !1 }, tooltip: { callbacks: { label: function (e) { let t = e.dataset.label || ""; return t && (t += ": "), t += "frequency" === i ? e.parsed.y : "".concat(e.parsed.y.toFixed(1), "%"), t } } } }, aspectRatio: f < 576 ? 1.8 : f < 768 ? 2 : f < 992 ? 2.1 : 2.5, responsive: !0 }, _ = (() => { b && (am = g.find((e => e.internal_id === r[0]))); const e = rm.slice(0, v ? 15 : 14).reverse(), t = g.map(((t, n) => { const r = m.map((e => t[om.hasOwnProperty(e) ? om[e] : e] || 0)), a = r.reduce(((e, t) => e + t), 0); return { label: o || b ? "" : "".concat(t.dept.replace(" ", ""), " ").concat(t.course_nbr, " (").concat(t.course_name, ") w/ ").concat(ol(t.prof), ", ").concat(t.sem), data: "frequency" === i ? r : r.map((e => e / a * 100)), backgroundColor: o || b ? e : rm[Math.round(15 * n / (g.length - 1) + 0)], borderColor: "light" === d ? "black" : "white", borderWidth: .8, minBarLength: 2 } })); if (o) { const n = m.map(((e, n) => t.reduce(((e, t) => e + t.data[n]), 0))), r = n.reduce(((e, t) => e + t), 0); return { labels: m, datasets: [{ label: "", data: "frequency" === i ? n : n.map((e => e / r * 100)), backgroundColor: e, borderColor: "light" === d ? "black" : "white", borderWidth: .8 }] } } return { labels: m, datasets: t } })(); bu.font.family = "Josefin Slab"; const k = r.length < 2 || r.length >= 19; return (0, a.jsx)(Ea, { className: "shadow mb-2 results-cards the-graph-card", children: (0, a.jsxs)(Ea.Body, { className: "d-flex align-items-center justify-content-center", children: [h && (0, a.jsxs)("div", { style: { flexGrow: 1 }, children: [(0, a.jsx)("div", { children: (0, a.jsx)("p", { style: { lineHeight: "110%" }, className: "px-1", children: (() => { if (b) { const t = m.reduce(((e, t) => { const n = om.hasOwnProperty(t) ? om[t] : t; return e + (am[n] || 0) }), 0), n = m.map(((e, n) => { let r; if ("percentage" === i) { const n = am[om.hasOwnProperty(e) ? om[e] : e], i = t > 0 ? (n / t * 100).toFixed(1) : "0.0"; r = (0, a.jsxs)(a.Fragment, { children: [e, ": ", i, "%"] }) } else r = (0, a.jsxs)(a.Fragment, { children: [e, ": ", am[om.hasOwnProperty(e) ? om[e] : e]] }); const o = "C" === e ? (0, a.jsx)("br", {}) : (0, a.jsxs)(a.Fragment, { children: [" ", "|", " "] }); return (0, a.jsxs)("span", { children: [r, n !== m.length - 1 && o] }, n) })); return (0, a.jsxs)(a.Fragment, { children: [am.dept.replace(" ", ""), " ", am.course_nbr, " (", (0, a.jsx)("span", { style: { fontVariant: "small-caps" }, children: rl(am.course_name) }), ") w/ ", ol(am.prof), ", ", am.sem, ". ", (0, a.jsx)("a", { target: "_blank", rel: "noopener noreferrer", href: "https://utdirect.utexas.edu/apps/student/coursedocs/nlogon/?year=".concat((e = am.sem, e.split(" ")[1]), "&semester=").concat(sm(am.sem), "&department=").concat(am.dept.replace(" ", "+"), "&course_number=").concat(am.course_nbr, "&course_title=&unique=&instructor_first=&instructor_last=").concat(ol(am.prof).split(" ")[0], "&course_type=In+Residence&search=Search"), className: "emph-on-hover", children: (0, a.jsx)("em", { children: "Syllabus" }) }), f < 1200 ? (0, a.jsx)("br", {}) : "", (0, a.jsx)("br", {}), n] }) } var e; return h ? "Multiple Courses Selected." : "" })() }) }), (0, a.jsxs)("label", { className: "mx-2", children: [(0, a.jsx)("div", { style: { verticalAlign: "-0.1em", display: "inline" }, children: (0, a.jsx)(Ra, { onChange: () => l("frequency" === i ? "percentage" : "frequency"), checked: "percentage" === i, height: 12, width: 30, handleDiameter: 8, uncheckedIcon: !1, checkedIcon: !1 }) }), (0, a.jsx)("span", { className: "mx-2", children: "Percentage" })] }), s && (0, a.jsxs)("label", { className: "mx-2", children: [(0, a.jsx)("div", { style: { verticalAlign: "-0.1em", display: "inline" }, children: (0, a.jsx)(Ra, { onChange: () => c(!o), checked: o, height: 12, width: 30, handleDiameter: 8, uncheckedIcon: !1, checkedIcon: !1, disabled: k }) }), (0, a.jsx)("span", { className: "ms-2 ".concat(k ? "toggle-label-disabled" : ""), children: "Aggregate" })] }), (0, a.jsx)("div", { style: { display: "block" }, children: (0, a.jsx)(nm, { data: _, options: w, className: "graph-nonempty-content" }, f) })] }), !h && (0, a.jsx)(a.Fragment, { children: (0, a.jsx)("span", { className: "my-auto", style: { fontWeight: "bold" }, children: "Select a course!" }) })] }) }) }; var cm = ["color", "size", "title"]; function um() { return um = Object.assign || function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, um.apply(this, arguments) } function dm(e, t) { if (null == e) return {}; var n, r, i = function (e, t) { if (null == e) return {}; var n, r, i = {}, o = Object.keys(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]); return i }(e, t); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (r = 0; r < o.length; r++)n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n]) } return i } var hm = (0, e.forwardRef)((function (t, n) { var r = t.color, i = t.size, o = t.title, a = dm(t, cm); return e.createElement("svg", um({ ref: n, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16", width: i, height: i, fill: r }, a), o ? e.createElement("title", null, o) : null, e.createElement("path", { d: "M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z" })) })); hm.propTypes = { color: y().string, size: y().oneOfType([y().string, y().number]), title: y().string }, hm.defaultProps = { color: "currentColor", size: "1em", title: null }; const fm = hm, pm = e => { let { data: t, selectedCourses: n, removeCourse: r, windowSize: i, aggregateMode: o } = e; const s = e => ["A", "A_minus", "A_plus", "B", "B_minus", "B_plus", "C", "C_minus", "C_plus", "D", "D_minus", "D_plus", "F", "Other"].reduce(((t, n) => t + e[n]), 0), l = () => t, c = e => { const t = e.split(" "); return "Fall" === t[0] ? t[0] = "Fall" : "Spring" === t[0] ? t[0] = "Spr" : "Summer" === t[0] && (t[0] = "Sum"), t.join(" ") }, u = (e, t) => t % 2 !== 0 ? e % 2 === 0 ? "savecard-cell-reg" : "savecard-cell-striped" : ((e % 2 === 0 ? 0 : 1) + (Math.floor(e / t) % 2 === 0 ? 0 : 1)) % 2 === 0 ? "savecard-cell-reg" : "savecard-cell-striped"; return (0, a.jsx)(Ea, { className: "shadow", children: (0, a.jsxs)(Ea.Body, { children: [(0, a.jsxs)("div", { className: "mb-1", children: [(0, a.jsx)("span", { className: "mx-2", style: { float: "left", fontWeight: "bold" }, children: "In Graph:" }), (0, a.jsx)("span", { className: "mx-2 emph-on-hover", style: { float: "right" }, onClick: () => l().forEach((e => { r(e.internal_id) })), children: (0, a.jsx)("u", { children: "Remove All" }) })] }), (0, a.jsx)(b, { fluid: !0, className: "table-grid", style: { height: "30vh", overflowY: "auto" }, children: (0, a.jsx)(ia, { children: (() => { const e = [], t = (() => { const e = i[0]; return e < 576 ? 1 : e < 768 ? 2 : e < 992 ? 3 : e < 1400 ? 4 : 6 })(), d = l().filter((e => n.includes(e.internal_id))); return d.forEach(((n, i) => { e.push((0, a.jsxs)(F, { sm: 6, md: 4, lg: 3, xxl: 2, className: "d-flex align-items-center savecard-cell ".concat(u(i, t)), style: { padding: "0.6em 0.75rem 0.5rem", backgroundColor: o || 1 === d.length ? "" : "".concat(im[Math.round(15 * i / (d.length - 1) + 0)]) }, children: [(0, a.jsx)(yi, { placement: "bottom", overlay: (0, a.jsx)(gi, { children: (0, a.jsx)("span", { style: { fontVariant: "small-caps" }, children: rl(n.course_name) }) }), children: (0, a.jsxs)("div", { style: { flex: 1, textAlign: "left", paddingRight: "0.75rem", lineHeight: "100%" }, children: [(0, a.jsxs)("span", { className: "fw-bold", children: [n.dept, "\xa0", n.course_nbr] }), " w/\xa0", (0, a.jsx)("span", { className: "text-capitalize", children: ol(n.prof) }), (0, a.jsx)("br", {}), (0, a.jsxs)("span", { children: [c(n.sem).replace(/ /g, "\xa0"), " - ", s(n), (0, a.jsx)(Fa, { style: { verticalAlign: "-0.186em" } })] })] }) }, "bottom"), (0, a.jsx)(fm, { onClick: () => r(n.internal_id), style: { cursor: "pointer" } })] }, i)) })), e })() }) })] }) }) }, gm = t => { let { data: n, theme: r, searchQuery: i, persistedCourseData: o, setPersistedCourseData: s, setPersistedCourseList: l } = t; const [c, u] = cl([], "courses", (e => e.join(",")), (e => e.split(",").map((e => parseInt(e))).filter((e => !Number.isNaN(e))))), [d, h] = cl("frequency", "disp", (e => e.toString()), (e => "percentage" === e ? "percentage" : "frequency")), [f, p] = cl(!1, "agg", (e => e ? "true" : "false"), (e => "true" === e)), [g, m] = cl(!1, "multi", (e => e ? "true" : "false"), (e => "true" === e)); (0, e.useEffect)((() => { i && "" !== i && (g || (u([]), l([])), g && l(c)) }), [i]); const b = e => { u((t => { const n = t.filter((t => t !== e)); return v(t, n), n })), s((t => t.filter((t => t.internal_id !== e)))) }, v = (e, t) => { 1 === t.length && p(!1), e.length <= 5 && t.length >= 6 && p(!0), e.length <= 18 && t.length >= 19 && p(!0), e.length < 2 && t.length >= 2 && h("percentage"), e.length >= 2 && t.length < 2 && h("frequency") }; const y = function (e, t) { let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : (e, t) => e === t; const r = [...e]; return t.forEach((e => r.some((t => n(e, t))) ? null : r.push(e))), r }(o, n, ((e, t) => e.internal_id === t.internal_id)), x = function () { const [t, n] = (0, e.useState)([0, 0]); return (0, e.useLayoutEffect)((() => { function e() { n([window.innerWidth, window.innerHeight]) } return window.addEventListener("resize", e), e(), () => window.removeEventListener("resize", e) }), []), t }(); return (0, a.jsxs)(ia, { className: "mt-4", children: [(0, a.jsx)(F, { md: 5, lg: 4, xl: 3, className: "".concat(x[0] < 768 ? "" : "pe-0"), children: (0, a.jsx)(ul, { data: n, selectedCourses: c, toggleCourseSelection: e => { g ? (u((t => { const n = t.includes(e) ? t.filter((t => t !== e)) : [...t, e]; return v(t, n), n })), s((t => t.some((t => t.internal_id === e)) ? t.filter((t => t.internal_id !== e)) : [...t, n.find((t => t.internal_id === e))]))) : (u((t => { const n = [e]; return v(t, n), n })), s((() => [n.find((t => t.internal_id === e))]))) }, addCourse: e => { u((t => { const n = t.includes(e) ? t : [...t, e]; return v(t, n), n })), s((t => t.some((t => t.internal_id === e)) ? t : [...t, n.find((t => t.internal_id === e))])) }, removeCourse: b, className: "results-table", windowSize: x, saveMode: g, setSaveMode: m }) }), (0, a.jsx)(F, { md: 7, lg: 8, xl: 9, children: (0, a.jsx)(lm, { data: y, selectedCourses: c, displayMode: d, aggregateMode: f, saveMode: g, setDisplayMode: h, setAggregateMode: p, className: "the-graph", windowSize: x, theme: r }) }), (0, a.jsx)(F, { children: g && (0, a.jsx)(pm, { data: y, selectedCourses: c, removeCourse: b, aggregateMode: f, windowSize: x, className: "save-table" }) })] }) }, mm = () => (0, a.jsx)("footer", { className: "footer mt-3 py-3 px-3", children: (0, a.jsx)("div", { className: "container fluid text-center", children: (0, a.jsxs)("span", { className: "text-muted", style: { lineHeight: "1em" }, children: ["Built by ", (0, a.jsx)(xi, { href: "https://jeffersonyu1.github.io/", children: "Jefferson Yu" }), ". Designed by ", (0, a.jsx)(xi, { href: "https://www.linkedin.com/in/stephaniewangyh/", children: "Stephanie Wang" }), ".", false, (0, a.jsxs)("span", { children: [" Help us keep the site up by ", (0, a.jsx)(xi, { href: "https://www.paypal.com/donate/?business=W8XQ2L48JH4PC&no_recurring=0&item_name=Help+us+keep+UT+Grades%2B+alive%21&currency_code=USD", children: "supporting it here!" })] })] }) }) }); var bm = n(28), vm = n.n(bm); const ym = (t, n) => { const [r, i] = (0, e.useState)((() => { try { const e = localStorage.getItem(t); return e ? JSON.parse(e) : (localStorage.setItem(t, JSON.stringify(n)), n) } catch (e) { return localStorage.setItem(t, JSON.stringify(n)), n } })); return [r, e => { let n; if ("function" === typeof e) { n = e(r) } else n = e; localStorage.setItem(t, JSON.stringify(n)), i(n) }] }; let xm, wm = ""; const _m = "https://api.utgradesplus.com"; const km = function () { const [t, n] = cl(null, "query", (e => e ? e.toString() : ""), (e => "" === e ? null : e.toString())), [r, i] = (0, e.useState)(null), [o, s] = (0, e.useState)(!0), [l, c] = (0, e.useState)(!1), [u, d] = (0, e.useState)(0), [h, f] = (0, e.useState)(null), [p, g] = (0, e.useState)([]), [m, v] = cl([], "persist", (e => e.join(",")), (e => e.split(",").map((e => parseInt(e))).filter((e => !Number.isNaN(e))))); (0, e.useEffect)((() => { if (t && "" !== t) { if (t !== wm) return xm && clearTimeout(xm), xm = setTimeout((() => { wm = t, y(t) }), 300), () => clearTimeout(xm) } else wm = "", n(null), (() => { for (var e in sl) sl.hasOwnProperty(e) && delete sl[e] })(), c(!1) }), [t, m]); const y = e => { if (!e) return; null == t && s(!0); const r = { "x-api-key": "yourmomdotcom" }; n(e); const o = fetch("".concat(_m, "/api/search?q=").concat(e), { headers: r }), a = m.length > 0 && m.some((e => !p.some((t => t.internal_id === e)))) ? fetch("".concat(_m, "/api/persist-search?q=").concat(m.join(",")), { headers: r }) : Promise.resolve(null); Promise.all([o, a]).then((async e => { let [t, n] = e; var r; if (await (r = 200, new Promise((e => { setTimeout(e, r) }))), !t.ok) { const e = await t.json(); throw new Error(e.message || "Error fetching search data") } const o = await t.json(); let a = []; if (n && !n.ok) { const e = await n.json(); throw new Error(e.message || "Error fetching persist data") } n && (a = await n.json(), g(a)), s(!1), i(o), c(!0), f(null) })).catch((e => { setTimeout(s(!1), 5e3), f(e.message) })) }, [x, w] = ym("theme_toggle", "light"); return (0, e.useEffect)((() => { document.documentElement.setAttribute("data-bs-theme", x) }), [x]), (0, e.useEffect)((() => { const e = new (vm())("Josefin Slab").load(), t = new Promise((e => { "complete" === document.readyState ? e() : window.addEventListener("load", e) })); Promise.all([e, t]).then((() => { s(!1) })).catch((() => { s(!1) })) }), []), (0, e.useEffect)((() => { const e = () => { const e = document.querySelector(".App-header"); e && d(e.offsetHeight) }; return window.addEventListener("resize", e), e(), () => { window.removeEventListener("resize", e) } }), []), (0, a.jsx)("div", { className: "App", children: (0, a.jsxs)("div", { className: "".concat(o ? "zero-opacity" : "full-opacity"), children: [(0, a.jsx)("header", { className: "App-header", children: (0, a.jsx)(na, { hasSearchResults: l, theme: x, toggleTheme: () => { w("light" === x ? "dark" : "light") } }) }), (0, a.jsxs)("div", { className: "main-content-wrapper ".concat(o ? "zero-opacity" : "full-opacity"), style: { minHeight: "calc(100vh - ".concat(u, "px)") }, children: [(0, a.jsx)(b, { fluid: !0, className: "px-4 ".concat(l ? "pt-3" : "d-flex align-items-center justify-content-center"), style: { flexGrow: 1 }, children: (0, a.jsxs)("div", { children: [!l && (0, a.jsx)("h1", { className: "mb-4 text-uppercase", children: "UT Grades+" }), (0, a.jsxs)(a.Fragment, { children: [(0, a.jsx)(Ci, { hasResults: l, onSearch: y, searchQuery: t, setSearchQuery: n }), !l && (0, a.jsx)("p", { className: "invisible", children: (0, a.jsx)("br", {}) }), h && (0, a.jsxs)("p", { children: ["We hit a snag. Try again momentarily.", (0, a.jsx)("br", {}), h] }), l && (0, a.jsx)(gm, { data: r, theme: x, searchQuery: t, persistedCourseData: p, setPersistedCourseData: g, setPersistedCourseList: v })] }), false] }) }), (0, a.jsx)(mm, {})] })] }) }) }, Sm = e => { e && e instanceof Function && n.e(787).then(n.bind(n, 787)).then((t => { let { getCLS: n, getFID: r, getFCP: i, getLCP: o, getTTFB: a } = t; n(e), r(e), i(e), o(e), a(e) })) }; var Cm = "@vercel/analytics", Em = "1.1.1", Mm = () => { window.va || (window.va = function () { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; (window.vaq = window.vaq || []).push(t) }) }; function Om() { return "undefined" !== typeof window } function Pm() { try { const e = "production"; if ("development" === e || "test" === e) return "development" } catch (Da) { } return "production" } function Nm() { return (Om() ? window.vam : Pm()) || "production" } function Tm() { return "development" === Nm() } function jm() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { debug: !0 }; var t; if (!Om()) return; !function () { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "auto"; window.vam = "auto" !== e ? e : Pm() }(e.mode), Mm(), e.beforeSend && (null == (t = window.va) || t.call(window, "beforeSend", e.beforeSend)); const n = Tm() ? "https://va.vercel-scripts.com/v1/script.debug.js" : "/_vercel/insights/script.js"; if (document.head.querySelector('script[src*="'.concat(n, '"]'))) return; const r = document.createElement("script"); r.src = n, r.defer = !0, r.setAttribute("data-sdkn", Cm), r.setAttribute("data-sdkv", Em), r.onerror = () => { const e = Tm() ? "Please check if any ad blockers are enabled and try again." : "Be sure to enable Web Analytics for your project and deploy again. See https://vercel.com/docs/analytics/quickstart for more information."; console.log("[Vercel Web Analytics] Failed to load script from ".concat(n, ". ").concat(e)) }, Tm() && !1 === e.debug && r.setAttribute("data-debug", "false"), document.head.appendChild(r) } function Dm(t) { let { beforeSend: n, debug: r = !0, mode: i = "auto" } = t; return (0, e.useEffect)((() => { jm({ beforeSend: n, debug: r, mode: i }) }), [n, r, i]), null } r.createRoot(document.getElementById("root")).render((0, a.jsxs)(e.StrictMode, { children: [(0, a.jsx)(Dm, {}), (0, a.jsx)(Zs, { children: (0, a.jsxs)(Qs, { children: [(0, a.jsx)(qs, { path: "/", element: (0, a.jsx)(km, {}) }), (0, a.jsx)(qs, { path: "*", element: (0, a.jsx)(Ys, { to: "/", replace: !0 }) })] }) })] })), Sm() })() })();
//# sourceMappingURL=main.aeb5555c.js.map